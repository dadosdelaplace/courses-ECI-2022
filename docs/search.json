[{"path":"index.html","id":"prefacio","chapter":"Prefacio","heading":"Prefacio","text":"Este material ha sido diseñado como complemento y recursos de apoyo al curso de la Escuela de Invierno de la UCM titulado «Analizando datos, visualizando información, contando historias», celebrado presencialmente del 31 de enero al 4 de febrero de 2022 (16:00 21:00 horas, de lunes viernes).El presente material introductorio ha sido elaborado por Javier Álvarez Liébana y Gabriel Valverde Castilla, y tiene como objetivo introducir en el lenguaje R todas aquellas personas que quieran aprender R desde cero. Dicho manual ha sido elaborado su vez en R con {bookdown}. Puedes ver un resumen de las funcionalidades de algunos paquetes documentados por el equipo de R Studio en sus esquemas resumen. El código de dicho manual se encuentra en GitHub. Para elaborar informes o libros con una estructura similar (de forma nativa en R) el paquete bookdown puede ser instalado desde la plataforma CRAN o desde su versión en desarrollo actualizada en Github:","code":"\ninstall.packages(\"bookdown\")\n# o desde su versión en desarrollo actualizada\n# devtools::install_github(\"rstudio/bookdown\")"},{"path":"index.html","id":"propósito","chapter":"Prefacio","heading":"Propósito","text":"El objetivo de este curso es introducir la programación y análisis estadístico en R toda aquella persona que nunca se haya iniciado en él, sin necesitar conocimientos previos de programación (aunque siempre ayuda, obviamente). se pretende que adquieras un vasto y experto conocimiento, pero si lo suficiente como para lograr 5 objetivos:tener miedo programarEntender los conceptos básicos de R.Dotarte de autonomía para poder trabajar con datos.Introducirte en el análisis estadístico.Adquirir las competencias necesarias para la visualización de datos en R.","code":""},{"path":"index.html","id":"contenidos","chapter":"Prefacio","heading":"Contenidos","text":"Toma de contacto1 Requisitos2 Instalación de R y Rstudio3 ¿Qué es R?4 Primeros pasos Conceptos básicos5 Tipos de datos6 Vectores7 Operaciones con vectores8 Datos estructurados9 Repaso: empezando trastear con datos Estructuras de control10 Estructuras condicionales -else11 Bucles **Estructuras de control*12 Primer proyecto de trabajo13 Funciones14 Listas","code":""},{"path":"index.html","id":"código-de-colores","chapter":"Prefacio","heading":"Código de colores","text":"Puedes buscar los siguientes términos en el buscador del documentoERROR:En color rojo encontrarás errores comunes o prácticas evitar.WARNING:En color naranja/amarillo encontrarás warnings o advertencias sobre cosas tener en cuenta para evitar problemas.Algunas funciones pueden arrojar ciertas advertencias que nunca está de más leer. Pero si dichos mensajes de alerta los tenemos controlados, y queremos que nos ensucie la ejecución en la consola, podemos poner al inicio del código assign(\"last.warning\", NULL, envir = baseenv()) para limpiar los warnings antiguos y options(warn = -1) para desactivarlos.CONSEJO:En color verde encontrarás consejos o tips para ampliar y facilitar tu programación. Además en cada cajita de código, si pasas el ratón, encontrarás un botón 📄📄 en la esquina superior derecha de la caja para copiar el código directamente tu consola. Puedes encontrarlos todos escribiendo «consejo» en el buscador.GLOSARIO:En color azul encontrarás un 📚 glosario con algunos términos estadísticos y conceptos básicos.","code":""},{"path":"index.html","id":"licencia","chapter":"Prefacio","heading":"Licencia","text":"Este documento es publicado bajo licencia pública general GNU,\nuna licencia libre de copyleft que garantiza los usuarios finales (personas, organizaciones, compañías) la libertad de usar, estudiar, compartir (copiar) y modificar el software, citando adecuadamente los autores del mismo.","code":""},{"path":"ejercicios-recopilados.html","id":"ejercicios-recopilados","chapter":"📝 Ejercicios recopilados","heading":"📝 Ejercicios recopilados","text":"Aquí haremos una recopilación de los ejercicios planteados lo largo del curso. Vuelve por aquí si quieres cuando acabas las lecciones para repasar aquellos ejercicios que más te hayan costado.","code":""},{"path":"ejercicios-recopilados.html","id":"primeros-pasos","chapter":"📝 Ejercicios recopilados","heading":"Primeros pasos","text":"Scripts usados:script01.R: toma de contacto. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script01.R(haz click en las flechas para ver soluciones)📝Ejercicio 1: en tu consola (parte inferior de tu pantalla), asigna los valores 2 y 5 dos variables y b. Tras asignarles valores, multiplica los números en consola (haz click en la flecha para la solución propuesta). Solución:\nImagen/gráfica 0.1: Multiplicación de y b.\n 📝Ejercicio 2: modifica el código inferior para definir dos variables c y d, con valores 3 y -1, y calcular la división c/d (haz click en la flecha para la solución propuesta).Solución: 📝Ejercicio 3: repite el ejercicio 1 pero ahora guarda el resultado de la multiplicación final en una variable c. Para ver el resultado guardado en c escribe dicha variable en consola (haz click en la flecha para la solución propuesta). Solución:\nImagen/gráfica 0.2: Multiplicación de y b guardando el resultado.\n 📝Ejercicio 4: asigna ahora los valores 1, -2, 3 tres variables , b y c, y calcula la raíz cuadrada de cada uno. Solución: 📝Ejercicio 5: repite el ejercicio 3 pero ahora escribe el código en un script (fichero de .R, guardado en script01.R). Recuerda al acabar seleccionar las líneas ejecutar y clickar Run, o bien guardar el script con Source save activado (haz click en la flecha para la solución propuesta). Solución:\nImagen/gráfica 0.3: Multiplicación de y b guardando el resultado pero escribiendo en el script.\n 📝Ejercicio 6: calcula en consola la suma de 3 más 4, y todo ello multiplicado por 10, y asígnalo una variable x (haz click en la flecha para la solución propuesta).Solución: 📝Ejercicio 7: asigna un valor positivo x y calcula su raíz cuadrada; asigna otro negativo y calcula su valor absoluto (haz click en la flecha para la solución propuesta).Solución: CONSEJO:Las órdenes sqrt(x) y abs(y) se llaman funciones, y la variable que tienen entre paréntesis se llama argumento de la función: una variable que toma de entrada la función y con la que opera internamente. 📝Ejercicio 8: usando la variable x ya definida, calcula la resta x - 5 y guárdala en una nueva variable z (haz click en la flecha para la solución propuesta).Solución: 📝Ejercicio 9: usando las variables x y z ya definidas, calcula el máximo de ambas, y guárdalo en una nueva variable t. (haz click en la flecha para la solución propuesta).Solución: WARNING:hace falta gastar una línea por cada orden que quieras ejecutar. Tampoco necesitas guardar cada paso intermedio que realices. Cuidado con la memoria: cada asignación que hagas es una variable guardada que consume recursos en tu ordenador.","code":"\n# Para poner comentarios en el código se usa #\n\n# Definición de variables\na <- 2\nb <- 5\n\n# Multiplicación\na * b## [1] 10\n# Definición de variables\nc <- \nd <-\n\n# Operación (división)\nc ? d\n# Definición de variables\nc <- 3\nd <- -1\n\n# División\na / b## [1] 0.4\n# Variables\na <- 2\nb <- 5\n\n# Resultado\nc <- a * b\n\n# Muestro en consola\nc## [1] 10\n# Variables\na <- 1\nb <- -2\nc <- 3\n\n# Resultado\nsqrt(a)## [1] 1\nsqrt(b)## [1] NaN\nsqrt(c)## [1] 1.732051\nx <- (3 + 4) * 10\n# Raíz cuadrada\nx <- 73\nsqrt(x)## [1] 8.544004\n# Valor absoluto\ny <- -73\nabs(y)## [1] 73\nz <- x - 5\nz## [1] 68\nt <- max(x, z)\nt## [1] 73"},{"path":"ejercicios-recopilados.html","id":"tipos-de-datos","chapter":"📝 Ejercicios recopilados","heading":"Tipos de datos","text":"Scripts usados:script02.R: tipos de datos y funciones usadas con ellos. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script02.R(haz click en las flechas para ver soluciones)📝Ejercicio 1: define una variable que guarde tu edad, otra con tu nombre, otra respondiendo la pregunta «¿tengo hermanos?» y otra con la fecha de tu nacimiento. Solución: 📝Ejercicio 2: define otra variable con tus apellidos y junta las variables nombre y apellidos en una sola variable nombre_completo. Solución: 📝Ejercicio 3: construye una frase que diga «Hola, llamo … y tengo … años. Nací el … de … de …» (con el nombre completo). Solución: 📝Ejercicio 4: calcula los días que han pasado desde la fecha de tu nacimiento Solución: 📝Ejercicio 5: obtén una variable lógica que nos diga si se cumplen (todas) las condiciones ) menor de 30 años (edad < 30); ii) con hermanos (hermanos == TRUE); iii) nacido en 1990 o posterior (fecha_nacimiento >= .Date(\"1990-01-01\")). Solución: 📝Ejercicio 6: modifica el código del ejercicio anterior para obtener una variable lógica que nos diga si se cumplen (al menos) alguna de las condiciones ) menor de 30 años; ii) con hermanos; iii) nacido en 1990 o posterior. Al contrario que antes, necesitamos que se cumplan todas, nos basta con que se cumple al menos una. Solución: 📝Ejercicio 7: calcula la fecha 11 días más tarde tu fecha de nacimiento. Obtén la semana del año de dicha fecha y el día de la semana con las funciones week, wday y weekdays. Solución: 📝Ejercicio 8: define dos números cualesquiera en variable y b. Calcula su suma y determina cual es mayor. Solución: ","code":"\nedad <- 32 # tipo numeric\nnombre <- \"Javier\" # tipo caracter\nhermanos <- TRUE # tipo hermanos\nfecha_nacimiento <- as.Date(\"1989-09-10\") # tipo fecha\nlibrary(glue)\n\n# Apellidos\napellidos <- \"Álvarez Liébana\"\n\n# Pegamos\nnombre_completo <- glue(\"{nombre} {apellidos}\")\nnombre_completo## Javier Álvarez Liébana\n# Otra forma\nnombre_completo <- paste(nombre, apellidos)\nnombre_completo## [1] \"Javier Álvarez Liébana\"\nlibrary(lubridate)\ndia_nacimiento <- day(fecha_nacimiento)\nmes_nacimiento <- month(fecha_nacimiento)\na_nacimiento <- year(fecha_nacimiento)\n\nglue(\"Hola, me llamo {nombre_completo} y tengo {edad} años. Nací el {dia_nacimiento} del {mes_nacimiento} de {a_nacimiento}\")## Hola, me llamo Javier Álvarez Liébana y tengo 32 años. Nací el 10 del 9 de 1989\ndays(today() - fecha_nacimiento)## [1] \"11805d 0H 0M 0S\"\n# Se tienen que cumplir todas\nedad < 30 & fecha_nacimiento >= as.Date(\"1990-01-01\") & hermanos## [1] FALSE\n# otra forma\nedad < 30 & fecha_nacimiento >= as.Date(\"1990-01-01\") & hermanos == TRUE## [1] FALSE\n# Se tienen que cumplir todas\nedad < 30 | fecha_nacimiento >= as.Date(\"1990-01-01\") | hermanos## [1] TRUE\n# Podemos sumar porque es fecha\nfecha_post <- fecha_nacimiento + 11\nfecha_post## [1] \"1989-09-21\"\n# Semana del año\nweek(fecha_post)## [1] 38\n# Día de la semana (versión americana, empiezan el domingo)\nwday(fecha_post)## [1] 5\n# Día de la semana (versión española)\nwday(fecha_post, week_start = 1)## [1] 4\n# Día de la semana en texto\nweekdays(fecha_post)## [1] \"Thursday\"\na <- -5\nb <- 7\n\n# Suma\nc <- a + b\nc## [1] 2\n# Comparaciones\na == b # ¿a = b?## [1] FALSE\na < b # ¿a < b?## [1] TRUE"},{"path":"ejercicios-recopilados.html","id":"vectores","chapter":"📝 Ejercicios recopilados","heading":"Vectores","text":"Scripts usados:script03.R: vectores. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script03.R(haz click en las flechas para ver soluciones)📝Ejercicio 1: modifica el código anterior para crear un vector de nombre vector_num que contenga los números 1, 5 y -7.Solución: 📝Ejercicio 2: define un vector que contenga los números 1, 10, -1 y 2, y guárdalo en una variable llamada vector_num. Solución: 📝Ejercicio 3: obtén la longitud del vector anterior vector_num. Solución: 📝Ejercicio 4: crea un vector con las palabras “Hola”, “”, “llamo” (y tu nombre y apellidos), y pega luego sus elementos de forma que la frase esté correctamente escrita en castellano. Tras hacerlo, añade “y tengo 30 años”. Solución: 📝Ejercicio 5: el código inferior crea una secuencia de números, que empieza en -1, que acaba en 32, y que va saltando de 2 en 2. Modíficalo para que haga el salto de 3 en 3 y guárdalo en una variable llamada secuencia.Solución: 📝Ejercicio 6: crea una secuencia de números, que empiece en -1, que acabe en 32, y que tenga longitud 12. Solución: 📝Ejercicio 7: crea una secuencia que empiece en 1 y recorra todos los naturales hasta el 10. Después crea otra secuencia de longitud 7 que todos los números sean 3. Solución: 📝Ejercicio 8: crea una secuencia que repita 5 veces el patrón 1, 2, 3. Después crea otra que repita dicho patrón pero de forma intercalada, con 5 veces 1, después 5 veces 2 y después 5 veces 3.Solución: 📝Ejercicio 9: crea un vector con las edades de cuatro conocidos o familiares. Tras ello, determina cuáles de ellos tienen menos de 20 años, 30 años o más, menos de 40 años y más de 65 años.Solución:","code":"\n# Vector de números\nvector_num <- c(1)\nvector_num\n# Vector de números\nvector_num <- c(1, 5, -7)\nvector_num## [1]  1  5 -7\n# Vector de números\nvector_num <- c(1, 10, -1, 2)\nvector_num## [1]  1 10 -1  2\n# Longitud del vector\nlength(vector_num)## [1] 4\n# Definiendo el vector\nvector_char <- c(\"Hola\", \"me\", \"llamo\", \"Javier\",\n                 \"Álvarez\", \"Liébana\")\n\n# Pegamos\nfrase <- paste(vector_char, collapse = \" \")\nfrase## [1] \"Hola me llamo Javier Álvarez Liébana\"\n# Añadimos frase\nglue(\"{frase} y tengo 30 años.\")## Hola me llamo Javier Álvarez Liébana y tengo 30 años.\n# Otra forma\npaste0(frase, \" y tengo 30 años.\")## [1] \"Hola me llamo Javier Álvarez Liébana y tengo 30 años.\"\n# Otra forma\npaste(frase, \"y tengo 30 años.\")## [1] \"Hola me llamo Javier Álvarez Liébana y tengo 30 años.\"\nseq(-1, 32, by = 2)\nsecuencia <- seq(-1, 32, by = 3)\nsecuencia##  [1] -1  2  5  8 11 14 17 20 23 26 29 32\nlength(secuencia) # longitud de la secuencia## [1] 12\nsecuencia <- seq(-1, 32, l = 12)\nsecuencia##  [1] -1  2  5  8 11 14 17 20 23 26 29 32\nlength(secuencia) # longitud de la secuencia## [1] 12\n1:10##  [1]  1  2  3  4  5  6  7  8  9 10\nrep(3, 7) # secuencia repetida## [1] 3 3 3 3 3 3 3\nrep(c(1, 2, 3), 5) # repetimos patrón (1, 2, 3) 5 veces##  [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3\nrep(c(1, 2, 3), each = 5) # repetimos patrón alternado##  [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3\nedades <- c(27, 32, 60, 61) # en mi caso, por ejemplo\nedades < 20 # menos de 20 años## [1] FALSE FALSE FALSE FALSE\nedades >= 30 # 30 años o más## [1] FALSE  TRUE  TRUE  TRUE\nedades < 40 # menos de 40 años## [1]  TRUE  TRUE FALSE FALSE\nedades > 65 # más de 65 años## [1] FALSE FALSE FALSE FALSE"},{"path":"ejercicios-recopilados.html","id":"operaciones-con-vectores","chapter":"📝 Ejercicios recopilados","heading":"Operaciones con vectores","text":"Scripts usados:script04.R: operaciones con vectores. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script04.R(haz click en las flechas para ver soluciones)📝Ejercicio 1: define de nuevo el vector vector_num definido como un vector que contenga los números 1, 10, -1 y 2) y calcula su suma del vector. Solución: 📝Ejercicio 2: define otro vector vector_num2 que contenga los números 5, -7, 8, -3, y haz la suma de vector_num y vector_num2. Solución: 📝Ejercicio 3: calcula el número de elementos mayores que 0 del resultado de la suma de vector_num y vector_num2. Solución: 📝Ejercicio 4: calcula la versión ordenada del vector vector_num. Solución: 📝Ejercicio 5: encuentra del vector vector_num original el lugar (el índice) que ocupa su mínimo y su máximo. Solución: 📝Ejercicio 6: encuentra del vector vector_num los elementos mayores que 1 y menores que 7. Encuentra una forma de averiguar si todos los elementos son o positivos. Solución: 📝Ejercicio 7: define el vector c(-1, 0, 4, 5, -2), calcula la raíz cuadrada del vector y determina que lugares son ausente de tipo NaN. Solución: 📝Ejercicio 8: define el vector de los primeros números impares (hasta el 21) y extrae los elementos que ocupan los lugares 1, 4, 5, 8. Elimina del vector el segundo elementoSolución:","code":"\n# Vector de números\nvector_num <- c(1, 10, -1, 2)\n\n# Suma\nsum(vector_num)## [1] 12\n# Vector de números\nvector_num2 <- c(5, -7, 8, -3)\n\n# Suma\nvector_num + vector_num2## [1]  6  3  7 -1\n# Vector de números\nvector_suma <- vector_num + vector_num2\n\n# Suma\nsum(vector_suma > 0)## [1] 3\n# Ordenamos el vector (con sort)\nsort(vector_num)## [1] -1  1  2 10\n# Ordenamos el vector  (con order)\nvector_num[order(vector_num)]## [1] -1  1  2 10\nvector_num <- c(1, 10, -1, 2)\n\n# Encontrando el lugar que ocupa el máximo y mínimo\nwhich.max(vector_num)## [1] 2\nwhich.min(vector_num)## [1] 3\n# Vector lógico: mayores que 1 y menores que 7\nvector_num > 1 & vector_num < 7## [1] FALSE FALSE FALSE  TRUE\n# ¿Son todos positivos?\nall(vector_num > 0)## [1] FALSE\n# Vector\nx <- c(-1, 0, 4, 5, -2)\n\n# ¿Cuáles son ausentes tras aplicar la raíz cuadrada?\nis.nan(sqrt(x))## [1]  TRUE FALSE FALSE FALSE  TRUE\n# Vector de impares (de 1 a 21 saltando de dos en dos)\nx <- seq(1, 21, by = 2)\n\n# Seleccionamos elementos\nx[c(1, 4, 5, 8)]## [1]  1  7  9 15\n# Eliminamos elementos\ny <- x[-2]\ny##  [1]  1  5  7  9 11 13 15 17 19 21"},{"path":"ejercicios-recopilados.html","id":"estructuras-de-datos-matrices-y-tablas-data.frame","chapter":"📝 Ejercicios recopilados","heading":"Estructuras de datos: matrices y tablas (data.frame)","text":"Scripts usados:script05.R: matrices y data.frames. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script05.R(haz click en las flechas para ver soluciones)Ejercicio 1: modifica el código para definir una matriz x de ceros de 3 filas y 7 columnas.Solución: Ejercicio 2: la matriz anterior, suma un 1 cada número de la matriz y divide el resultado entre 5.Solución: Ejercicio 3: tras definir la matriz x calcula su transpuesta y obtén sus dimensionesSolución: Ejercicio 4: el siguiente código define una matriz de dimensiones 4 x 3 y calcula la suma por columnas. Modifica el código para que realice la suma por filas.Solución: Ejercicio 5: con la matriz anterior definida como matrix(1:12, nrow = 4), calcula la media de todos los elementos, la media de cada fila y la media de cada columna.Solución: Ejercicio 6: el data.frame llamado airquality, del paquete {datasets}, contiene variables de la calidad del aire de la ciudad de Nueva York desde mayo hasta septiembre de 1973. Obtén el nombre de las variables.\nSolución: Ejercicio 7: obtén las dimensiones del conjunto de datos. ¿Cuántas variables hay? ¿Cuántos días se han medido?Solución: Ejercicio 8: modifica el código inferior para que nos filtre solo los datos del mes de julio.Solución: Ejercicio 9: del conjunto airquality selecciona aquellos datos que sean ni de julio ni de agosto.Solución: Ejercicio 10: modifica el siguiente código para quedarte solo con las variable Ozone y Temp.Solución: Ejercicio 11: del conjunto airquality selecciona los datos de temperatura y viento de agosto.Solución: Ejercicio 12: calcula el número de filas borradas del ejercicio anterior. Tras hacer todo ello, traduce castellano el nombre de las columnas del data.frame filtrado.Solución: Ejercicio 13: añade los datos originales una columna con la fecha completa (recuerda que es del año 1973 todas las observaciones.Solución: ","code":"\n# Matriz\nx <- matrix(0, nrow = 2, ncol = 3)\nx\n# Matriz\nx <- matrix(0, nrow = 3, ncol = 7)\nx##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n## [1,]    0    0    0    0    0    0    0\n## [2,]    0    0    0    0    0    0    0\n## [3,]    0    0    0    0    0    0    0\n(x + 1) / 5##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n## [1,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n## [2,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n## [3,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n# Transpuesta\nt(x)##      [,1] [,2] [,3]\n## [1,]    0    0    0\n## [2,]    0    0    0\n## [3,]    0    0    0\n## [4,]    0    0    0\n## [5,]    0    0    0\n## [6,]    0    0    0\n## [7,]    0    0    0\n# Dimensiones transpuesta: pasa de ser 3x7 a 7x3\ndim(t(x))## [1] 7 3\nncol(t(x)) # número de columnas de la transpuesta## [1] 3\nnrow(t(x)) # número de filas de la transpuesta## [1] 7\n# Matriz\nmatriz <- matrix(1:12, nrow = 4)\n\n# Suma por columnas\napply(matriz, MARGIN = 2, FUN = \"sum\")## [1] 10 26 42\n# Matriz\nmatriz <- matrix(1:12, nrow = 4)\n\n# Suma por filas\napply(matriz, MARGIN = 1, FUN = \"sum\")## [1] 15 18 21 24\n# Matriz\nmatriz <- matrix(1:12, nrow = 4)\n\n#  media de todos\nmean(matriz)## [1] 6.5\n# Media por filas (MARGIN = 1 ya que es una operación por filas)\napply(matriz, MARGIN = 1, FUN = \"mean\")## [1] 5 6 7 8\n# Media por filas (MARGIN = 2 ya que es una operación por filas)\napply(matriz, MARGIN = 2, FUN = \"mean\")## [1]  2.5  6.5 10.5\nlibrary(datasets)\nnames(airquality)## [1] \"Ozone\"   \"Solar.R\" \"Wind\"    \"Temp\"    \"Month\"   \"Day\"\n# Dimensiones\ndim(airquality)## [1] 153   6\nnrow(airquality)## [1] 153\nncol(airquality)## [1] 6\n# Filtramos filas\nfiltro_fila <- subset(., subset = Month < 6)\nfiltro_fila\n# Filtramos filas\nfiltro_fila <- subset(airquality, subset = Month == 7)\nfiltro_fila##    Ozone Solar.R Wind Temp Month Day\n## 62   135     269  4.1   84     7   1\n## 63    49     248  9.2   85     7   2\n## 64    32     236  9.2   81     7   3\n## 65    NA     101 10.9   84     7   4\n## 66    64     175  4.6   83     7   5\n## 67    40     314 10.9   83     7   6\n## 68    77     276  5.1   88     7   7\n## 69    97     267  6.3   92     7   8\n## 70    97     272  5.7   92     7   9\n## 71    85     175  7.4   89     7  10\n## 72    NA     139  8.6   82     7  11\n## 73    10     264 14.3   73     7  12\n## 74    27     175 14.9   81     7  13\n## 75    NA     291 14.9   91     7  14\n## 76     7      48 14.3   80     7  15\n## 77    48     260  6.9   81     7  16\n## 78    35     274 10.3   82     7  17\n## 79    61     285  6.3   84     7  18\n## 80    79     187  5.1   87     7  19\n## 81    63     220 11.5   85     7  20\n## 82    16       7  6.9   74     7  21\n## 83    NA     258  9.7   81     7  22\n## 84    NA     295 11.5   82     7  23\n## 85    80     294  8.6   86     7  24\n## 86   108     223  8.0   85     7  25\n## 87    20      81  8.6   82     7  26\n## 88    52      82 12.0   86     7  27\n## 89    82     213  7.4   88     7  28\n## 90    50     275  7.4   86     7  29\n## 91    64     253  7.4   83     7  30\n## 92    59     254  9.2   81     7  31\n# Filtramos filas\nfiltro_fila <-\n  subset(airquality, subset = !(Month %in% c(7, 8)))\nfiltro_fila##     Ozone Solar.R Wind Temp Month Day\n## 1      41     190  7.4   67     5   1\n## 2      36     118  8.0   72     5   2\n## 3      12     149 12.6   74     5   3\n## 4      18     313 11.5   62     5   4\n## 5      NA      NA 14.3   56     5   5\n## 6      28      NA 14.9   66     5   6\n## 7      23     299  8.6   65     5   7\n## 8      19      99 13.8   59     5   8\n## 9       8      19 20.1   61     5   9\n## 10     NA     194  8.6   69     5  10\n## 11      7      NA  6.9   74     5  11\n## 12     16     256  9.7   69     5  12\n## 13     11     290  9.2   66     5  13\n## 14     14     274 10.9   68     5  14\n## 15     18      65 13.2   58     5  15\n## 16     14     334 11.5   64     5  16\n## 17     34     307 12.0   66     5  17\n## 18      6      78 18.4   57     5  18\n## 19     30     322 11.5   68     5  19\n## 20     11      44  9.7   62     5  20\n## 21      1       8  9.7   59     5  21\n## 22     11     320 16.6   73     5  22\n## 23      4      25  9.7   61     5  23\n## 24     32      92 12.0   61     5  24\n## 25     NA      66 16.6   57     5  25\n## 26     NA     266 14.9   58     5  26\n## 27     NA      NA  8.0   57     5  27\n## 28     23      13 12.0   67     5  28\n## 29     45     252 14.9   81     5  29\n## 30    115     223  5.7   79     5  30\n## 31     37     279  7.4   76     5  31\n## 32     NA     286  8.6   78     6   1\n## 33     NA     287  9.7   74     6   2\n## 34     NA     242 16.1   67     6   3\n## 35     NA     186  9.2   84     6   4\n## 36     NA     220  8.6   85     6   5\n## 37     NA     264 14.3   79     6   6\n## 38     29     127  9.7   82     6   7\n## 39     NA     273  6.9   87     6   8\n## 40     71     291 13.8   90     6   9\n## 41     39     323 11.5   87     6  10\n## 42     NA     259 10.9   93     6  11\n## 43     NA     250  9.2   92     6  12\n## 44     23     148  8.0   82     6  13\n## 45     NA     332 13.8   80     6  14\n## 46     NA     322 11.5   79     6  15\n## 47     21     191 14.9   77     6  16\n## 48     37     284 20.7   72     6  17\n## 49     20      37  9.2   65     6  18\n## 50     12     120 11.5   73     6  19\n## 51     13     137 10.3   76     6  20\n## 52     NA     150  6.3   77     6  21\n## 53     NA      59  1.7   76     6  22\n## 54     NA      91  4.6   76     6  23\n## 55     NA     250  6.3   76     6  24\n## 56     NA     135  8.0   75     6  25\n## 57     NA     127  8.0   78     6  26\n## 58     NA      47 10.3   73     6  27\n## 59     NA      98 11.5   80     6  28\n## 60     NA      31 14.9   77     6  29\n## 61     NA     138  8.0   83     6  30\n## 124    96     167  6.9   91     9   1\n## 125    78     197  5.1   92     9   2\n## 126    73     183  2.8   93     9   3\n## 127    91     189  4.6   93     9   4\n## 128    47      95  7.4   87     9   5\n## 129    32      92 15.5   84     9   6\n## 130    20     252 10.9   80     9   7\n## 131    23     220 10.3   78     9   8\n## 132    21     230 10.9   75     9   9\n## 133    24     259  9.7   73     9  10\n## 134    44     236 14.9   81     9  11\n## 135    21     259 15.5   76     9  12\n## 136    28     238  6.3   77     9  13\n## 137     9      24 10.9   71     9  14\n## 138    13     112 11.5   71     9  15\n## 139    46     237  6.9   78     9  16\n## 140    18     224 13.8   67     9  17\n## 141    13      27 10.3   76     9  18\n## 142    24     238 10.3   68     9  19\n## 143    16     201  8.0   82     9  20\n## 144    13     238 12.6   64     9  21\n## 145    23      14  9.2   71     9  22\n## 146    36     139 10.3   81     9  23\n## 147     7      49 10.3   69     9  24\n## 148    14      20 16.6   63     9  25\n## 149    30     193  6.9   70     9  26\n## 150    NA     145 13.2   77     9  27\n## 151    14     191 14.3   75     9  28\n## 152    18     131  8.0   76     9  29\n## 153    20     223 11.5   68     9  30\nfiltro_col <- subset(.,  select = c(\"Ozone\"))\nfiltro_col\n# Filtramos columnas\nfiltro_col <- subset(airquality,  select = c(\"Ozone\", \"Temp\"))\nfiltro_col##     Ozone Temp\n## 1      41   67\n## 2      36   72\n## 3      12   74\n## 4      18   62\n## 5      NA   56\n## 6      28   66\n## 7      23   65\n## 8      19   59\n## 9       8   61\n## 10     NA   69\n## 11      7   74\n## 12     16   69\n## 13     11   66\n## 14     14   68\n## 15     18   58\n## 16     14   64\n## 17     34   66\n## 18      6   57\n## 19     30   68\n## 20     11   62\n## 21      1   59\n## 22     11   73\n## 23      4   61\n## 24     32   61\n## 25     NA   57\n## 26     NA   58\n## 27     NA   57\n## 28     23   67\n## 29     45   81\n## 30    115   79\n## 31     37   76\n## 32     NA   78\n## 33     NA   74\n## 34     NA   67\n## 35     NA   84\n## 36     NA   85\n## 37     NA   79\n## 38     29   82\n## 39     NA   87\n## 40     71   90\n## 41     39   87\n## 42     NA   93\n## 43     NA   92\n## 44     23   82\n## 45     NA   80\n## 46     NA   79\n## 47     21   77\n## 48     37   72\n## 49     20   65\n## 50     12   73\n## 51     13   76\n## 52     NA   77\n## 53     NA   76\n## 54     NA   76\n## 55     NA   76\n## 56     NA   75\n## 57     NA   78\n## 58     NA   73\n## 59     NA   80\n## 60     NA   77\n## 61     NA   83\n## 62    135   84\n## 63     49   85\n## 64     32   81\n## 65     NA   84\n## 66     64   83\n## 67     40   83\n## 68     77   88\n## 69     97   92\n## 70     97   92\n## 71     85   89\n## 72     NA   82\n## 73     10   73\n## 74     27   81\n## 75     NA   91\n## 76      7   80\n## 77     48   81\n## 78     35   82\n## 79     61   84\n## 80     79   87\n## 81     63   85\n## 82     16   74\n## 83     NA   81\n## 84     NA   82\n## 85     80   86\n## 86    108   85\n## 87     20   82\n## 88     52   86\n## 89     82   88\n## 90     50   86\n## 91     64   83\n## 92     59   81\n## 93     39   81\n## 94      9   81\n## 95     16   82\n## 96     78   86\n## 97     35   85\n## 98     66   87\n## 99    122   89\n## 100    89   90\n## 101   110   90\n## 102    NA   92\n## 103    NA   86\n## 104    44   86\n## 105    28   82\n## 106    65   80\n## 107    NA   79\n## 108    22   77\n## 109    59   79\n## 110    23   76\n## 111    31   78\n## 112    44   78\n## 113    21   77\n## 114     9   72\n## 115    NA   75\n## 116    45   79\n## 117   168   81\n## 118    73   86\n## 119    NA   88\n## 120    76   97\n## 121   118   94\n## 122    84   96\n## 123    85   94\n## 124    96   91\n## 125    78   92\n## 126    73   93\n## 127    91   93\n## 128    47   87\n## 129    32   84\n## 130    20   80\n## 131    23   78\n## 132    21   75\n## 133    24   73\n## 134    44   81\n## 135    21   76\n## 136    28   77\n## 137     9   71\n## 138    13   71\n## 139    46   78\n## 140    18   67\n## 141    13   76\n## 142    24   68\n## 143    16   82\n## 144    13   64\n## 145    23   71\n## 146    36   81\n## 147     7   69\n## 148    14   63\n## 149    30   70\n## 150    NA   77\n## 151    14   75\n## 152    18   76\n## 153    20   68\n# Todo de una vez\nfiltro <- subset(airquality, subset = Month == 8,\n                 select = c(\"Temp\", \"Wind\"))\nfiltro##     Temp Wind\n## 93    81  6.9\n## 94    81 13.8\n## 95    82  7.4\n## 96    86  6.9\n## 97    85  7.4\n## 98    87  4.6\n## 99    89  4.0\n## 100   90 10.3\n## 101   90  8.0\n## 102   92  8.6\n## 103   86 11.5\n## 104   86 11.5\n## 105   82 11.5\n## 106   80  9.7\n## 107   79 11.5\n## 108   77 10.3\n## 109   79  6.3\n## 110   76  7.4\n## 111   78 10.9\n## 112   78 10.3\n## 113   77 15.5\n## 114   72 14.3\n## 115   75 12.6\n## 116   79  9.7\n## 117   81  3.4\n## 118   86  8.0\n## 119   88  5.7\n## 120   97  9.7\n## 121   94  2.3\n## 122   96  6.3\n## 123   94  6.3\n# Filas borradas\nnrow(airquality) - nrow(filtro)## [1] 122\n# Cambiamos nombres a castellano del conjunto filtrado\nnames(filtro) <- c(\"temperatura\", \"viento\")\n# Construimos las fechas (pegamos año-mes-día con \"-\")\nfechas <- \n  as.Date(paste(\"1973\", airquality$Month, airquality$Day,\n                sep = \"-\"))\n\n# Añadimos\ndata.frame(airquality, fechas)##     Ozone Solar.R Wind Temp Month Day     fechas\n## 1      41     190  7.4   67     5   1 1973-05-01\n## 2      36     118  8.0   72     5   2 1973-05-02\n## 3      12     149 12.6   74     5   3 1973-05-03\n## 4      18     313 11.5   62     5   4 1973-05-04\n## 5      NA      NA 14.3   56     5   5 1973-05-05\n## 6      28      NA 14.9   66     5   6 1973-05-06\n## 7      23     299  8.6   65     5   7 1973-05-07\n## 8      19      99 13.8   59     5   8 1973-05-08\n## 9       8      19 20.1   61     5   9 1973-05-09\n## 10     NA     194  8.6   69     5  10 1973-05-10\n## 11      7      NA  6.9   74     5  11 1973-05-11\n## 12     16     256  9.7   69     5  12 1973-05-12\n## 13     11     290  9.2   66     5  13 1973-05-13\n## 14     14     274 10.9   68     5  14 1973-05-14\n## 15     18      65 13.2   58     5  15 1973-05-15\n## 16     14     334 11.5   64     5  16 1973-05-16\n## 17     34     307 12.0   66     5  17 1973-05-17\n## 18      6      78 18.4   57     5  18 1973-05-18\n## 19     30     322 11.5   68     5  19 1973-05-19\n## 20     11      44  9.7   62     5  20 1973-05-20\n## 21      1       8  9.7   59     5  21 1973-05-21\n## 22     11     320 16.6   73     5  22 1973-05-22\n## 23      4      25  9.7   61     5  23 1973-05-23\n## 24     32      92 12.0   61     5  24 1973-05-24\n## 25     NA      66 16.6   57     5  25 1973-05-25\n## 26     NA     266 14.9   58     5  26 1973-05-26\n## 27     NA      NA  8.0   57     5  27 1973-05-27\n## 28     23      13 12.0   67     5  28 1973-05-28\n## 29     45     252 14.9   81     5  29 1973-05-29\n## 30    115     223  5.7   79     5  30 1973-05-30\n## 31     37     279  7.4   76     5  31 1973-05-31\n## 32     NA     286  8.6   78     6   1 1973-06-01\n## 33     NA     287  9.7   74     6   2 1973-06-02\n## 34     NA     242 16.1   67     6   3 1973-06-03\n## 35     NA     186  9.2   84     6   4 1973-06-04\n## 36     NA     220  8.6   85     6   5 1973-06-05\n## 37     NA     264 14.3   79     6   6 1973-06-06\n## 38     29     127  9.7   82     6   7 1973-06-07\n## 39     NA     273  6.9   87     6   8 1973-06-08\n## 40     71     291 13.8   90     6   9 1973-06-09\n## 41     39     323 11.5   87     6  10 1973-06-10\n## 42     NA     259 10.9   93     6  11 1973-06-11\n## 43     NA     250  9.2   92     6  12 1973-06-12\n## 44     23     148  8.0   82     6  13 1973-06-13\n## 45     NA     332 13.8   80     6  14 1973-06-14\n## 46     NA     322 11.5   79     6  15 1973-06-15\n## 47     21     191 14.9   77     6  16 1973-06-16\n## 48     37     284 20.7   72     6  17 1973-06-17\n## 49     20      37  9.2   65     6  18 1973-06-18\n## 50     12     120 11.5   73     6  19 1973-06-19\n## 51     13     137 10.3   76     6  20 1973-06-20\n## 52     NA     150  6.3   77     6  21 1973-06-21\n## 53     NA      59  1.7   76     6  22 1973-06-22\n## 54     NA      91  4.6   76     6  23 1973-06-23\n## 55     NA     250  6.3   76     6  24 1973-06-24\n## 56     NA     135  8.0   75     6  25 1973-06-25\n## 57     NA     127  8.0   78     6  26 1973-06-26\n## 58     NA      47 10.3   73     6  27 1973-06-27\n## 59     NA      98 11.5   80     6  28 1973-06-28\n## 60     NA      31 14.9   77     6  29 1973-06-29\n## 61     NA     138  8.0   83     6  30 1973-06-30\n## 62    135     269  4.1   84     7   1 1973-07-01\n## 63     49     248  9.2   85     7   2 1973-07-02\n## 64     32     236  9.2   81     7   3 1973-07-03\n## 65     NA     101 10.9   84     7   4 1973-07-04\n## 66     64     175  4.6   83     7   5 1973-07-05\n## 67     40     314 10.9   83     7   6 1973-07-06\n## 68     77     276  5.1   88     7   7 1973-07-07\n## 69     97     267  6.3   92     7   8 1973-07-08\n## 70     97     272  5.7   92     7   9 1973-07-09\n## 71     85     175  7.4   89     7  10 1973-07-10\n## 72     NA     139  8.6   82     7  11 1973-07-11\n## 73     10     264 14.3   73     7  12 1973-07-12\n## 74     27     175 14.9   81     7  13 1973-07-13\n## 75     NA     291 14.9   91     7  14 1973-07-14\n## 76      7      48 14.3   80     7  15 1973-07-15\n## 77     48     260  6.9   81     7  16 1973-07-16\n## 78     35     274 10.3   82     7  17 1973-07-17\n## 79     61     285  6.3   84     7  18 1973-07-18\n## 80     79     187  5.1   87     7  19 1973-07-19\n## 81     63     220 11.5   85     7  20 1973-07-20\n## 82     16       7  6.9   74     7  21 1973-07-21\n## 83     NA     258  9.7   81     7  22 1973-07-22\n## 84     NA     295 11.5   82     7  23 1973-07-23\n## 85     80     294  8.6   86     7  24 1973-07-24\n## 86    108     223  8.0   85     7  25 1973-07-25\n## 87     20      81  8.6   82     7  26 1973-07-26\n## 88     52      82 12.0   86     7  27 1973-07-27\n## 89     82     213  7.4   88     7  28 1973-07-28\n## 90     50     275  7.4   86     7  29 1973-07-29\n## 91     64     253  7.4   83     7  30 1973-07-30\n## 92     59     254  9.2   81     7  31 1973-07-31\n## 93     39      83  6.9   81     8   1 1973-08-01\n## 94      9      24 13.8   81     8   2 1973-08-02\n## 95     16      77  7.4   82     8   3 1973-08-03\n## 96     78      NA  6.9   86     8   4 1973-08-04\n## 97     35      NA  7.4   85     8   5 1973-08-05\n## 98     66      NA  4.6   87     8   6 1973-08-06\n## 99    122     255  4.0   89     8   7 1973-08-07\n## 100    89     229 10.3   90     8   8 1973-08-08\n## 101   110     207  8.0   90     8   9 1973-08-09\n## 102    NA     222  8.6   92     8  10 1973-08-10\n## 103    NA     137 11.5   86     8  11 1973-08-11\n## 104    44     192 11.5   86     8  12 1973-08-12\n## 105    28     273 11.5   82     8  13 1973-08-13\n## 106    65     157  9.7   80     8  14 1973-08-14\n## 107    NA      64 11.5   79     8  15 1973-08-15\n## 108    22      71 10.3   77     8  16 1973-08-16\n## 109    59      51  6.3   79     8  17 1973-08-17\n## 110    23     115  7.4   76     8  18 1973-08-18\n## 111    31     244 10.9   78     8  19 1973-08-19\n## 112    44     190 10.3   78     8  20 1973-08-20\n## 113    21     259 15.5   77     8  21 1973-08-21\n## 114     9      36 14.3   72     8  22 1973-08-22\n## 115    NA     255 12.6   75     8  23 1973-08-23\n## 116    45     212  9.7   79     8  24 1973-08-24\n## 117   168     238  3.4   81     8  25 1973-08-25\n## 118    73     215  8.0   86     8  26 1973-08-26\n## 119    NA     153  5.7   88     8  27 1973-08-27\n## 120    76     203  9.7   97     8  28 1973-08-28\n## 121   118     225  2.3   94     8  29 1973-08-29\n## 122    84     237  6.3   96     8  30 1973-08-30\n## 123    85     188  6.3   94     8  31 1973-08-31\n## 124    96     167  6.9   91     9   1 1973-09-01\n## 125    78     197  5.1   92     9   2 1973-09-02\n## 126    73     183  2.8   93     9   3 1973-09-03\n## 127    91     189  4.6   93     9   4 1973-09-04\n## 128    47      95  7.4   87     9   5 1973-09-05\n## 129    32      92 15.5   84     9   6 1973-09-06\n## 130    20     252 10.9   80     9   7 1973-09-07\n## 131    23     220 10.3   78     9   8 1973-09-08\n## 132    21     230 10.9   75     9   9 1973-09-09\n## 133    24     259  9.7   73     9  10 1973-09-10\n## 134    44     236 14.9   81     9  11 1973-09-11\n## 135    21     259 15.5   76     9  12 1973-09-12\n## 136    28     238  6.3   77     9  13 1973-09-13\n## 137     9      24 10.9   71     9  14 1973-09-14\n## 138    13     112 11.5   71     9  15 1973-09-15\n## 139    46     237  6.9   78     9  16 1973-09-16\n## 140    18     224 13.8   67     9  17 1973-09-17\n## 141    13      27 10.3   76     9  18 1973-09-18\n## 142    24     238 10.3   68     9  19 1973-09-19\n## 143    16     201  8.0   82     9  20 1973-09-20\n## 144    13     238 12.6   64     9  21 1973-09-21\n## 145    23      14  9.2   71     9  22 1973-09-22\n## 146    36     139 10.3   81     9  23 1973-09-23\n## 147     7      49 10.3   69     9  24 1973-09-24\n## 148    14      20 16.6   63     9  25 1973-09-25\n## 149    30     193  6.9   70     9  26 1973-09-26\n## 150    NA     145 13.2   77     9  27 1973-09-27\n## 151    14     191 14.3   75     9  28 1973-09-28\n## 152    18     131  8.0   76     9  29 1973-09-29\n## 153    20     223 11.5   68     9  30 1973-09-30"},{"path":"ejercicios-recopilados.html","id":"estructuras-condicionales","chapter":"📝 Ejercicios recopilados","heading":"Estructuras condicionales","text":"Scripts usados:script07.R: -else. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script07.R(haz click en las flechas para ver soluciones)📝Ejercicio 1: modifica el código inferior para imprimir un mensaje por pantalla si todos los mamíferos del conjunto MASS::mammals pesan menos de una tonelada (variable body).Solución: 📝Ejercicio 2: modifica el código inferior para imprimir un mensaje por pantalla si alguno de los mamíferos del conjunto MASS::mammals pesan menos de una tonelada (variable body).Solución: 📝Ejercicio 3: modifica el código inferior para imprimir un mensaje por pantalla si el tercer mamífero del conjunto MASS::mammals tiene un cerebro que pesa más de 100 gr (variable brain).Solución:imprime nada porque cumple la condición. 📝Ejercicio 4: del paquete lubridate, la función hour() nos devuelve la hora de una fecha dada, y la función now() nos devuelve fecha y hora del momento actual. Con ambas funciones, y usando , imprime por pantalla \"buenas noches\" solo partir de las 21 horas. Solución: 📝Ejercicio 5: con las funciones del ejercicio anterior, y usando una estructura -else, imprime por pantalla \"buenos días\" (de 6 14 horas), \"buenas tardes\" (de 14 21 horas) o \"buenas noches\" (de las 21 las 6 horas). Solución: 📝Ejercicio 6: realiza el ejercicio anterior pero sin estructura de llaves, de forma concisa con ifelse(). Mira la ayuda si la necesitases poniendo ? ifelse. Solución: ","code":"\npeso <- MASS::mammals$body\n\nif (peso[1] == 1000) {\n  \n  print(\"Todos los mamíferos guardados pesan menos de una tonelada\")\n  \n}\npeso <- MASS::mammals$body\n\nif (all(peso < 1000)) {\n  \n  print(\"Todos los mamíferos guardados pesan menos de una tonelada\")\n  \n}\npeso <- MASS::mammals$body\n\nif (peso[1] == 1000) {\n  \n  print(\"Alguno de los mamíferos guardados pesan menos de una tonelada\")\n  \n}\npeso <- MASS::mammals$body\n\nif (any(peso < 1000)) {\n  \n  print(\"Alguno de los mamíferos guardados pesan menos de una tonelada\")\n  \n}## [1] \"Alguno de los mamíferos guardados pesan menos de una tonelada\"\npeso <- MASS::mammals$body\n\nif (peso[1] == 1000) {\n  \n  print(\"El tercer mamífero tiene un cerebro que pesa más de 100 gr.\")\n  \n}\ncerebro <- MASS::mammals$brain\n\nif (cerebro[3] > 100) {\n  \n  print(\"El tercer mamífero tiene un cerebro que pesa más de 100 gr.\")\n  \n}\n# Cargamos librería\nlibrary(lubridate)\n\n# Fecha-hora actual\nfecha_actual <- now()\n\n# Estructura if\nif (hour(fecha_actual) > 21) {\n  \n  cat(\"Buenas noches\") # print/cat dos formas de imprimir por pantalla\n}\n# Fecha actual\nfecha_actual <- now()\n\n# Estructura if-else\nif (hour(fecha_actual) > 6 & hour(fecha_actual) < 14) {\n  \n  cat(\"Buenos días\")\n  \n} else if (hour(fecha_actual) > 14 & hour(fecha_actual) < 21) {\n  \n  cat(\"Buenas tardes\")\n  \n} else {\n  \n  cat(\"Buenas noches\")\n}## Buenas noches\n# Fecha actual\nfecha_actual <- now()\n\n# Estructura if-else\ncat(ifelse(hour(fecha_actual) > 6 & hour(fecha_actual) < 14,\n           \"Buenos días\",\n           ifelse(hour(fecha_actual) > 14 &\n                    hour(fecha_actual) < 21,\n                  \"Buenas tardes\", \"Buenas noches\")))## Buenas noches"},{"path":"ejercicios-recopilados.html","id":"bucles","chapter":"📝 Ejercicios recopilados","heading":"Bucles","text":"Scripts usados:script08.R: bucles. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script08.R(haz click en las flechas para ver soluciones)📝Ejercicio 1: modifica el código interior para diseñar un bucle de 5 iteraciones que recorra los 5 primeros impares y les sume uno.Solución: 📝Ejercicio 2: modifica el código interior para diseñar un bucle que parta con una variable conteo <- 1 y pare cuando llegue 6.Solución: 📝Ejercicio 3: construye un bucle que recorra las primeras 8 filas del conjunto de datos MASS::mammals y que imprima el peso del animal (en kg) multiplicado por 1000 (gramos).Solución: 📝Ejercicio 4: diseña un bucle de 200 iteraciones que, empezando en un valor inicial de 100 (euros), te sume 3€ si el número actual es par y te reste 5€ si es impar.Un número par o impar: un número par será todo aquel número que al dividir entre 2, la división es exacta, es decir, que su resto es nulo. Por ejemplo, al dividir 5 entre 2, el resto es 1, pero al dividir 12 entre 2 el resto es 0. Para calcula ese resto usaremos la función %%.Solución: 📝Ejercicio 5: diseña el anterior bucle pero guardando el dinero de cada iteración.Solución: 📝Ejercicio 6: diseña el bucle del ejercicio 4 parando cuando nos quede dinero.Solución:","code":"\nfor (i in 1:5) {\n  \n  print(i)\n}## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\n# Una forma\nfor (i in seq(1, 9, by = 2)) {\n  \n  print(i + 1)\n}## [1] 2\n## [1] 4\n## [1] 6\n## [1] 8\n## [1] 10\n# Otra\nfor (i in c(1, 3, 5, 7, 9)) {\n  \n  print(i + 1)\n}## [1] 2\n## [1] 4\n## [1] 6\n## [1] 8\n## [1] 10\nconteo <- 1\nwhile (conteo == 2) {\n  \n  print(conteo)\n}\nconteo <- 1\nwhile (conteo < 6) {\n  \n  print(conteo)\n  conteo <- conteo <- conteo + 1\n}## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\nfor (i in 1:8) {\n  \n  print(MASS::mammals$body[i] * 1000)\n}## [1] 3385\n## [1] 480\n## [1] 1350\n## [1] 465000\n## [1] 36330\n## [1] 27660\n## [1] 14830\n## [1] 1040\n5 %% 2## [1] 1\n12 %% 2## [1] 0\n23 %% 2## [1] 1\n46 %% 2## [1] 0\n# dinero inicial\ndinero <- 100\n\n# Bucle for\nfor (i in 1:200) {\n  \n  dinero <- ifelse(dinero %% 2 == 0, dinero + 3, dinero  - 5)\n  \n}\ndinero## [1] -100\n# vector de importes\ndinero <- rep(0, 201)\ndinero[1] <- 100 # dinero inicial\n\n# Bucle for\nfor (i in 2:201) {\n  \n  # si dinero[i - 1] es par o  impar\n  dinero[i] <- ifelse(dinero[i - 1] %% 2 == 0, dinero[i - 1] + 3,\n                      dinero[i - 1]  - 5)\n  \n}\ndinero##   [1]  100  103   98  101   96   99   94   97   92   95   90   93   88   91   86\n##  [16]   89   84   87   82   85   80   83   78   81   76   79   74   77   72   75\n##  [31]   70   73   68   71   66   69   64   67   62   65   60   63   58   61   56\n##  [46]   59   54   57   52   55   50   53   48   51   46   49   44   47   42   45\n##  [61]   40   43   38   41   36   39   34   37   32   35   30   33   28   31   26\n##  [76]   29   24   27   22   25   20   23   18   21   16   19   14   17   12   15\n##  [91]   10   13    8   11    6    9    4    7    2    5    0    3   -2    1   -4\n## [106]   -1   -6   -3   -8   -5  -10   -7  -12   -9  -14  -11  -16  -13  -18  -15\n## [121]  -20  -17  -22  -19  -24  -21  -26  -23  -28  -25  -30  -27  -32  -29  -34\n## [136]  -31  -36  -33  -38  -35  -40  -37  -42  -39  -44  -41  -46  -43  -48  -45\n## [151]  -50  -47  -52  -49  -54  -51  -56  -53  -58  -55  -60  -57  -62  -59  -64\n## [166]  -61  -66  -63  -68  -65  -70  -67  -72  -69  -74  -71  -76  -73  -78  -75\n## [181]  -80  -77  -82  -79  -84  -81  -86  -83  -88  -85  -90  -87  -92  -89  -94\n## [196]  -91  -96  -93  -98  -95 -100\ndinero <- 100 # dinero inicial\n\n# Bucle while\nwhile (dinero > 0) {\n  \n  dinero <- ifelse(dinero %% 2 == 0, dinero + 3, dinero - 5)\n  \n}\ndinero## [1] 0"},{"path":"ejercicios-recopilados.html","id":"funciones","chapter":"📝 Ejercicios recopilados","heading":"Funciones","text":"Scripts usados:script09.R: bucles. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script09.R(haz click en las flechas para ver soluciones)Ejercicio 1: modifica el código inferior para definir una función llamada funcion_suma, de forma que dados dos elementos, devuelve su suma.Solución:&nsbp;Ejercicio 2: modifica el código inferior para definir una función llamada funcion_producto, de forma que dados dos elementos, devuelve su producto.Solución: Ejercicio 3: modifica el código inferior para definir una función llamada funcion_producto, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado (es decir, por defecto un solo argumento, y el resultado sea el número por sí mismo)Solución: Ejercicio 4: define una función llamada igualdad_nombres que, dados dos nombres persona_1 e persona_2, nos diga si son iguales o . Hazlo considerando importantes las mayúsculas, y sin que importen las mayúsculas. Recuerda que con toupper() podemos pasar todo un texto mayúscula. Solución: Ejercicio 5: define una función llamada pares que, dados dos números x e y, nos diga si la suma de ambos es par o .Recuerda que con %% podemos obtener el resto de un número al dividir entre 2.Solución: ","code":"\n# Definimos función\nnombre <- function(x, y) {\n  \n  # Sumamos\n  suma <- # código a ejecutar\n  \n  # ¿Qué devolvemos?\n  return()\n}\n\n# Aplicamos la función\nsuma(3, 7)\n# Definimos función\nfuncion_suma <- function(x, y) {\n  \n  # Sumamos\n  suma <- x + y\n  \n  # Devolvemos la salida\n  return(suma)\n}\n\n# Aplicamos la función\nfuncion_suma(3, 7)## [1] 10\n# Definimos función\nnombre <- function(x, y) {\n  \n  # Multiplicamos\n  producto <- # código de la multiplicación\n  \n  # ¿Qué devolvemos?\n  return()\n}\n\n# Aplicamos la función\nproducto(3, -7)\n# Definimos función\nfuncion_producto <- function(x, y) {\n  \n  # Multiplicamos\n  producto <- x * y\n  \n  # Devolvemos la salida\n  return(producto)\n}\n\n# Aplicamos la función\nfuncion_producto(3, -7)## [1] -21\n# Definimos función\nnombre <- function(x, y) {\n  \n  # Multiplicamos\n  producto <- # código de la multiplicación\n  \n  # ¿Qué devolvemos?\n  return()\n}\n\n# Aplicamos la función solo con un argumento\nproducto(3)\n\n# Aplicamos la función con dos argumentos\nproducto(3, -7)\n# Definimos función\nfuncion_producto <- function(x, y = x) {\n  \n  # Multiplicamos\n  producto <- x * y\n  \n  # Devolvemos la salida\n  return(producto)\n}\n\n# Aplicamos la función\nfuncion_producto(3) # por defecto x = 3, y = 3## [1] 9\nfuncion_producto(3, -7)## [1] -21\n# Distinguiendo mayúsculas\nigualdad_nombres <- function(persona_1, persona_2) {\n  \n  return(persona_1 == persona_2)\n}\nigualdad_nombres(\"Javi\", \"javi\")## [1] FALSE\nigualdad_nombres(\"Javi\", \"Lucía\")## [1] FALSE\n# Sin importar mayúsculas\nigualdad_nombres <- function(persona_1, persona_2) {\n  \n  return(toupper(persona_1) == toupper(persona_2))\n}\nigualdad_nombres(\"Javi\", \"javi\")## [1] TRUE\nigualdad_nombres(\"Javi\", \"Lucía\")## [1] FALSE\n2 %% 2 # par, resto 0## [1] 0\n3 %% 2 # impar, resto 1## [1] 1\n# Definimos función\npares <- function(x, y) {\n  \n  # Sumamos\n  suma <- x + y\n  \n  # Comprobamos si es par\n  par <- suma %% 2 == 0\n  \n  # Devolvemos la salida\n  return(par)\n}\n\n# Aplicamos la función\npares(1, 3) # suma 4 (par)## [1] TRUE\npares(2, 7) # suma 9 (impar)## [1] FALSE"},{"path":"recursos-de-aprendizaje.html","id":"recursos-de-aprendizaje","chapter":"📚 Recursos de aprendizaje","heading":"📚 Recursos de aprendizaje","text":"Recopilación de recursos de aprendizaje para seguir profundizando.","code":""},{"path":"requisitos.html","id":"requisitos","chapter":"Capítulo 1 Requisitos","heading":"Capítulo 1 Requisitos","text":"Conexión internet (para la descarga de algunos datos y paquetes).Conexión internet (para la descarga de algunos datos y paquetes).Instalar R (ver 2.1). R será nuestro lenguaje, nuestro diccionario, nuestro castellano, nuestra ortografía para poder «comunicarnos» con el ordenador. https://cran.r-project.org/Instalar R (ver 2.1). R será nuestro lenguaje, nuestro diccionario, nuestro castellano, nuestra ortografía para poder «comunicarnos» con el ordenador. https://cran.r-project.org/Instalar R Studio (ver 2.2). De la misma manera que podemos escribir el mismo texto en castellano en una tablet, en un ordenador, en un Word, en un papel o en un tuit, en programación podemos usar distintos IDE (entornos de desarrollo integrados, nuestro Office), para que el trabajo sea más cómodo. Nosotros trabajaremos con RStudio.Instalar R Studio (ver 2.2). De la misma manera que podemos escribir el mismo texto en castellano en una tablet, en un ordenador, en un Word, en un papel o en un tuit, en programación podemos usar distintos IDE (entornos de desarrollo integrados, nuestro Office), para que el trabajo sea más cómodo. Nosotros trabajaremos con RStudio.Todo lo necesario para seguir este curso es de descarga gratuita: viva el software libre.","code":""},{"path":"instalacion.html","id":"instalacion","chapter":"Capítulo 2 Instalación","heading":"Capítulo 2 Instalación","text":"En breve daremos nuestros primeros pasos pero antes necesitamos instalar algunas cosas. serán tantas. Para entender lo que instalamos pensaremos que vamos escribir un libro. ¿Qué necesitamos?Gramática/ortografía: en nuestro caso será R, el lenguaje de programación que usaremos.Word: al igual que podemos escribir en castellano de distintas maneras (en un Word, un post-, un cuaderno, etc), cuando programamos podemos trabajar en distintos entornos de desarrollo (IDE). En nuestro caso escribiremos y programaremos en RStudio, nuestro Word para escribir en lenguaje R.","code":""},{"path":"instalacion.html","id":"instalacionR","chapter":"Capítulo 2 Instalación","heading":"2.1 Instalación de R","text":"Vamos necesitar solo 3 pasos (y conexión internet).Paso 1: entra en la web oficial de R https://cran.r-project.org/. En la pantalla de inicio selecciona la instalación acorde tu sistema operativo (ver imagen 2.1)\nImagen/gráfica 2.1: Pantalla inicial de la plataforma CRAN de R.\nPaso 2: para sistemas operativos Mac basta con que hacer click en el archivo .pkg, y abrirlo una vez descargado (ver imagen 2.2)\nImagen/gráfica 2.2: Pantalla de instalación de R en Mac OS.\nPara sistemas operativos Windows, debemos clickar en install R first time (ver imagen 2.3) y en la siguiente pantalla hacer click en Download R Windows (ver imagen 2.4). Una vez descargado, abrirlo como cualquier archivo de instalación.\nImagen/gráfica 2.3: Pantalla previa de instalación de R en Windows.\n\nImagen/gráfica 2.4: Pantalla final de instalación de R en Windows.\nPaso 3: tras su instalación tendrás en tu escritorio (Windows) o en tu Launchpad (Mac Os) un ejecutable de R para abrir. En Windows puede que tengas dos ejecutables i386 y x64 (como todo programa en Windows, está la versión de 32 y de 64 bits, haz click preferiblemente - si lo tienes - en el de x64). Te saldrá algo parecido lo que observas en la imagen 2.5.\nImagen/gráfica 2.5: Primera pantalla al abrir el ejecutable de R.\n","code":""},{"path":"instalacion.html","id":"primera-operación-sumar-dos-números","chapter":"Capítulo 2 Instalación","heading":"2.1.1 Primera operación: sumar dos números","text":"Para comprobar que está correctamente instalado, abre R y prueba escribir en la pantalla blanca inferior el siguiente código (recuerda: los códigos de este manual puedes copiarlos directamente de la cajita haciendo click en el botón de la esquina superior derecha)\nImagen/gráfica 2.6: Primera suma en la consola de R.\n¡Enhorabuena!¿Dónde hemos escrito ese código? Esa pantalla blanca donde hemos escrito el código se llama CONSOLA, y será donde ejecutaremos las órdenes.¿Dónde hemos escrito ese código? Esa pantalla blanca donde hemos escrito el código se llama CONSOLA, y será donde ejecutaremos las órdenes.¿Qué hemos hecho? Hemos hecho más de lo que parece. Primero, hemos definido dos variables y b asignándole un valor numérico cada una de ellas. Imagina que el símbolo <- es visto en nuestra cabeza como una flecha: una variable que llamamos le asignamos el valor 1, una variable que llamamos b le asignamos el valor 2. Podemos verlo como \\(= 1,~b = 2\\). Y tras definir dichas variables, las hemos usado en una operación aritméticaa + b. Ya sabemos usar R como calculadora.¿Qué hemos hecho? Hemos hecho más de lo que parece. Primero, hemos definido dos variables y b asignándole un valor numérico cada una de ellas. Imagina que el símbolo <- es visto en nuestra cabeza como una flecha: una variable que llamamos le asignamos el valor 1, una variable que llamamos b le asignamos el valor 2. Podemos verlo como \\(= 1,~b = 2\\). Y tras definir dichas variables, las hemos usado en una operación aritméticaa + b. Ya sabemos usar R como calculadora.¿Cómo nos devuelve R el resultado de la operación? Si te ha devuelto el resultado correcta, en la consola debe aparecer [1] 3. El valor [1] aparecerá siempre ya que simplemente nos numera las líneas de la consola usadas; lo que viene detrás es realmente el resultado, es decir, \\(+ b = 3\\).¿Cómo nos devuelve R el resultado de la operación? Si te ha devuelto el resultado correcta, en la consola debe aparecer [1] 3. El valor [1] aparecerá siempre ya que simplemente nos numera las líneas de la consola usadas; lo que viene detrás es realmente el resultado, es decir, \\(+ b = 3\\).¿Por qué hemos escrito + b al final? Un mantra de R, que veremos lo largo de todo el curso, es que R intenta molestarte lo menos posible (eso es bueno cuando ya sabes usarlo, tan bueno cuando empezamos aprenderlo). Cuando asignamos los valores <- 1 y b <- 2, R nos muestra nada: si guardamos un resultado en una variable, nos muestra nada por consola. Para obtener el resultado en la consola necesitamos escribir el nombre de las variables (u operaciones entre ellas, como + b).¿Por qué hemos escrito + b al final? Un mantra de R, que veremos lo largo de todo el curso, es que R intenta molestarte lo menos posible (eso es bueno cuando ya sabes usarlo, tan bueno cuando empezamos aprenderlo). Cuando asignamos los valores <- 1 y b <- 2, R nos muestra nada: si guardamos un resultado en una variable, nos muestra nada por consola. Para obtener el resultado en la consola necesitamos escribir el nombre de las variables (u operaciones entre ellas, como + b). WARNING: Como habrás advertido, en R usaremos <- para asignar valores en lugar de =, como una flecha. Usaremos = para indicarle el valor los argumentos que usemos en funciones y == como operador de comparación: si escribimos 2 == 3, le estamos preguntando si 2 es igual 3. Bonita esta interfaz es, así que la cerraremos y la abriremos más. Tenemos nuestro lenguaje instalado, vamos instalar nuestro Word para poder programar de forma cómoda.","code":"\na <- 1\nb <- 2\na + b## [1] 3\n2 == 3## [1] FALSE"},{"path":"instalacion.html","id":"instalacionRStudio","chapter":"Capítulo 2 Instalación","heading":"2.2 Instalación de R Studio","text":"Para instalar RStudio deberemos ir la web https://www.rstudio.com/products/rstudio/download/#download (el gratuito) y seleccionar el ejecutable que te aparezca acorde tu sistema operativo (ver imagen 2.7). Tras descargar el ejecutable, hay que abrirlo como otro cualquier otro ejecutable y dejar que termine la instalación.\nImagen/gráfica 2.7: Descargar el ejecutable de RStudio para su posterior instalación.\nTras instalar tendremos en el escritorio o Launchpad un ejecutable de RStudio que abriremos. Se nos aparecerá una pantalla similar esta:\nImagen/gráfica 2.8: Primer recibimiento de nuestro mejor amigo RStudio.\nListo, tienes instalado (casi) todo correctamente.","code":""},{"path":"instalacion.html","id":"glosario","chapter":"Capítulo 2 Instalación","heading":"2.3 Glosario","text":"GLOSARIOConsola: es el nombre para llamar esa ventana grande que te ocupa buena parte de tu pantalla. Prueba escribir el mismo código que antes en ella (es el equivalente la consola de R que hemos abierto al principio).\nImagen/gráfica 2.9: Lanzando consola nuestras primeras órdenes en RStudio.\nLa consola será donde ejecutaremos órdenes y mostraremos resultadosEnvironment (entorno): la pantalla pequeña (puedes ajustar los márgenes con el ratón tu gusto) que tenemos en la parte superior derecha se denomina environment o entorno de variables, donde como puedes ver, tras ejecutar el pequeño código en la consola, nos informa de que tenemos dos variables numéricas y su valor asignado. Nos mostrará las variables que tenemos definidas, el tipo y su valor.\nImagen/gráfica 2.10: Environment de variables.\nPanel multiusos: la ventana que tenemos en la parte inferior derecha servirá para buscar ayuda de comandos y órdenes, además de para visualizar gráficos. Lo veremos cuando sea necesario.\nImagen/gráfica 2.11: Panel multiusos.\n","code":"\na <- 1\nb <- 2\na + b"},{"path":"instalacion.html","id":"consejos","chapter":"Capítulo 2 Instalación","heading":"2.4 Consejos","text":"CONSEJOS¿Cómo saber cuando la orden lanzada en consola ha terminado?veces R y RStudio son tan silenciosos que sabemos si ha acabado la orden que acabamos de lanzar en la consola o . Siempre que veas el símbolo > como última línea en la consola significa que está listo para que le escribamos otra orden (es la forma cariñosa de decirte que ya ha acabado, ver imagen 2.12)\nImagen/gráfica 2.12: Ejemplo de que la orden lanzada ha acabado.\n ¿Cómo prevenir la fatiga programando?Estando delante de una pantalla de ordenador, con la vista muy fija mientras se programa, puede que acabes teniendo cierta fatiga visual en el trabajo. Te aconsejo que cambies en tu RStudio la tonalidad del fondo de tu programa, en tonos oscuros y blancos (¿te fijado que mis capturas tienen un azul cobalto oscuro de fondo mientras el tuyo es un blanco nuclear? Echa un vistazo las imágenes 2.13 y 2.14)\nImagen/gráfica 2.13: Menú de opciones de nuestro editor\n\nImagen/gráfica 2.14: Personalizar el color de fondo de nuestro editor, la letra y el tamaño de fuente\n","code":""},{"path":"que-es-R.html","id":"que-es-R","chapter":"Capítulo 3 ¿Qué es R?","heading":"Capítulo 3 ¿Qué es R?","text":"Una vez que tenemos todo instalado vamos dar nuestros primeros pasos en R, pero antes veamos un poco de su historia y de una particularidad: R es un lenguaje modular (¿modu…qué?)","code":""},{"path":"que-es-R.html","id":"historia-de-r","chapter":"Capítulo 3 ¿Qué es R?","heading":"3.1 Historia de R","text":"Veamos antes un poco de la historia de nuestra deidad.Allá por 1975, los laboratorios Bell (los que inventaron la radio moderna tal y como la conocemos), necesitaban una alternativa los lenguajes más «rudos» y antiguos como C++ o Fortran, lenguajes rápidos en la ejecución pero complejos en su uso, con una gran curva de aprendizaje y con muy poca capacidad en la visualización de datos que se empezaba necesitar.Así que en 1976 sacaron la primera versión del lenguaje conocido S (hasta entonces estaba de moda lo de llamar los lenguajes con una sola inicial). En 1980 se empezó distribuir la primera versión pública de S, más allá de los laboratorios Bell, y en 1988 se añadieron bastantes funcionalidades nuevas como poder aplicar funciones otras funciones (los famosos apply() que ya veremos). Años más tarde, en 1991, dicho lenguaje se simplificó, reescribiendo muchas subrutinas de otros lenguajes más primitivos, para tener una versión muy parecida al actual R, permitiendo el usod de operadores, data.frames (que veremos) y otro tipo de objetos, sencillos en la programación pero muy versatiles.Sin embargo, salvo uso docente, S tenía licencia así que en 1992 Ross Ihaka y Robert Gentleman se lanzaron crear una versión de S libre y gratuita, un trabajo de casi 8 años hasta que en el año 2000, ambos investigadores de la Universidad de Auckland en Nueva Zelanda lanzaron la primera versión estable del lenguaje.Tras dicho lanzamiento, se creó un equipo de expertos en estadística computacional (el conocido como R Development Core Team) que es el que se encarga de mantener toda la aerquitectura de R y los que se encargar de actualizar y mejorar el paquete {base}, una librería motor sobre la que se construye el resto de funciones.Y es precisamente ese hecho una de las principales diferencias entre Python y R: R fue creado por y para estadísticos. Te dejo esta entrada en el blog por si quieres curiosear las diferencias (aunque ambos pueden ser útiles para trabajos estadísticos muy generales).","code":""},{"path":"que-es-R.html","id":"instalacionpaquetes","chapter":"Capítulo 3 ¿Qué es R?","heading":"3.2 Comunidad de usuarios: paquetes","text":"La pregunta del millón suele ser siempre la misma: ¿qué lenguaje elegir? Podríamos hacer una comparativa técnico de distintos lenguajes pero vamos quedarnos con dos consejos fundamentales: prioriza el software libre y aquellos lenguajes que tienen una comunidad muy grande de usuarios trabajando en los problemas o campo para el que vas usar dicho lenguaje.El lenguaje R (también Python) tiene 3 ventajas principales:Es un lenguaje creado por y para estadísticos/.Es un lenguaje creado por y para estadísticos/.Es software libre (como C++, Python, Fortran, y otros tantos lenguajes). El software libre solo tiene una ventaja evidente (es gratis, ok) sino que permite acceder libremente código ajeno.Es software libre (como C++, Python, Fortran, y otros tantos lenguajes). El software libre solo tiene una ventaja evidente (es gratis, ok) sino que permite acceder libremente código ajeno.Es un lenguaje modular: en la instalación que hemos realizado se han instalado todas las funcionalidades, solo el mínimo para poder funcionar, de forma que se ahorra espacio en disco y en memoria. Al ser software libre, existen trozos de código hechos por otras personas llamados paquetes, que podemos ir instalando nuestro gusto según los vayamos necesitando. Esto es una ventaja enorme ya que R tiene una comunidad de usuarios gigante para hacer estadística (Python tiene una enorme comunidad pero más enfocada al Machine Learning), con más de 17 000 paquetes: ¡hay más de 17 000 trozos de código, muchos de ellos programados por expertos/en R, validados por la comunidad y la plataforma, y de forma gratuita!Es un lenguaje modular: en la instalación que hemos realizado se han instalado todas las funcionalidades, solo el mínimo para poder funcionar, de forma que se ahorra espacio en disco y en memoria. Al ser software libre, existen trozos de código hechos por otras personas llamados paquetes, que podemos ir instalando nuestro gusto según los vayamos necesitando. Esto es una ventaja enorme ya que R tiene una comunidad de usuarios gigante para hacer estadística (Python tiene una enorme comunidad pero más enfocada al Machine Learning), con más de 17 000 paquetes: ¡hay más de 17 000 trozos de código, muchos de ellos programados por expertos/en R, validados por la comunidad y la plataforma, y de forma gratuita!\nImagen/gráfica 3.1: Paquetes disponibles en R.\nEsto nos ahorra muchísimo tiempo en nuestro día día ya que casi todo lo que querramos hacer ya lo habrá querido hacer otra persona (y seguramente mejor que nosotros/). Vamos instalar, por ejemplo, un paquete gráfico (ggplot2) que necesitaremos en el futuro. Para ello, escribe en tu consola el siguiente código y pulsa enter.Dicha orden (puede tardar un poco la primera vez, depende de tu conexión internet) lo que hará será acceder la web de R, bajarse tu ordenador los trozos de código incluidos en el paquete llamado ggplot2, y dejarlos para siempre en él. WARNING:La instalación de paquetes SOLO ES NECESARIA la primera vez que se usa dicho paquete en la vida del ordenador, hace falta hacerlo cada vez que lo usas. Una vez que tenemos los trozos de código (el paquete) en nuestro ordenador, en cada sesión de R que abramos (cada vez que cierres y abras RStudio) deberemos (si queremos) llamar ese paquete que tenemos instalado, escribiendo el siguiente comando en consolaWelcome software libre","code":"\ninstall.packages(\"ggplot2\")\nlibrary(ggplot2)"},{"path":"que-es-R.html","id":"por-qué-excel-no-es-tu-amigo","chapter":"Capítulo 3 ¿Qué es R?","heading":"3.3 ¿Por qué Excel no es tu amigo?","text":"R es un lenguaje de programación, de alto nivel para el usuario y modular. Los lenguajes de alto nivel como R, Python (curso interactivo de Python en https://checkio.org/) o Matlab, facilitan la programación al usuario, teniendo que preocuparte solo de la tarea de programar. Son lenguajes con una menor curva de aprendizaje aunque suelen ser más lentos en su ejecución en comparación con lenguajes de bajo nivel (C, C++ o Fortran), lenguajes muy rápidos en su ejecución pero cuya programación requiere un mayor tiempo y formación, teniendo que además estar pendiente del tipo de variables, espacio en memoria, etc.Por su arquitectura, R es un lenguaje que puede ser usado para un propósito general pero que está especialmente diseñado para el análisis estadístico de datos. Su modularidad nos da la ventaja de que podemos instalar las funcionalidades que vayamos necesitando de forma progresiva.¿Por qué es recomendable usar Excel como base de datos ni para realizar análisis estadísticos complejos? Software de pago: Excel, al igual que el resto de programas de Microsoft o SPSS (por desgracia programa estrella de nuestro sistema sanitario), es un programa de pago. nivel individual, todos hemos tenido una versión que hemos pagado, pero dicha evasión se la puede permitir una empresa o administración, que debe de pagar altas cantidades de dinero anuales por las licencias, dinero que sería necesario si los investigadores y trabajadores tuvieran formación (remunerada) en otras herramientas de software libre.Software de pago: Excel, al igual que el resto de programas de Microsoft o SPSS (por desgracia programa estrella de nuestro sistema sanitario), es un programa de pago. nivel individual, todos hemos tenido una versión que hemos pagado, pero dicha evasión se la puede permitir una empresa o administración, que debe de pagar altas cantidades de dinero anuales por las licencias, dinero que sería necesario si los investigadores y trabajadores tuvieran formación (remunerada) en otras herramientas de software libre.Software cerrado: solo es de pago sino que es cerrado, así que solo podemos hacer lo que Excel ha creído que interesante que podamos hacer. Incluso con la programación de MACROS, las funcionalidades de Excel siguen siendo mucho más limitadas ya que viene «programadas» de antemanoSoftware cerrado: solo es de pago sino que es cerrado, así que solo podemos hacer lo que Excel ha creído que interesante que podamos hacer. Incluso con la programación de MACROS, las funcionalidades de Excel siguen siendo mucho más limitadas ya que viene «programadas» de antemanoAlto consumo de memoria: dicha programación predeterminada hace que Excel ocupe muchísimo espacio en el disco duro y tenga un alto consumo de memoria (la memoria es lo que te permite hacer varias tareas la vez en tu ordenador).Alto consumo de memoria: dicha programación predeterminada hace que Excel ocupe muchísimo espacio en el disco duro y tenga un alto consumo de memoria (la memoria es lo que te permite hacer varias tareas la vez en tu ordenador).es universal: solo es de pago sino que además, dependiendo de la versión que tengas de Excel, tendrá un formato distinto para datos como fechas, teniendo incluso extensiones distintas, de forma que un archivo .xls abierto por un Excel moderno puede provocar errores en la carga.es universal: solo es de pago sino que además, dependiendo de la versión que tengas de Excel, tendrá un formato distinto para datos como fechas, teniendo incluso extensiones distintas, de forma que un archivo .xls abierto por un Excel moderno puede provocar errores en la carga.¡ES SOLO UNA HOJA DE CÁLCULO!: el propio Microsoft desaconseja el uso de Excel para el análisis de grandes volúmenes de datos. El Excel es una herramienta maravillosa para ser usada como una sencilla hoja de cálculo: llevar las cuentas de tu familia, de tu pequeño negocio, una declaración de la Renta sencilla, planificar viajes, etc. Pero el programa ESTÁ DISEÑADO para ser una base de datos ni para análisis detallado, y muchos menos pensado para generar un entorno flexible para el análisis estadístico y la visualización de datos.¡ES SOLO UNA HOJA DE CÁLCULO!: el propio Microsoft desaconseja el uso de Excel para el análisis de grandes volúmenes de datos. El Excel es una herramienta maravillosa para ser usada como una sencilla hoja de cálculo: llevar las cuentas de tu familia, de tu pequeño negocio, una declaración de la Renta sencilla, planificar viajes, etc. Pero el programa ESTÁ DISEÑADO para ser una base de datos ni para análisis detallado, y muchos menos pensado para generar un entorno flexible para el análisis estadístico y la visualización de datos. ¿Puedes ser el mejor partiendo un filete con una cuchara? Seguramente puedas (en Excel puedes hasta programar con macros), y si siempre lo hiciste así, acabarás normalizándolo, pero seguirás siendo una persona comiendo filete con cuchara.¿Qué sucede si usamos la herramienta equivocada? Tres ejemplos:Problemas para codificar fechas: en 2016 se publicó una revisión de artículos en genética, descubriendo que 1 de cada 5 artículos contenían errores debido una mala codificación de las fechas, conviertiendo por ejemplo los genes Septin-2 (conocido como SEPT2) en fechas, y al revés (Ziemann, Eren, El-Osta 2016).\nImagen/gráfica 3.2: Excel en una noche loca.\nProblemas de memoria: un Excel permite por defecto una cantidad máxima de filas. Aunque dicha cantidad se puede ampliar, sigue siendo finita, por lo que cuando superas el umbral de filas, al añadir filas Excel te borra registros sin avisarte de que lo está haciendo. Esto es lo que sucedió con los registros de casos covid en Reino Unido.\nImagen/gráfica 3.3: Cuando Excel dice basta.\nProblemas para codificar edades: una variable de tipo fecha, aunque nosotros la veamos con letras, en realidad es una variable numérica que representa los días que han pasado desde una fecha origen. En función de las distintas versiones de Excel, dicha fecha origen cambia. Además, si se codifica mal la fecha en formato dd-mm-YY, dicho formato cuando se exporta otro excel en texto, permite distinguir un nacido en 1918 y un nacido en 2018, así que podemos estar confundiendo personas de 103 años con niños de 3 años (y es lo que sucedió en España, observando unas tasas de mortalidad en niños muy pequeños equivalentes personas mayores).\nImagen/gráfica 3.4: Los centenarios con biberón.\n","code":""},{"path":"que-es-R.html","id":"glosario-1","chapter":"Capítulo 3 ¿Qué es R?","heading":"3.4 Glosario","text":"GLOSARIOPaquete: trozos de código realizadas por otros usuarios de la comunidad (y validades por el equipo de CRAN si la descarga es mediante install.packages()) para ser usados. Una vez instalados (descargados) los trozos de código nuestro ordenador, basta con «acudir» ellos con library().Haciendo una metáfora con la colección de libros que tengas en casa: con la instalación hemos comprado el libro y lo tenemos en nuestra estantería (para siempre), con la llamada al paquete, por ejemplo library(ggplot2), lo que hacemos es decidir, de entre todos los libros de la estantería, cuales queremos llevarnos de viaje (en cada maleta que hagamos).Los paquetes usados los verás denotados como {nombre_paquete} lo largo del manual.","code":""},{"path":"primeros-pasos.html","id":"primeros-pasos","chapter":"Capítulo 4 Primeros pasos","heading":"Capítulo 4 Primeros pasos","text":"Scripts usados:script01.R: ejercicio 5. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script01.R Vamos empezar por lo sencillo: ¿cómo usar R como una calculadora?","code":""},{"path":"primeros-pasos.html","id":"primeros-pasos-en-r-calculadora","chapter":"Capítulo 4 Primeros pasos","heading":"4.1 Primeros pasos en R: calculadora","text":"¿Te acuerdas de lo que era la consola? En el caso de RStudio, la consola será esa pequeña pantalla que tenemos en la parte inferior (la pestaña Console). Vamos trabajar de momento solo en esa ventana inferior.\nImagen/gráfica 4.1: Lanzando consola nuestras primeras órdenes en RStudio.\nLo que ya hemos descubierto en los pasos de la instalación (ver imagen 4.1) es que la consola de R tiene una función muy básica y evidente: nos sirve de calculadora. Un ejemplo muy simple: si escribimos 3 en la consola y pulsamos ENTER, la consola nos mostrará el resultado de la suma ¿Cuál es la diferencia entre una calculadora y un lenguaje de programación? Imagina que dicha suma 3 la quisiéramos utilizar para un segundo cálculo: ¿y si en lugar de lanzarlo la consola sin más lo almacenamos en alguna variable?Como hemos visto en la instalación de RStudio, para asignar variables lo haremos con <-, por ejemplo la orden x <- 1 + 2: una variable de nombre x va tener asignada lo que valga la suma 1 + 2Como puedes comprobar, en tu parte superior derecha (nuestro entorno de variables), podrás ver como una nueva variable x es ahora visualizada, con su valor asignado (se mostrará en consola salvo que escribas 3 en ella: R asume que querías visualizarla en consola sino solo guardarla).\nImagen/gráfica 4.2: Environment.\nDicha variable x además podemos reciclarla para definir, por ejemplo, una variable y, restándole una constante. De la misma manera que hemos hecho restas, sumas y multiplicaciones, R tiene todas las operaciones clásicas que podrías tener en una calculadora. Prueba ejecutar en la consola las órdenes x^2, sqrt(x) o abs(y): R calculará las operaciones elevar al cuadrado, raíz cuadrada y valor absoluto (respectivaemnte) de la variable que tengan entre paréntesis ","code":"\n1 + 2## [1] 3\nx <- 1 + 2\ny <- x - 3\nx## [1] 3\ny## [1] 0\nx * y## [1] 0\nx^2## [1] 9\nsqrt(x)## [1] 1.732051\ny <- x - 5\nabs(y)## [1] 2"},{"path":"primeros-pasos.html","id":"y-dónde-programamos","chapter":"Capítulo 4 Primeros pasos","heading":"4.2 ¿Y dónde programamos?","text":"¿Estás emocionado/? Vamos abrir nuestro primer script. Un script será el documento en el que programamos, nuestro .doc, pero aquí será un archivo con extensión .R, donde escribiremos las órdenes, que nos evitará estar lanzando todo consola. ¿Por qué abusar de la consola? Una máxima para olvidar: TODO lo que escribas en un script, cuando cierres RStudio, lo habrás perdido (cómo si en lugar de escribir en un Word y guardarlo, nunca guardases el documento).Para abrir nuestro primero script, haz click en el menú superior en File << New File << R Script como se muestra en la imagen 4.3\nImagen/gráfica 4.3: Abriendo nuestro primer script de R.\nTras abrirlo tendremos una cuarta ventana: esta será la ventana de nuestros códigos, la ventana más importante ya que es donde escribiremos lo que queremos ejecutar. Escribe el código de la suma de arriba en ese script y guarda el archivo haciendo click en el botón Save current document\nImagen/gráfica 4.4: Escribiendo y guardando nuestro primer script.\nEse código se ejecuta salvo que se lo digamos. Tenemos tres opciones para ejecutar código:Copiar y pegar el trozo de código en la consola (como hemos hecho al principio).Copiar y pegar el trozo de código en la consola (como hemos hecho al principio).Seleccionar líneas de código y clickar en Run (o con su atajo de teclado), lo que hará que se ejecute solo las líneas seleccionadas.Seleccionar líneas de código y clickar en Run (o con su atajo de teclado), lo que hará que se ejecute solo las líneas seleccionadas.Activar el cuadrado Source save la derecha del botón de guardar y volvemos hacer click en el botón de guardar: siempre que esa opción esté activada, al guardar solo es nos guarda el archivo .R sino que además se ejecuta el código completo que tengas en el script.Activar el cuadrado Source save la derecha del botón de guardar y volvemos hacer click en el botón de guardar: siempre que esa opción esté activada, al guardar solo es nos guarda el archivo .R sino que además se ejecuta el código completo que tengas en el script.","code":"\na <- 1\nb <-2\na + b## [1] 3"},{"path":"primeros-pasos.html","id":"tipos_errores","chapter":"Capítulo 4 Primeros pasos","heading":"4.3 Tipos de errores","text":"Durante tu aprendizaje en R va ser muy habitual que las cosas salgan la primera, apareciendo en consola mensajes en un color rojo. Un miedo muy habitual cuando se empieza programar es pensar que si haces algo mal o aparece algún mensaje de error, el ordenador puede explotar en cualquier momento. programar se aprende programando, así que haz las pruebas que quieras, lo peor que puede pasar es que necesites cerrar sesión en R Studio y abrirlo de nuevo, o en el peor de los casos, desintalarlo y volverlo iinstalar.Dado que el \\(99.9\\%\\) de las veces tu código tendrá errores que deberás ir solventando, está de más conocer los tipos de mensajes que R puede sacarte por consola.Los mensajes de ERROR irán precedidos de la frase «Error …», dándote veces incluso el tipo de error y la línea de código en la que se ha producido. Veamos un ejemplo intentando sumar un número una cadena de texto.Los errores son aquellos fallos que seguramente impidan la ejecución del código. Un error muy habitual es intentar acceder alguna función de algún paquete que, o bien tenemos instalado, o bien hemos llamado haciendo uso del library(): estás intentando leerte un libro de tu biblioteca pero ni siquiera ido la tienda «comprarlo». Los mensajes de WARNING irán precedidos de la frase «Warning …», y son los fallos más delicados ya que son posibles errores o incoherencias que R detecta en tu código pero que van hacer que tu código deje de ejecutarse, aunque probablemente lo haga como ti te gustaría. Un ejemplo es cuando tratamos de hacer la raiz cuadrada de un número negativo.¿Ha ejecutado la orden? Sí, pero te advierte de que el resultado de la operación es un NaN, un valor que existe (al menos dentro de los números reales), un Number (ver Sección 6.5). Los mensajes de CONTROL serán aquellos que aparecerán por consola sin empezar por «Error …» ni «Warning:…». Dichos mensajes, que puedes incluir tú mismo en tu código con funciones como cat() para monitorizar la ejecución de códigos largos, son errores ni problemas, son simplemente información que R considera útil aportarte. ","code":"\n\"a\" + 1## Error in \"a\" + 1: argumento no-numérico para operador binario\nsqrt(-1)## Warning in sqrt(-1): Se han producido NaNs## [1] NaN"},{"path":"primeros-pasos.html","id":"glosario-2","chapter":"Capítulo 4 Primeros pasos","heading":"4.4 Glosario","text":"GLOSARIOPaquete: trozos de código realizadas por otros usuarios de la comunidad (y validades por el equipo de CRAN si la descarga es mediante install.packages()) para ser usados. Una vez instalados (descargados) los trozos de código nuestro ordenador, basta con «acudir» ellos con library().Haciendo una metáfora con la colección de libros que tengas en casa: con la instalación hemos comprado el libro y lo tenemos en nuestra estantería (para siempre), con la llamada al paquete, por ejemplo library(ggplot2), lo que hacemos es decidir, de entre todos los libros de la estantería, cuales queremos llevarnos de viaje (en cada maleta que hagamos).Los paquetes usados los verás denotados como {nombre_paquete} lo largo del manual.","code":""},{"path":"primeros-pasos.html","id":"consejos-1","chapter":"Capítulo 4 Primeros pasos","heading":"4.5 Consejos","text":"CONSEJOS Panel de ayudaSi escribes en la consola ? nombre_funcion (por ejemplo, escribe en la consola ? sqrt), en el panel inferior derecho te aparecerá una documentación de ayuda de la función para saber que argumentos necesita, como puedes usar la función, qué es lo que te devuelve, ejemplos de uso, etc.\nImagen/gráfica 4.5: Panel de ayuda.\n ¿Cómo comentar el código?Probablemente lo más importante al programar es que te acostumbres comentar lo máximo posible tu código. ¿Qué es un comentario? Es un texto que escribes entre el código precedido de #: todo lo que venga detrás será interpretado por R como código. Es vital cuando programamos que nos acostumbremos comentar lo que hacemos, tanto para nosotros como para otras personas que puedan leer nuestro código. Índice en el códigoPuedes escribir comentarios en el código para que automáticamente se organice tu código en epígrafes, mostrándote un índice en el panel lateral (haz click en el icono de la esquina superior derecha del editor) y permitiendo minimizar partes del código. Para ello puedes comentar por ejemplo con # ----- título -----.\nImagen/gráfica 4.6: Comentando el código para generar un índice.\n ","code":"\n? sqrt"},{"path":"primeros-pasos.html","id":"ejercicios","chapter":"Capítulo 4 Primeros pasos","heading":"4.6 📝 Ejercicios","text":"(haz click en las flechas para ver soluciones)📝Ejercicio 1: en tu consola (parte inferior de tu pantalla), asigna los valores 2 y 5 dos variables y b. Tras asignarles valores, multiplica los números en consola (haz click en la flecha para la solución propuesta). Solución:\nImagen/gráfica 4.7: Multiplicación de y b.\n 📝Ejercicio 2: modifica el código inferior para definir dos variables c y d, con valores 3 y -1, y calcular la división c/d (haz click en la flecha para la solución propuesta).Solución: 📝Ejercicio 3: repite el ejercicio 1 pero ahora guarda el resultado de la multiplicación final en una variable c. Para ver el resultado guardado en c escribe dicha variable en consola (haz click en la flecha para la solución propuesta). Solución:\nImagen/gráfica 4.8: Multiplicación de y b guardando el resultado.\n 📝Ejercicio 4: asigna ahora los valores 1, -2, 3 tres variables , b y c, y calcula la raíz cuadrada de cada uno. Solución: 📝Ejercicio 5: repite el ejercicio 3 pero ahora escribe el código en un script (fichero de .R, guardado en script01.R). Recuerda al acabar seleccionar las líneas ejecutar y clickar Run, o bien guardar el script con Source save activado (haz click en la flecha para la solución propuesta). Solución:\nImagen/gráfica 4.9: Multiplicación de y b guardando el resultado pero escribiendo en el script.\n 📝Ejercicio 6: calcula en consola la suma de 3 más 4, y todo ello multiplicado por 10, y asígnalo una variable x (haz click en la flecha para la solución propuesta).Solución: 📝Ejercicio 7: asigna un valor positivo x y calcula su raíz cuadrada; asigna otro negativo y calcula su valor absoluto (haz click en la flecha para la solución propuesta).Solución: CONSEJO:Las órdenes sqrt(x) y abs(y) se llaman funciones, y la variable que tienen entre paréntesis se llama argumento de la función: una variable que toma de entrada la función y con la que opera internamente. 📝Ejercicio 8: usando la variable x ya definida, calcula la resta x - 5 y guárdala en una nueva variable z (haz click en la flecha para la solución propuesta).Solución: 📝Ejercicio 9: usando las variables x y z ya definidas, calcula el máximo de ambas, y guárdalo en una nueva variable t. (haz click en la flecha para la solución propuesta).Solución: WARNING:hace falta gastar una línea por cada orden que quieras ejecutar. Tampoco necesitas guardar cada paso intermedio que realices. Cuidado con la memoria: cada asignación que hagas es una variable guardada que consume recursos en tu ordenador.","code":"\n# Para poner comentarios en el código se usa #\n\n# Definición de variables\na <- 2\nb <- 5\n\n# Multiplicación\na * b## [1] 10\n# Definición de variables\nc <- \nd <-\n\n# Operación (división)\nc ? d\n# Definición de variables\nc <- 3\nd <- -1\n\n# División\na / b## [1] 0.4\n# Variables\na <- 2\nb <- 5\n\n# Resultado\nc <- a * b\n\n# Muestro en consola\nc## [1] 10\n# Variables\na <- 1\nb <- -2\nc <- 3\n\n# Resultado\nsqrt(a)## [1] 1\nsqrt(b)## [1] NaN\nsqrt(c)## [1] 1.732051\nx <- (3 + 4) * 10\n# Raíz cuadrada\nx <- 73\nsqrt(x)## [1] 8.544004\n# Valor absoluto\ny <- -73\nabs(y)## [1] 73\nz <- x - 5\nz## [1] 68\nt <- max(x, z)\nt## [1] 73"},{"path":"tipos-datos.html","id":"tipos-datos","chapter":"Capítulo 5 Tipos de datos","heading":"Capítulo 5 Tipos de datos","text":"Scripts usados:script02.R: tipos de datos y funciones usadas con ellos. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script02.R Tras los ejercicios planteados en la lección anterior y lo que hayas jugueteado por tu cuenta, deberíamos saber más o menos usar R como una calculadora, definiendo variables que nos guardan números, como <- 1. Vamos ir más allá: ¿existen variables más allá de los números? En este capítulo vamos empezar familiarizarnos con los tipos de datos que podemos necesitar. Piensa por ejemplo en los datos guardados de una persona:La edad será un número (sin decimales)Su peso o estatura será otro número (ahora con decimales).Su nombre será una cadena de texto.Su fecha de nacimiento será precisamente eso, una fecha.la pregunta «¿está usted soltero/?» la respuesta será lo que llamamos una variable binaria o lógica: una variable que solo puede valer TRUE (si está soltero/) y FALSE (en otro caso).Existen más tipos (por ejemplo, números complejos) pero con estos nos valdrá de momento.","code":""},{"path":"tipos-datos.html","id":"numericas","chapter":"Capítulo 5 Tipos de datos","heading":"5.1 Variables numéricas","text":"[X] Variables numéricas (individuales)[ ] Variables de caracteres[ ] Variables lógicas[ ] Variables de tipo fechaProbablemente el dato más sencillo y obvio de entender sean los datos numéricos, datos que ya hemos usado en nuestros primeros pasos como calculadora.En el código anterior, tanto como b, como la suma + b, son de tipo numérico, algo que podemos comprobar con la función class() (nos devuelve numeric).También podemos comprobar su naturaleza con typeof(), que nos devuelve la naturaleza del dato tal cual es guardada en R.Aunque es especialmente relevante profundizar en ello de momento, fíjate que ambas órdenes combinadas nos dicen que las variables son de tipo numérico pero concretamente de tipo double: dichas variables son entendidas internamente como números con decimales (aunque los veamos), lo que en matemáticas se llaman números reales (por curiosidad: el término double viene de lenguajes de programación antiguos como C, que significa «doble precisión», para indicarle que reserve 8 bytes - 64 bits - de memoria). Durante el curso distinguiremos entre distintos tipos de números, para nosotros serán siempre de clase numeric y de tipo double, pero podríamos definir números enteros o integer (sin decimales, ahorrando huecos en memoria).Con los datos numéricos podemos realizar todas las operaciones que se nos ocurriría hacer en una calculadora, como sumar (+), restar (-), multiplicar (*), dividir (/), raíz cuadrada (sqrt()), valor absoluto (abs()), elevar al cuadrado (^2), elevar al cubo (^3), etc.","code":"\na <- 1\nb <- 2\na + b## [1] 3\n# Clase de las variables\nclass(a)## [1] \"numeric\"\nclass(b)## [1] \"numeric\"\nclass(a + b)## [1] \"numeric\"\n# Topología interna\ntypeof(a)## [1] \"double\"\ntypeof(b)## [1] \"double\"\ntypeof(a + b)## [1] \"double\"\n# Dato numérico (entero)\na <- 1L\nclass(a)## [1] \"integer\"\ntypeof(a)## [1] \"integer\"\n# Definimos dos variables numéricas\na <- 1\nb <- -2\n\n# Suma y resta\na + b## [1] -1\na - b## [1] 3\n# Multiplicación y división\na * b## [1] -2\na / b## [1] -0.5\n# Raíz cuadrada\nsqrt(a)## [1] 1\n# Potencias\na^2## [1] 1\nb^3## [1] -8"},{"path":"tipos-datos.html","id":"caracter","chapter":"Capítulo 5 Tipos de datos","heading":"5.2 Variables de tipo caracter (texto)","text":"[X] Variables numéricas (individuales)[X] Variables de caracteres[ ] Variables lógicas[ ] Variables de tipo fechaPero solo de números viven los datos: imagina que además de la edad de una persona queremos guardar su nombre.Fíjate que ahora tenemos en nombre una variable de tipo character, es decir, una cadena de texto (conocido en otros lenguajes como string o char): letras y caracteres entre comillas.","code":"\nedad <- 32\nnombre <- \"Javier\"\n\nclass(edad)## [1] \"numeric\"\ntypeof(edad)## [1] \"double\"\nclass(nombre)## [1] \"character\"\ntypeof(nombre)## [1] \"character\""},{"path":"tipos-datos.html","id":"nuestra-primera-función-paste","chapter":"Capítulo 5 Tipos de datos","heading":"5.2.1 Nuestra primera función: paste","text":"Las cadenas de texto son un tipo especial de dato, con los que obviamente podremos hacer operaciones aritméticas, pero si podemos hacer operaciones propias de cadenas de texto como puede ser la función paste(). Dicha función nos permite pegar dos cadenas de caracteres, decidiendo que caracter queremos que vaya entre palabra con el argumento sep =.Si queremos pegar cadenas de texto sin ningún tipo de caracter, existe una forma más abreviada y limpia de ejecutar la orden, usando la función paste0()Cuando hemos ejecutado paste() estamos ejecutando lo que se conoce como una función: una palabra reservada que representa un conjunto de órdenes, y que se ejecuta partir de unos argumentos de entrada. En el caso de la función paste(), los argumentos serán las cadenas de texto que queremos copiar, y un argumento opcional llamado sep, que podemos darle un valor en concreto o dejarlo sin especificar. Lo que hará R será tomar su valor por defecto igual sep = \" \" (por defecto, la función paste() pega cadenas de texto con un espacio entre ellas). Prueba ejecutar ? paste en consola para ver las opciones en el panel de ayuda.","code":"\nnombre <- \"Javier\"\napellido <- \"Álvarez\"\npaste(nombre, apellido, sep = \"\") # todo junto## [1] \"JavierÁlvarez\"\npaste(nombre, apellido, sep = \" \") # separados por un espacio## [1] \"Javier Álvarez\"\npaste(nombre, apellido, sep = \".\") # separados por un punto .## [1] \"Javier.Álvarez\"\n# Son equivalentes\npaste(nombre, apellido, sep = \"\") # todo junto## [1] \"JavierÁlvarez\"\npaste0(nombre, apellido) # todo junto sin nada separando## [1] \"JavierÁlvarez\"\n# Son equivalentes\npaste(nombre, apellido, sep = \" \")## [1] \"Javier Álvarez\"\npaste(nombre, apellido)## [1] \"Javier Álvarez\""},{"path":"tipos-datos.html","id":"nuestro-primer-paquete-glue","chapter":"Capítulo 5 Tipos de datos","heading":"5.2.2 Nuestro primer paquete: glue","text":"Otra forma más intuitiva de trabajar con textos y variables numéricas es usar el paquete glue, que nos permite pegar cadenas de texto variables numéricas de forma simbólica.Recuerda que install.packages() es solo necesario la primera que «compramos el libro»: nos bajamos una serie de archivos nuestro ordenador. Una vez que hemos comprado el libro, cada vez que queramos usarlo bastará con indicarle que nos traiga ese libro concreto con library().El paquete glue nos permite pegar de una forma mucho más legible cadenas de textoTambién podemos hacer uso de dicha función sin tener los valores numéricos previamente guardados en variables. ","code":"\ninstall.packages(\"glue\") # solo la primera vez\nlibrary(glue)\n# Ejemplo 1\nedad <- 32\nglue(\"La edad es de {edad} años\")## La edad es de 32 años\npaste(\"La edad es de\", edad, \"años\") # equivalente## [1] \"La edad es de 32 años\"\n# Ejemplo 2\nedad <- 32\nunidades <- \"años\"\nglue(\"La edad es de {edad} {unidades}\")## La edad es de 32 años\n# Otra forma sin definir variables a priori\nglue(\"La edad es de {32} años\")## La edad es de 32 años"},{"path":"tipos-datos.html","id":"logicas","chapter":"Capítulo 5 Tipos de datos","heading":"5.3 Variables lógicas (TRUE/FALSE)","text":"[X] Variables numéricas (individuales)[X] Variables de caracteres[X] Variables lógicas[ ] Variables de tipo fechaProbablemente el tipo de datos más importante en todo lenguaje de programación son las variables lógicas. Un valor lógico puede tomar dos valores (en realidad pueden tomar un tercer valor, NA, las siglas de available para representar datos ausentes, pero lo veremos más adelante):TRUE (guardado internamente como un 1).FALSE (guardado internamente como un 0).Este tipo de variables, también conocidas como variables binarias (solo dos valores) o booleanas, son la base de la programación ya que cada bit de nuestro ordenador puede guardar un 1 o un 0.Ahora nuestas variables son guardadas como logical, y pueden tomar los valores TRUE/FALSE, aunque internamente son guardados como 1/0. Es importante entender que son variables de texto:\"TRUE\" es un texto (internamente idéntico rojo o azul)TRUE es una variable lógicaEstos valores suelen ser resultado de evaluar condiciones lógicas. Por ejemplo, imaginemos que queremos comprobar si una persona está soltero o , y si tiene carnet de conducir o . Basta con que ejecutemos la orden soltero == TRUE, que nos devolverá TRUE si está soltero, y FALSE en caso contrario. De igual manera podremos hacer carnet_conducir == TRUE. IMPORTANTE: cuando queremos comparar si un elemento es igual otro, usaremos el operador de comparación ==, pudiendo usar también su opuesto != («distinto de»).Por el mismo razonamiento podemos comparar si una variable numérica o de tipo caracter es igual o distinto un valor dado, incluso para las numéricas podemos comparar si son menores o mayores que un número.¿Tiene la persona menos de 32 años? ¿Tiene justo 32 años? ¿Tiene 32 años o más?¿La persona se llama Carlos?Fíjate que para comparaciones tenemos «igual » == frente distinto !=, pero también comparaciones de orden como <=, > o >=. Las condiciones lógicas pueden ser combinadas, principalmente de dos maneras:Intersección: todas las condiciones concatenadas se deben cumplir (conjunción y, operador &) para devolver un TRUE.Intersección: todas las condiciones concatenadas se deben cumplir (conjunción y, operador &) para devolver un TRUE.Unión: basta con que una de las condiciones concatenadas se cumpla (conjunción o, operador |) para devolver un TRUE.Unión: basta con que una de las condiciones concatenadas se cumpla (conjunción o, operador |) para devolver un TRUE.Por ejemplo, podríamos preguntarnos si la persona tiene más de 32 años y está soltero (AMBAS deben cumplirse).Vemos que el resultado es FALSE ya que solo se cumple una de las condiciones: devolvería TRUE si preguntamos si tiene más de 30 años y está soltero, o si solo pedimos una de las dos condiciones (¿está soltero y/o tiene más de 32 años?).","code":"\nsoltero <- TRUE # ¿Es soltero? --> SÍ\ncarnet_conducir <- FALSE # ¿Tiene carnet de conducir? --> NO\n\nclass(soltero)## [1] \"logical\"\ntypeof(soltero)## [1] \"logical\"\nclass(carnet_conducir)## [1] \"logical\"\ntypeof(carnet_conducir)## [1] \"logical\"\n# Texto\ntexto <- \"TRUE\"\ntexto + 1## Error in texto + 1: argumento no-numérico para operador binario\n# Lógica\nlogica <- TRUE\nlogica + 1## [1] 2\nsoltero == TRUE## [1] TRUE\nsoltero != TRUE # igual que soltero == FALSE## [1] FALSE\ncarnet_conducir == TRUE## [1] FALSE\ncarnet_conducir != TRUE## [1] TRUE\nedad < 32## [1] FALSE\nedad == 32## [1] TRUE\nedad >= 32## [1] TRUE\nnombre == \"Carlos\"## [1] FALSE\nedad > 32 & soltero == TRUE## [1] FALSE\n# Equivalente (al ser soltero un valor ya de por si lógico)\nedad > 32 & soltero## [1] FALSE\nedad > 32 | soltero # nos sirve con que alguna se cumpla## [1] TRUE\nedad > 32 & soltero # deben cumplirse ambas## [1] FALSE\nedad > 30 & soltero # deben cumplirse ambas## [1] TRUE"},{"path":"tipos-datos.html","id":"fechas","chapter":"Capítulo 5 Tipos de datos","heading":"5.4 Variables de tipo fecha","text":"[X] Variables numéricas (individuales)[X] Variables de caracteres[X] Variables lógicas[X] Variables de tipo fechaPor último, vamos ver un tipo de datos muy especial: los datos de tipo fecha. Una fecha podría ser priori una simple cadena de texto \"2021-04-21\" pero podemos usar la función .Date() para que R entienda que esa cadena de texto representa un instante temporal. Fíjate la diferencia entre una fecha en texto y una fecha con .Date().En el momento en que convertimos la cadena de texto fecha, aunque se visualice como un texto, internamente es un número, por lo que podemos restar fechas (días entre ambas), podemos sumar números fechas (fecha días después), etc. Como ya hemos dicho, las fechas y momentos temporales serán meras cadenas de caracter sino que tienen clases especiales asociadas. Las fechas serán guardadas internamente como el número de días transcurridos desde el 1 de enero de 1970, y las horas como número de segundos desde el 1 de enero de 1970 (para la clase POSIXct) o una lista de segundos, minutos y horas (para la clase POSIXlt).¿Cómo obtener automáticamente la fecha de hoy? La función Sys.Date() nos devuelve directamente la fecha y hora en el momento de la ejecución de la orden.Para convertir una cadena de texto fecha, basta usar la función .Date(), pasándole como argumento la fecha en formato \"yyyy-mm-dd\" por defecto.Si introducimos otro tipo de formato, debemos especificárselo en un segundo argumento, para R sepa el formato de fecha que le estamos pasando ERROR: sin pasar fecha se puede operarSi tenemos una fecha como caracter, nunca podremos hacer operaciones (por ejemplo, restarle una unidad temporal, en este caso un día).Fíjate la diferencia cuando lo convertimos en fecha Dentro del entorno del paquete lubridate tenemos bastantes funciones útiles para trabajar con fechas como las siguientesAdemás el paquete nos proporciona herramientas para extraer la fecha y hora actuales con las funciones today() y now()También tenemos disponibles en dicho paquete funciones para extraer facilmente algunas variables temporales como el día de la semana, el mes o el cuatrimestre, con las funciones year(), months(), day() o wday() (día de la semana).Al igual que podemos realizar operaciones aritméticas sencillas con las fechas, también podemos realizar comparaciones, por ejemplo, si el día actual es menor o mayor que otra fecha dada. ","code":"\n# Cadena de texto\nfecha_char <- \"2021-04-21\"\nfecha_char + 1## Error in fecha_char + 1: argumento no-numérico para operador binario\n# Fecha, mostrada como un texto pero guardada internamente como un número\nfecha_date <- as.Date(fecha_char, format = \"%Y-%m-%d\")\nfecha_date + 1## [1] \"2021-04-22\"\nfecha <- Sys.Date()\nfecha## [1] \"2022-01-05\"\nfecha - 7 # una semana antes## [1] \"2021-12-29\"\nclass(fecha) # de clase fecha## [1] \"Date\"\nas.Date(\"2021-03-10\") # formato por defecto## [1] \"2021-03-10\"\nas.Date(\"10-03-2020\", \"%d-%m-%Y\") # con día-mes-año (4 cifras)## [1] \"2020-03-10\"\nas.Date(\"10-03-20\", \"%d-%m-%y\")  # con día-mes-año (2 cifras)## [1] \"2020-03-10\"\nas.Date(\"03-10-2020\", \"%m-%d-%Y\") # con mes-día-año (4 cifras)## [1] \"2020-03-10\"\nas.Date(\"Octubre 21, 1995 21:24\", \"%B %d, %Y %H:%M\") # fecha escrita## [1] NA\n\"2021-03-10\" - 1 # error## Error in \"2021-03-10\" - 1: argumento no-numérico para operador binario\nfecha <- as.Date(\"2021-03-10\") - 1 # día previo\nfecha## [1] \"2021-03-09\"\ninstall.packages(\"lubridate\") # solo la primera vez\nlibrary(lubridate)\nymd_hms(\"2017-11-28T14:02:00\") # convertir a fecha una cadena año-mes-día + hora## [1] \"2017-11-28 14:02:00 UTC\"\nydm_hms(\"2017-22-12 10:00:00\") # convertir a fecha una cadena año-día-mes + hora## [1] \"2017-12-22 10:00:00 UTC\"\ndmy_hms(\"1 Jan 2017 23:59:59\") # convertir a fecha una cadena textual de fecha + hora## [1] \"2017-01-01 23:59:59 UTC\"\nmdy(\"July 4th, 2000\") # convertir a fecha una cadena textual de fecha## [1] \"2000-07-04\"\nymd(20170131)## [1] \"2017-01-31\"\ntoday()## [1] \"2022-01-05\"\nnow()## [1] \"2022-01-05 14:02:59 CET\"\nfecha <- now()\nyear(fecha)## [1] 2022\nmonth(fecha)## [1] 1\nday(fecha)## [1] 5\nwday(fecha, week_start = 1) # Día de la semana (empezando por el lunes)## [1] 3\nhour(fecha)## [1] 14\nminute(fecha)## [1] 2\nsecond(fecha)## [1] 59.06378\nweek(fecha) # Número de semana (del año)## [1] 1\nfecha_actual <- now()\nfecha_actual > ymd(20170131) # Actual vs 2017-01-31## [1] TRUE\nfecha_actual > ymd(21000131) # Actual vs 2100-01-31## [1] FALSE"},{"path":"tipos-datos.html","id":"consejos-2","chapter":"Capítulo 5 Tipos de datos","heading":"5.5 Consejos","text":"CONSEJOS Recuperar un comando y autocompletarSi haces click con el ratón en la consola y pulsas la flecha «arriba» del teclado, te irá apareciendo todo el historial de órdenes ejecutadas. Es una manera de ahorrar tiempo para ejecutar órdenes similares las ya ejecutadas. Si empiezas escribir el nombre de una variable pero te acuerdas exactamente de su nombre, pulsando tabulador te autocompletará solo. Convertir tipos de datosA veces la lectura de variables numéricas de nuestros archivos puede hacer que un número, por ejemplo 1, sea leído como la cadena de texto \"1\", con la que podemos operar como un número. Las funciones .numeric(), .character() y .logical() nos permiten convertir una variable en tipo numérico, caracter o lógico, respectivamente. ","code":"\n\"1\" + 1## Error in \"1\" + 1: argumento no-numérico para operador binario\nas.numeric(\"1\") + 1## [1] 2\nas.character(1)## [1] \"1\"\nas.logical(c(0, 1))## [1] FALSE  TRUE"},{"path":"tipos-datos.html","id":"ejercicios-1","chapter":"Capítulo 5 Tipos de datos","heading":"5.6 📝 Ejercicios","text":"(haz click en las flechas para ver soluciones)📝Ejercicio 1: define una variable que guarde tu edad, otra con tu nombre, otra respondiendo la pregunta «¿tengo hermanos?» y otra con la fecha de tu nacimiento. Solución: 📝Ejercicio 2: define otra variable con tus apellidos y junta las variables nombre y apellidos en una sola variable nombre_completo. Solución: 📝Ejercicio 3: construye una frase que diga «Hola, llamo … y tengo … años. Nací el … de … de …» (con el nombre completo). Solución: 📝Ejercicio 4: calcula los días que han pasado desde la fecha de tu nacimiento Solución: 📝Ejercicio 5: obtén una variable lógica que nos diga si se cumplen (todas) las condiciones ) menor de 30 años (edad < 30); ii) con hermanos (hermanos == TRUE); iii) nacido en 1990 o posterior (fecha_nacimiento >= .Date(\"1990-01-01\")). Solución: 📝Ejercicio 6: modifica el código del ejercicio anterior para obtener una variable lógica que nos diga si se cumplen (al menos) alguna de las condiciones ) menor de 30 años; ii) con hermanos; iii) nacido en 1990 o posterior. Al contrario que antes, necesitamos que se cumplan todas, nos basta con que se cumple al menos una. Solución: 📝Ejercicio 7: calcula la fecha 11 días más tarde tu fecha de nacimiento. Obtén la semana del año de dicha fecha y el día de la semana con las funciones week, wday y weekdays. Solución: 📝Ejercicio 8: define dos números cualesquiera en variable y b. Calcula su suma y determina cual es mayor. Solución: ","code":"\nedad <- 32 # tipo numeric\nnombre <- \"Javier\" # tipo caracter\nhermanos <- TRUE # tipo hermanos\nfecha_nacimiento <- as.Date(\"1989-09-10\") # tipo fecha\n# Apellidos\napellidos <- \"Álvarez Liébana\"\n\n# Pegamos\nnombre_completo <- glue(\"{nombre} {apellidos}\")\nnombre_completo## Javier Álvarez Liébana\n# Otra forma\nnombre_completo <- paste(nombre, apellidos)\nnombre_completo## [1] \"Javier Álvarez Liébana\"\ndia_nacimiento <- day(fecha_nacimiento)\nmes_nacimiento <- month(fecha_nacimiento)\na_nacimiento <- year(fecha_nacimiento)\n\nglue(\"Hola, me llamo {nombre_completo} y tengo {edad} años. Nací el {dia_nacimiento} del {mes_nacimiento} de {a_nacimiento}\")## Hola, me llamo Javier Álvarez Liébana y tengo 32 años. Nací el 10 del 9 de 1989\ndays(today() - fecha_nacimiento)## [1] \"11805d 0H 0M 0S\"\n# Se tienen que cumplir todas\nedad < 30 & fecha_nacimiento >= as.Date(\"1990-01-01\") & hermanos## [1] FALSE\n# otra forma\nedad < 30 & fecha_nacimiento >= as.Date(\"1990-01-01\") & hermanos == TRUE## [1] FALSE\n# Se tienen que cumplir todas\nedad < 30 | fecha_nacimiento >= as.Date(\"1990-01-01\") | hermanos## [1] TRUE\n# Podemos sumar porque es fecha\nfecha_post <- fecha_nacimiento + 11\nfecha_post## [1] \"1989-09-21\"\n# Semana del año\nweek(fecha_post)## [1] 38\n# Día de la semana (versión americana, empiezan el domingo)\nwday(fecha_post)## [1] 5\n# Día de la semana (versión española)\nwday(fecha_post, week_start = 1)## [1] 4\n# Día de la semana en texto\nweekdays(fecha_post)## [1] \"Thursday\"\na <- -5\nb <- 7\n\n# Suma\nc <- a + b\nc## [1] 2\n# Comparaciones\na == b # ¿a = b?## [1] FALSE\na < b # ¿a < b?## [1] TRUE"},{"path":"vectores.html","id":"vectores","chapter":"Capítulo 6 Vectores","heading":"Capítulo 6 Vectores","text":"Scripts usados:script03.R: vectores. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script03.RHemos visto como poder almacenar elementos individuales: la edad de una persona, su estado civil con una variable lógica, su nombre, su fecha de nacimiento… ¿Y si en lugar de querer almacenar un solo elemento, por ejemplo edad <- 32, tenemos una colección de elementos (las edades de toda nuestra familia, por ejemplo)?En este capítulo vamos ver un clásico de cualquier lenguaje de programación: los vectores o arrays, que son más que una concatenación de elementos del mismo tipo. De hecho un número individual (por ejemplo, x <- 1) es en realidad un vector de longitud uno (un solo elemento).Un vector es lo que solemos representar como \\(\\overrightarrow{x} = \\left[1, 2, 3 \\right]\\) en matemáticas, pero te preocupes si nunca visto esta forma de representarlos. Vamos empezar de cero.","code":""},{"path":"vectores.html","id":"vectores-numéricos","chapter":"Capítulo 6 Vectores","heading":"6.1 Vectores numéricos","text":"La forma más sencilla de crear un vector en R es con el comando c() (de concatenar elementos), y basta con introducir sus elementos entre paréntesis, y separados por comas. Voy crear el vector con las 4 edades de los miembros de mi familia.Como ves ahora en el environment (entorno, arriba la derecha) tenemos una colección de elementos guardada, con cuatro en concreto, guardados en una misma variable edades.\nImagen/gráfica 6.1: Vector en el enviroment\nLa longitud de un vector se puede calcular con el comando length() (nos devolverá el número de elementos de la variable que le pasemos como argumento).Además podemos concatenar su vez vectores (uno tras otro): vamos concatenar el vector edades consigo mismo, y añadiéndole al final un 8.Esta última concatenación lo que nos ha dado son, primero, los cuatro elementos que ya teníamos en edades, después de nuevo los cuatro elementos, y por último un 8.","code":"\nedades <- c(32, 27, 60, 61)\nedades## [1] 32 27 60 61\nlength(edades)## [1] 4\nc(edades, edades, 8)## [1] 32 27 60 61 32 27 60 61  8"},{"path":"vectores.html","id":"secuencias-numéricas-con-un-patrón","chapter":"Capítulo 6 Vectores","heading":"6.2 Secuencias numéricas con un patrón","text":"Muchas veces nos gustaría crear vectores de una forma mucho más rápida. Supongamos que queremos un vector de identificadores de números, desde el 1 hasta el 21. Si construyéramos el vector como antes, tendríamos que ejecutar el comando c(1, 2, 3, 4, 5, ...) hasta llegar al número 21. ¿Un poco largo, ?Hay un atajo: el comando seq() nos permite crear una secuencia desde un elemento inicial hasta un elemento final, avanzando de uno en uno.Es importante que perdamos el foco: programar es similar escribir en un idioma, por lo que si hay algo que se puede decir de una forma más limpia y que se entienda mejor, ¿por qué usarlo? Siempre que queramos definir secuencias entre dos números naturales (por ejemplo, entre 1 y un valor n), cuya distancia entre elementos consecutivos sea uno, el comando 1:n nos devuelve lo mismo que la orden seq(1, n). Además, si el elemento inicial es mayor que el final, R entenderá solo que la secuencia la queremos decreciente. También podemos definir otro tipo de distancia entre dos elementos consecutivos (distancia conocida como paso de discretización), por ejemplo de 0.5 en 0.5, o de 1.7 en 1.7Otras veces nos interesará definir una secuencia entre un valor inicial y un valor final, pero nos dará igual la distancia entre cada elemento: solo nos importa que tenga un número concreto de elementos (y que sea R el que decida la distancia entre elementos consecutivos para conseguirlo). Otro atajo que podemos usar para definir secuencias de números con un patrón es definir vectores de elementos repetidos, por ejemplo un vector lleno de ceros. La función rep() nos permite repetir un elemento un número fijado de veces.solo podemos repetir un número sino que podemos repetir vectores enteros.Esa repetición además podemos definirla también de forma intercalada: en lugar de repetir c(0, 1, 2) cuatro veces seguidas, queremos cuatro 0, después cuatro 1, y después cuatro 2.","code":"\nseq(1, 21) # secuencia desde 1 hasta 21 de uno en uno##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21\nn <- 21\n1:n # secuencia desde 1 hasta n (21) de uno en uno##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21\nn:1 # secuencia decreciente##  [1] 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1\nseq(1, 10, by = 0.5) # secuencia desde 1 a 10 de 0.5 en 0.5##  [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0\n## [16]  8.5  9.0  9.5 10.0\nseq(1, 21, by = 1.7) # secuencia desde 1 a 21 de 1.7 en 1.7##  [1]  1.0  2.7  4.4  6.1  7.8  9.5 11.2 12.9 14.6 16.3 18.0 19.7\nseq(1, 50, l = 11) # secuencia desde 1 a 50 de longitud 11##  [1]  1.0  5.9 10.8 15.7 20.6 25.5 30.4 35.3 40.2 45.1 50.0\nseq(1, 50, l = 8) # secuencia desde 1 a 50 de longitud 8## [1]  1  8 15 22 29 36 43 50\nrep(0, 7) # vector de 7 ceros## [1] 0 0 0 0 0 0 0\nrep(c(0, 1, 2), 4) # repetimos el vector c(0, 1, 2) 4 veces##  [1] 0 1 2 0 1 2 0 1 2 0 1 2\nrep(c(0, 1, 2), each = 4) # cuatro 0, luego cuatro 1, luego cuatro 2##  [1] 0 0 0 0 1 1 1 1 2 2 2 2"},{"path":"vectores.html","id":"vectores-de-caracteres-texto","chapter":"Capítulo 6 Vectores","heading":"6.3 Vectores de caracteres (texto)","text":"Un error común es asociar el concepto de vectores solo números: un vector es una colección o concatenación de elementos del mismo tipo pero tienen porque ser necesariamente números. Vamos crear una frase de ejemplo, un vector de 4 elementos de tipo texto (en R se llaman char): \"Mi\", \"nombre\", \"es\" \"Javier\".Como antes, las variables de tipo char o character van entre comillas dobles, ya que es un cadena de texto.Ya tenemos nuestro primer vector de texto de longitud 4. Cuando usamos la función paste() con variables diferentes, usábamos sep = ... para decidir el caracter con el que pegamos dichas cadenas texto. Cuando la función paste() la aplicamos un vector de caracteres, decidiremos que caracter queremos que vaya entre palabra con el argumento collapse =.Ahora que sabemos lo que es un vector de números, por ejemplo el vector 1:7 (el conjunto de naturales desde el 1 hasta el 7), podemos definir cadenas de texto que compartan por ejemplo un prefijo (persona_1, persona_2, …)De igual manera podemos hacer uso del ya conocido paquete glue, combinando cadenas de texto y vectores numéricos, obteniendo vectores de frases.¿Y si queremos pasar todo mayúscula o todo minúscula? ¿Y si queremos sustituir un caracter (por ejemplo, .) por otro en todos los elementos?R también nos proporciona algunas funciones muy sencillas (del paquete {base}) de usar para dichas tareas. Aquí un ejemplo de algunas de ellas.El paquete {base} también nos permite buscar y reemplazar patrones concretos en cadenas de texto (por ejemplo, sustituir toda letra «o» por el caracter «*»), con la función gsub(). ","code":"\nmi_nombre <- c(\"Mi\", \"nombre\", \"es\", \"Javier\")\nmi_nombre## [1] \"Mi\"     \"nombre\" \"es\"     \"Javier\"\npaste(mi_nombre, collapse = \"\") # todo junto## [1] \"MinombreesJavier\"\npaste(mi_nombre, collapse = \" \") # separados por un espacio## [1] \"Mi nombre es Javier\"\npaste(mi_nombre, collapse = \".\") # separados por un punto .## [1] \"Mi.nombre.es.Javier\"\npaste0(mi_nombre) # todo junto sin nada separando## [1] \"Mi\"     \"nombre\" \"es\"     \"Javier\"\npaste0(\"persona\", 1:7) # a la palabra «persona» le pegamos los números del 1 al 7## [1] \"persona1\" \"persona2\" \"persona3\" \"persona4\" \"persona5\" \"persona6\" \"persona7\"\npaste(\"persona\", 1:7, sep = \"_\") # separado por una barra baja## [1] \"persona_1\" \"persona_2\" \"persona_3\" \"persona_4\" \"persona_5\" \"persona_6\"\n## [7] \"persona_7\"\nlibrary(glue)\nedad <- 10:13 # edades\nglue(\"La edad es de {edad} años\")## La edad es de 10 años\n## La edad es de 11 años\n## La edad es de 12 años\n## La edad es de 13 años\n# Otra forma sin definir variables a priori\nglue(\"La edad es de {10:13} años\")## La edad es de 10 años\n## La edad es de 11 años\n## La edad es de 12 años\n## La edad es de 13 años\ntexto <- c(\"Hola.\", \"qué\", \"ase?\", \"todo\", \"bien.\", \"y yo\",\n           \"que\", \"ME\", \"ALEGRO\")\ntoupper(texto) # todo a mayúscula## [1] \"HOLA.\"  \"QUÉ\"    \"ASE?\"   \"TODO\"   \"BIEN.\"  \"Y YO\"   \"QUE\"    \"ME\"    \n## [9] \"ALEGRO\"\ntolower(texto) # todo a minúscula## [1] \"hola.\"  \"qué\"    \"ase?\"   \"todo\"   \"bien.\"  \"y yo\"   \"que\"    \"me\"    \n## [9] \"alegro\"\ngsub(\"o\", \"*\", texto) # toda \"o\" en el texto será sustituida por *## [1] \"H*la.\"  \"qué\"    \"ase?\"   \"t*d*\"   \"bien.\"  \"y y*\"   \"que\"    \"ME\"    \n## [9] \"ALEGRO\""},{"path":"vectores.html","id":"vectores-lógicos-truefalse","chapter":"Capítulo 6 Vectores","heading":"6.4 Vectores lógicos (TRUE/FALSE)","text":"Antes hemos comentado que las variables lógicas suelen aparecer como resultado de comparaciones de elementos. Por ejemplo, imaginemos ahora que definimos un vector de números x <- c(1.5, -1, 2, 4, 3, -4). ¿Qué numeros de x son menores que 2? Basta con que ejecutemos la orden x < 2, que nos devolverá TRUE/FALSE en cada hueco, en función de si cumple (TRUE) o (FALSE) la condición pedida.El primer, segundo y sexto elemento del vector son los únicos elementos (estrictamente) menores que 2, de ahí que en el primer, segundo y sexto elemento aparezca un TRUE y en el resto un FALSE. Es importante recordar que al evaluar una condición lógica sobre un vector de longitud n, la salida sigue siendo un vector de longitud n pero con valores lógicos.Dicha condición lógica puede hacerse con otros operadores como <=, > o >=. Al igual que antes, las condiciones pueden ser combinadas. Por ejemplo, vamos calcular qué elementos del vector c(1.5, -1, 2, 4, 3, -4) sean menores que 3 y además mayores que 0.De la misma manera podemos comprobar los elementos menores que 2 o mayores que 3 (basta con se que cumple alguna de las condiciones)","code":"\nx <- c(1.5, -1, 2, 4, 3, -4)\nx < 2## [1]  TRUE  TRUE FALSE FALSE FALSE  TRUE\nx <= 2## [1]  TRUE  TRUE  TRUE FALSE FALSE  TRUE\nx > 2## [1] FALSE FALSE FALSE  TRUE  TRUE FALSE\nx >= 2## [1] FALSE FALSE  TRUE  TRUE  TRUE FALSE\nx == 2## [1] FALSE FALSE  TRUE FALSE FALSE FALSE\nx != 2## [1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\nx <- c(1.5, -1, 2, 4, 3, -4)\nx < 3 & x > 0 # Solo los que cumplen ambas condiciones## [1]  TRUE FALSE  TRUE FALSE FALSE FALSE\nx < 2 | x > 3 # Los cumplen al menos una de ellas## [1]  TRUE  TRUE FALSE  TRUE FALSE  TRUE"},{"path":"vectores.html","id":"ausentes","chapter":"Capítulo 6 Vectores","heading":"6.5 Datos ausentes: NA y NaN","text":"La vida siempre es perfecta así que en muchas ocasiones nos encontraremos con lo que llamamos en estadística un dato ausente o missing value, un valor que tenemos en nuestra variable, y un ejemplo práctico lo tenemos con los datos de vacunación de covid del Ministerio de Sanidad. Cada día se publicaba un PDF con los datos de vacunación PERO…se publicabann datos los fines de semana: en dichas fechas hay datos que tenemos, y en R se representan por NA (significa available).","code":""},{"path":"vectores.html","id":"na-not-available","chapter":"Capítulo 6 Vectores","heading":"6.5.1 NA: not available","text":"Vamos crear un vector de números con datos ausentes con la orden x <- c(1, NA, 3, NA, NA, 5, 6): el vector tendrá longitud 7 pero en el segundo, cuarto y quinto elemento tendremos datos faltantes, un lugar que tenemos relleno (pero que eliminamos).¿Puedes aventurar qué sucede cuando multiplicamos ese vector por una constante (por 2, por ejemplo)?Un dato que tenemos, multiplicado por 2, sigue siendo un dato ausente. Es muy importante para evitar resultados erróneos que entendamos que un dato ausente computa en una operación aritmética, es un hueco vacío. Si hacemos la suma del vector, estamos sumando números más datos ausentes, por lo que el resultado final será también un dato ausente. Si tenemos algún dato ausente en nuestro vector, la suma final está su vez ausente, ¡podemos saber cuánto vale! Una manera de localizar que elementos están ausentes en nuestrps vectores es con la función .na(), una función que nos devuelve un vector de valores lógico: TRUE si el elemento está ausente y FALSE si lo está.Dichos datos ausentes se pueden eliminar con la función na.omit() (aunque veces lo que nos interesa es que sea ausente, introduciendo el punto medio entre su valor anterior y su valor posterior, por ejemplo).","code":"\nx <- c(1, NA, 3, NA, NA, 5, 6) # Vector numérico con datos faltante\nlength(x) # longitud del vector## [1] 7\nx## [1]  1 NA  3 NA NA  5  6\n2 * x # operación aritmética con un vector con NA## [1]  2 NA  6 NA NA 10 12\n1 + NA + 3## [1] NA\nis.na(x) # TRUE si está ausente (NA), FALSE si no lo está.## [1] FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE\nna.omit(x)## [1] 1 3 5 6\n## attr(,\"na.action\")\n## [1] 2 4 5\n## attr(,\"class\")\n## [1] \"omit\""},{"path":"vectores.html","id":"nan-not-a-number","chapter":"Capítulo 6 Vectores","heading":"6.5.2 NaN: not a number","text":"Hay un tipo de dato, como resultado de operaciones permitidas o cuyo resultado es indeterminado, que en R lo veremos como NaN: number, un resultado fruto de una indeterminación, como por ejemplo la operación 0/0 (cuyo límite está definido). Importante saber que también existe una forma de denotar al infinito como Inf, siendo el resultado de algunas operaciones como 1/0.De la misma manera que podemos localizar valores NA, tenemos nuestra disposición las funciones .infinte() y .nan() para detectar que elementos de nuestro vector son Inf o NaN, respectivamente.","code":"\n1/0## [1] Inf\n0/0## [1] NaN\nx <- c(1, NA, 3, 4, Inf, 6, 7, Inf, NaN, NA)\nis.na(x)##  [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\nis.nan(x)##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\nis.infinite(x)##  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE"},{"path":"vectores.html","id":"consejos-3","chapter":"Capítulo 6 Vectores","heading":"6.6 Consejos","text":"CONSEJOS Expresiones regularesDentro del entorno de paquetes tidyverse, el paquete stringr permite un manejo más complejo de cadenas de texo (como el uso de expresiones regulares).\nImagen/gráfica 6.2: Paquete stringr para manejar cadenas de texto más complejas\n ","code":""},{"path":"vectores.html","id":"ejercicios-2","chapter":"Capítulo 6 Vectores","heading":"6.7 📝 Ejercicios","text":"(haz click en las flechas para ver soluciones)📝Ejercicio 1: modifica el código anterior para crear un vector de nombre vector_num que contenga los números 1, 5 y -7.Solución: 📝Ejercicio 2: define un vector que contenga los números 1, 10, -1 y 2, y guárdalo en una variable llamada vector_num. Solución: 📝Ejercicio 3: obtén la longitud del vector anterior vector_num. Solución: 📝Ejercicio 4: crea un vector con las palabras “Hola”, “”, “llamo” (y tu nombre y apellidos), y pega luego sus elementos de forma que la frase esté correctamente escrita en castellano. Tras hacerlo, añade “y tengo 30 años”. Solución: 📝Ejercicio 5: el código inferior crea una secuencia de números, que empieza en -1, que acaba en 32, y que va saltando de 2 en 2. Modíficalo para que haga el salto de 3 en 3 y guárdalo en una variable llamada secuenciaSolución: 📝Ejercicio 6: crea una secuencia de números, que empiece en -1, que acabe en 32, y que tenga longitud 12. Solución: 📝Ejercicio 7: crea una secuencia que empiece en 1 y recorra todos los naturales hasta el 10. Después crea otra secuencia de longitud 7 que todos los números sean 3. Solución: 📝Ejercicio 8: crea una secuencia que repita 5 veces el patrón 1, 2, 3. Después crea otra que repita dicho patrón pero de forma intercalada, con 5 veces 1, después 5 veces 2 y después 5 veces 3.Solución: 📝Ejercicio 9: crea un vector con las edades de cuatro conocidos o familiares. Tras ello, determina cuáles de ellos tienen menos de 20 años, 30 años o más, menos de 40 años y más de 65 años.Solución:","code":"\n# Vector de números\nvector_num <- c(1)\nvector_num\n# Vector de números\nvector_num <- c(1, 5, -7)\nvector_num## [1]  1  5 -7\n# Vector de números\nvector_num <- c(1, 10, -1, 2)\nvector_num## [1]  1 10 -1  2\n# Longitud del vector\nlength(vector_num)## [1] 4\n# Definiendo el vector\nvector_char <- c(\"Hola\", \"me\", \"llamo\", \"Javier\",\n                 \"Álvarez\", \"Liébana\")\n\n# Pegamos\nfrase <- paste(vector_char, collapse = \" \")\nfrase## [1] \"Hola me llamo Javier Álvarez Liébana\"\n# Añadimos frase\nglue(\"{frase} y tengo 30 años.\")## Hola me llamo Javier Álvarez Liébana y tengo 30 años.\n# Otra forma\npaste0(frase, \" y tengo 30 años.\")## [1] \"Hola me llamo Javier Álvarez Liébana y tengo 30 años.\"\n# Otra forma\npaste(frase, \"y tengo 30 años.\")## [1] \"Hola me llamo Javier Álvarez Liébana y tengo 30 años.\"\nseq(-1, 32, by = 2)\nsecuencia <- seq(-1, 32, by = 3)\nsecuencia##  [1] -1  2  5  8 11 14 17 20 23 26 29 32\nlength(secuencia) # longitud de la secuencia## [1] 12\nsecuencia <- seq(-1, 32, l = 12)\nsecuencia##  [1] -1  2  5  8 11 14 17 20 23 26 29 32\nlength(secuencia) # longitud de la secuencia## [1] 12\n1:10##  [1]  1  2  3  4  5  6  7  8  9 10\nrep(3, 7) # secuencia repetida## [1] 3 3 3 3 3 3 3\nrep(c(1, 2, 3), 5) # repetimos patrón (1, 2, 3) 5 veces##  [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3\nrep(c(1, 2, 3), each = 5) # repetimos patrón alternado##  [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3\nedades <- c(27, 32, 60, 61) # en mi caso, por ejemplo\nedades < 20 # menos de 20 años## [1] FALSE FALSE FALSE FALSE\nedades >= 30 # 30 años o más## [1] FALSE  TRUE  TRUE  TRUE\nedades < 40 # menos de 40 años## [1]  TRUE  TRUE FALSE FALSE\nedades > 65 # más de 65 años## [1] FALSE FALSE FALSE FALSE"},{"path":"operacionesvectores.html","id":"operacionesvectores","chapter":"Capítulo 7 Operaciones con vectores","heading":"Capítulo 7 Operaciones con vectores","text":"Scripts usados:script04.R: operaciones con vectores. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script04.R","code":""},{"path":"operacionesvectores.html","id":"operaciones-aritméticas-con-vectores-numéricos","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.1 Operaciones aritméticas con vectores numéricos","text":"Hemos dicho que un número es un vector de longitud 1, así que toda operación aritmética (suma, resta, multiplicación, etc) que podamos hacer con un número la vamos poder hacer con un vector de númerosSi hacemos por ejemplo la operación 2 * z, siendo z un vector, lo que sucederá es que la operación se realizará en CADA ELEMENTO del vector.De la misma manera sucede si sumamos o restamos una constante.De la misma manera se pueden definir sumas de vectores, como z + x, raíces cuadradas sqrt(z) o elevar cada elemento al cuadrado z^2. En R, salvo que especifiquemos lo contrario, toda operación ARITMÉTICA que hagas un vector será elemento elemento. Esto último es bastante importante que se te olvide ya que en otros lenguajes siempre es así. Dado que la operación (por ejemplo, una suma) se realiza elemento elemento, ¿qué sucederá si sumamos dos vectores de distinta longitud? Prueba definir un vector con los 4 primeros impares, e intentar hacer la suma z + y (un vector de longitud 3 más un vector de longitud 4).R intenta molestarte lo menos posible, así que lo que hace es reciclar elementos: si tiene un vector de 4 elementos y le intentas sumar uno de 3 elementos, lo que hará será reciclar elementos del vector con menor longitud: hará 1+2, 3+4, 5+6 pero… 7+2 (vuelve al primero). Como hemos comentado anteriormente, los valores lógicosTRUE/FALSE son guardados internamente como 0/1 por lo que podemos usar operaciones aritméticas con ellos. Por ejemplo, si queremos averiguar el número de elementos de un vector que cumplen una condición lógica (por ejemplo, < 2), los que lo hagan tendrán asignado un 1 y los que un 0, por lo que basta con sumar dicho vector lógico para obtener el número de elementos que cumplen dicha condición.","code":"\n# Multiplicamos por 2 a CADA ELEMENTO del vector\nz <- c(2, 4, 6)\n2 * z## [1]  4  8 12\n# Sumamos 3 a CADA ELEMENTO DEL VECTOR\nz + 3## [1] 5 7 9\n# Restamos 5 a CADA ELEMENTO DEL VECTOR\nz - 5## [1] -3 -1  1\nx <- c(1, 3, 5)\nx + z # suma de vectores ## [1]  3  7 11\nsqrt(z) # Hacemos la raíz cuadrada de CADA ELEMENTO DEL VECTOR## [1] 1.414214 2.000000 2.449490\nz^2 # Elevamos al cuadrado CADA ELEMENTO DEL VECTOR## [1]  4 16 36\ny <- c(1, 3, 5, 7)\nz + y## [1]  3  7 11  9\nsum(x < 2) # sumamos el vector de TRUE/FALSE --> número de TRUE## [1] 1"},{"path":"operacionesvectores.html","id":"operaciones-estadísticas-con-vectores-numéricos","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.2 Operaciones estadísticas con vectores numéricos","text":"Al igual que podemos ejecutar operaciones aritméticas, podemos realizar también operaciones estadísticas con los vectores, como calcular su suma (sum()), su media (mean()), su mediana (median()) o su suma acumulada (cumsum() cada elemento lo acumula al anterior).Hagamos antes un repaso de algunos términos estadísticos:Media: medida de centralización que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. pesar de ser la más conocida, la media es muy poco robusta: dado un conjunto, si se introducen valores atípicos o outliers (valores muy grandes o muy pequeños), la media se perturbar con mucha facilidad (por ejemplo, el salario medio en un país con mucha desigualdad tiene valor estadístico ya que está perturbado por las altas fortunas). Dado un vector de valores \\(x = (x_1, \\ldots, x_n)\\), se denota como \\(\\overline{x}\\).\\[\\overline{x} = \\frac{\\displaystyle \\sum_{=1}^{n}x_i}{n}\\]Mediana: medida de centralización que consiste en, tras ordenar los datos de menor mayor, quedarnos con el valor que ocupa el medio (deja tantos números por debajo como por encima). Más robusta que la media aunque menos que la moda. Dado un vector de valores \\(x = (x_1, \\ldots, x_n)\\), se denota como \\(Me_x\\).\\[Me_x = \\displaystyle \\arg \\min_{x_i} \\left\\lbrace F_i > 0.5 \\right\\rbrace, \\quad F_i = \\frac{\\#\\left\\lbrace x_j \\leq x_i \\right\\rbrace}{n}\\]Moda: medida de centralización que consiste en encontrar el valor más repetido (el valor trending). Es la medida de centralización más robusta. Dado un vector de valores \\(x = (x_1, \\ldots, x_n)\\), se denota como \\(Mo_x\\).\\[Mo_x = \\displaystyle \\arg \\max_{x_i} f_i  , \\quad f_i = \\frac{\\#\\left\\lbrace x_j = x_i \\right\\rbrace}{n}\\] aquí un ejemplo de algunas funciones estadísticas útilesOtra operación útil en estadística es calcular los percentiles con la función quantiles().Recuerda que en R algunas funciones tienen argumentos por defecto, argumentos que necesitan ser asignados un valor priori. En el ejemplo de calcular los percentiles con quantile(), hay un argumento por defecto (con un valor ya asignado sino se especifica lo contrario) que es probs = c(0, 0.25, 0.5, 0.75, 1). Pero dicho argumento por defecto puede ser cambiado, por ejemplo, para sacar los percentiles 15%-30%-70%-90%.","code":"\nsum(y) # suma## [1] 16\nmean(y) # media## [1] 4\nmedian(y) # mediana## [1] 4\ncumsum(y) # suma acumulada## [1]  1  4  9 16\ny <- c(1, 2, 5, 5, 8, 9, 10, 10, 10, 11, 13, 15, 20, 23, 24, 29)\nquantile(y) # Percentiles por defecto: cuartiles (0%-25%-50%-75%-100%)##    0%   25%   50%   75%  100% \n##  1.00  7.25 10.00 16.25 29.00\ny <- c(1, 2, 5, 5, 8, 9, 10, 10, 10, 11, 13, 15, 20, 23, 24, 29)\nquantile(y, probs = c(0.15, 0.3, 0.7, 0.9)) # Percentiles p15, p30, p70 y p90##  15%  30%  70%  90% \n##  5.0  8.5 14.0 23.5"},{"path":"operacionesvectores.html","id":"operacionesausentes","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.2.1 Operaciones con ausentes","text":"Para evitar que un dato ausente en nuestros datos nos impida hacer ciertas operaciones, en muchas funciones de R podemos añadir el argumento na.rm = TRUE: primero elimina los datos ausentes, y luego ejecuta la función.","code":"\nx <- c(1, NA, 3, NA, NA, 5, 6)\n\n# eliminando datos ausentes antes de aplicar la función\nsum(x, na.rm = TRUE) ## [1] 15\nmean(x, na.rm = TRUE)## [1] 3.75"},{"path":"operacionesvectores.html","id":"seleccionar-elementos","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.3 Seleccionar elementos","text":"Ya sabemos definir variables que sean vectores (recuerda: colección de valores del mismo tipo). ¿Y si del vector original queremos EXTRAER UN SUBCONJUNTO del mismo, por ejemplo, los primeros 10 elementos?R tiene varias formas de hacer esto pero la más sencilla es entendiendo que si yo quiero acceder al elemento -ésimo de un vector, deberé usar el operador de selección []. Veamos un ejemplo: definimos las edades de cinco personas y queremos saber la edad de la persona que ocupa el tercer lugar.Un número es más que un vector de longitud uno, así que esta operación también la podemos aplicar usando un vector de índices seleccionar, de forma que le podemos indicar simultaneamente que valores que queremos (por ejemplo, al tercer y cuarto elemento de nuestras edades).Esta lógica de acceder elementos de vectores también sirve para nuestros vectores de caracteres.Para acceder al último elemento de un vector podemos pasarle como índice la longitud de dicho vector (si el vector tiene longitud 6, el último elemento ocupará el lugar 6).Otras veces querremos seleccionar un elemento en concreto sino filtrar algunos elementos en concreto y extraerlos, eliminarlos, para lo cual deberemos repetir la misma operación pero con el signo - delante: el operador [-] selecciona el elemento -ésimo del vector sino que lo elimina en nuestro filtro. Sin embargo, lo habitual es que dicho filtro lo hagamos en base una condición lógica. Supongamos que x <- c(7, 20, 18, 3, 19, 9, 13, 3, 45) e y <- c(17, 21, 58, 33, 15, 59, 13, 1, 45) son las edades de dos grupos de personas y que queremos quedarnos solo con los mayores edad. ¿Tenemos que andar averiguando en que posición se encuentran para luego seleccionarlos? , vamos seleccionar los elementos que cumplen una condición dada.Lo que hemos hecho ha sido pasar como índices seleccionar un vector lógico TRUE/FALSE: solo filtrará los lugares donde se guarde un TRUE, aquellos que cumplen la condición lógica introducida.Esto también nos puede servir para limpiar de datos ausentes, combinando la función .na(), que nos localiza el lugar que ocupan los ausentes, con el operador !, que lo que hace es negar lo que venga detrás.También podemos probar combinar condiciones lógicas para nuestra selección.Como ves, si un valor es NA, la evaluación de una condición lógica sobre él (mayor o menor de 18 años) nos seguirá devolviendo NA. ","code":"\nedades <- c(20, 30, 32, NA, 61)\nedades[3] # accedemos a la edad de la tercera persona en la lista## [1] 32\nedades[4] # accedemos a la edad de la cuarta persona (que no la tenemos guardada)## [1] NA\nedades[c(3, 4)] # queremos acceder a la vez al tercer y cuarto elemento## [1] 32 NA\ny <- c(\"hola\", \"qué\", \"tal\", \"todo\", \"ok\", \"?\")\ny[1:2] # Solo queremos acceder a los elementos en la posición 1 y 2## [1] \"hola\" \"qué\"\ny[c(1:2, length(y))] # Solo accedemos a los elementos en la posición 1, 2 y además el que ocupa la última posición (recuerda: length(y) nos da la longitud total del vector)## [1] \"hola\" \"qué\"  \"?\"\ny## [1] \"hola\" \"qué\"  \"tal\"  \"todo\" \"ok\"   \"?\"\ny[-2] # Nos muestra todo y salvo el elemento que ocupa la segunda posición## [1] \"hola\" \"tal\"  \"todo\" \"ok\"   \"?\"\nx <- c(7, 20, 18, 3, 19, 9, 13, 3, 45)\ny <- c(17, 21, 58, 33, 15, 59, 13, 1, 45)\nx[x >= 18] # mayores de 18 años del conjunto x## [1] 20 18 19 45\ny[x >= 18] # mayores de 18 años del conjunto y## [1] 21 58 15 45\nx >= 18 # donde haya TRUE, lo seleccionará## [1] FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE\nx[x >= 18] # mayores de 18 años del conjunto x## [1] 20 18 19 45\nx <- c(7, NA, 20, 3, 19, 21, 25, 80, NA)\nx[is.na(x)] # solo valores ausentes## [1] NA NA\nx[!is.na(x)] # sin valores ausentes: ! es el símbolo de la negación## [1]  7 20  3 19 21 25 80\nx[x >= 18 & x <= 25] # los valores que cumplen ambas (&): entre 18 y 25 años## [1] NA 20 19 21 25 NA"},{"path":"operacionesvectores.html","id":"nombrando-vectores","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.3.1 Nombrando vectores","text":"Además R nos permite dar significado léxico nuestros valores (significan algo, solo números), pudiendo poner nombres los elementos de un vector.Esto es una ventaja ya que nos permite su selección usando dichos nombres: ya elegimos el tercer número o el primero, sino el número que representa el teléfono y el código postal de una persona.Con la función names() podemos, solo consultar los nombres de una variable, sino cambiarlos nuestro gusto. ","code":"\nx <- c(\"edad\" = 31, \"tlf\" = 613910687, \"cp\" = 33007) # cada número tiene un significado distinto\nx##      edad       tlf        cp \n##        31 613910687     33007\nx[c(\"edad\", \"cp\")] # seleccionamos los elementos que tienen ese nombre asignado##  edad    cp \n##    31 33007\nnames(x) # Consultamos nombres## [1] \"edad\" \"tlf\"  \"cp\"\nnames(x) <- c(\"años\", \"móvil\", \"dirección\") # Cambiamos nombres\nnames(x) # Consultamos nuevos nombres## [1] \"años\"      \"móvil\"     \"dirección\"\nx##      años     móvil dirección \n##        31 613910687     33007"},{"path":"operacionesvectores.html","id":"which","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.3.2 which","text":"Hemos visto como seleccionar elementos de un vector que cumplen una condición, para veces queremos el elemento en sí, sino el lugar que ocupa: ¿qué valores de un vector cumplen una condición lógica, qué lugar ocupan? Para obtener dicho índice tenemos nuestro disposición la función (), que nos devuelve el elemento en sí sino su lugar.Esta función es muy útil especialmente cuando queremos averiguar el valor que ocupa el máximo/mínimo de una colección de valores, con las funciones .max() y .min().","code":"\nx <- c(7, NA, 20, 3, 19, 21, 25, 80, NA)\nx[x >= 18] # Accedemos a los elementos que cumplen la condición## [1] NA 20 19 21 25 80 NA\nwhich(x >= 18) # Obtenemos los lugares que ocupan los elementos que cumplen la condición## [1] 3 5 6 7 8\nx## [1]  7 NA 20  3 19 21 25 80 NA\nmax(x, na.rm = TRUE) # máximo de x (si no eliminamos NA, nos devolverá NA)## [1] 80\nmin(x, na.rm = TRUE) # mínimo de x (si no eliminamos NA, nos devolverá NA)## [1] 3\nwhich.max(x) # Lugar que ocupa el máximo## [1] 8\nwhich.min(x) # Lugar que ocupa el mínimo## [1] 4"},{"path":"operacionesvectores.html","id":"null","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.3.3 NULL","text":"veces además de NA y NaN, R nos muestra un dato llamado NULL. Cuando tenemos NA en alguna variable, el registro existe, pero está relleno. Sin embargo, cuando tenemos un NULL significa que ese valor ni siquiera existe: es un dato guardado pero cuyo valor desconocemos, es un dato que ni siquiera existe (por ejemplo, si guardamos datos de 7 personas, el dato de la octava persona es NA, es que hay octava persona directamente).","code":"\nx <- c(1, NA, 3, NA, NA, 5, 6)\nx[2] # NA: el registro existe pero sin dato## [1] NA\nnames(x) # No hemos definido el nombre de las variables, así que devuelve NULL## NULL"},{"path":"operacionesvectores.html","id":"ordenar","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.4 Ordenar","text":"Una acción habitual al trabajar con datos es saber ordenarlos: de menor mayor edad, datos más recientes vs antiguos, etc. Para ello tenemos la función sort(), que podemos usar directamente para ordenar de menor mayor. Vamos ordenar, por ejemplo, una colección de edades de diferentes personas.Por defecto, sort() ordena de menor mayor. Con el argumento opcional decreasing = TRUE podemos ordenar de mayor menor.Otra forma de ordenar un vector es que R nos devuelva los índices de los elementos ordenados, y luego usar dichos índices para reorganizar los elementos, con la función order().","code":"\nedades <- c(81, 7, 25, 41, 65, 20, 32, 23, 77)\nsort(edades) # orden de joven a mayor## [1]  7 20 23 25 32 41 65 77 81\nsort(edades, decreasing = FALSE) # orden de mayor a joven## [1]  7 20 23 25 32 41 65 77 81\norder(x) ## [1] 1 3 6 7 2 4 5\nx[order(x)] # accedemos a los índices ordenados## [1]  1  3  5  6 NA NA NA"},{"path":"operacionesvectores.html","id":"consejos-4","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.5 Consejos","text":"CONSEJOS Operaciones estadísticasComo podido comprobar, las operaciones ESTADÍSTICAS se realizan elemento elemento: la media o la suma las realiza tomando todos los elementos del vector. , anyExisten dos funciones muy útiles en R para saber si TODOS o ALGUNO de los elementos de un vector cumple una condición. Las funciones () y () nos devolverá un único valor lógico. Estas funciones son muy útiles al final de los códigos para comprobar que las condiciones que tienen que verificar los datos se cumplen, y asegurarnos que el proceso se ha ejecutado correctamente (por ejemplo, que todos los datos sean positivos o haya datos ausentes). Argumentos por defectoLa función sort() es un buen ejemplo de que las funciones traen definidos argumentos por defecto (aunque los veamos priori). La orden sort(x) en realidad está ejecutando sort(x, decreasing = TRUE), pero como es su valor por defecto, nos podemos ahorrar incluirlo. Escribe ? help sort() en la consola y verás como en la cabecera de la función ya hay preasignado un decreasing = TRUE. Diferencia de conjuntosUna función muy útil para ver las diferencias entre dos conjuntos es setdiff(), una función que nos devuelve los elementos distintos entre dos conjuntos. Optimiza tu códigoAunque parezca un tema menor, si tu código tarda 1 milisegundo más de lo que podría tardar de otra forma, si esa orden se repite muchas veces, ese milisegundo extra puede ser 5, 10 o 20 minutos más que tu código tardará en ejecutarse. Hay un paquete muy útil en R para medir tiempos de distintas órdenes que hacen lo mismo (el paquete microbenchmark), vamos instalarlo.Este paquete contiene una orden para comparar el tiempo de dos órdenes: necesita como primeros argumentos las dos órdenes cuyos tiempos vamos comparar, y un argumento times en el que le indicamos el número de veces que ejecutará cada orden para realizar los tiempos medios. Vamos comparar los comandos de ordenación order() y sort().Sí, estás viendo bien: aunque priori parezca contraintuitivo, es más corto obtener los índices ordenados de un vector, y luego reordenarlo en base esos índices, que la ordenación directa través del comando sort() (ya que usan algoritmos de ordenación distintos).","code":"\nx <- c(1, 2, 3, 4, 5, NA, 7)\nall(x < 3)## [1] FALSE\nany(x < 3)## [1] TRUE\nall(x > 0)## [1] NA\nall(na.omit(x) > 0)## [1] TRUE\nall(is.na(x))## [1] FALSE\nany(is.na(x))## [1] TRUE\ny <- 1:10\nz <- c(1, 3, 7, 10)\nsetdiff(y, z) # Elementos en y que no están en z ## [1] 2 4 5 6 8 9\ninstall.packages(\"microbenchmark\")\nlibrary(microbenchmark)\nx <- rnorm(1e3) # 1000 elementos aleatorias de una normal N(0, 1)\nmicrobenchmark(sort(x), # primera forma\n               x[order(x)], # segunda forma\n               times = 1e3) # se repetirá 1000 veces## Unit: microseconds\n##         expr    min      lq     mean  median     uq     max neval cld\n##      sort(x) 44.579 50.3730 58.35313 55.1740 59.773 229.543  1000   b\n##  x[order(x)] 30.714 36.5935 42.55647 38.7355 42.061 941.536  1000  a"},{"path":"operacionesvectores.html","id":"ejercicios-3","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.6 📝 Ejercicios","text":"(haz click en las flechas para ver soluciones)📝Ejercicio 1: define de nuevo el vector vector_num definido como un vector que contenga los números 1, 10, -1 y 2) y calcula su suma. Solución: 📝Ejercicio 2: define otro vector vector_num2 que contenga los números 5, -7, 8, -3, y haz la suma de vector_num y vector_num2. Solución: 📝Ejercicio 3: calcula el número de elementos mayores que 0 del resultado de la suma de vector_num y vector_num2. Solución: 📝Ejercicio 4: calcula la versión ordenada del vector vector_num. Solución: 📝Ejercicio 5: encuentra del vector vector_num original el lugar (el índice) que ocupa su mínimo y su máximo. Solución: 📝Ejercicio 6: encuentra del vector vector_num los elementos mayores que 1 y menores que 7. Encuentra una forma de averiguar si todos los elementos son o positivos. Solución: 📝Ejercicio 7: define el vector c(-1, 0, 4, 5, -2), calcula la raíz cuadrada del vector y determina que lugares son ausente de tipo NaN. Solución: 📝Ejercicio 8: define el vector de los primeros números impares (hasta el 21) y extrae los elementos que ocupan los lugares 1, 4, 5, 8. Elimina del vector el segundo elementoSolución:","code":"\n# Vector de números\nvector_num <- c(1, 10, -1, 2)\n\n# Suma\nsum(vector_num)## [1] 12\n# Vector de números\nvector_num2 <- c(5, -7, 8, -3)\n\n# Suma\nvector_num + vector_num2## [1]  6  3  7 -1\n# Vector de números\nvector_suma <- vector_num + vector_num2\n\n# Suma\nsum(vector_suma > 0)## [1] 3\n# Ordenamos el vector (con sort)\nsort(vector_num)## [1] -1  1  2 10\n# Ordenamos el vector  (con order)\nvector_num[order(vector_num)]## [1] -1  1  2 10\nvector_num <- c(1, 10, -1, 2)\n\n# Encontrando el lugar que ocupa el máximo y mínimo\nwhich.max(vector_num)## [1] 2\nwhich.min(vector_num)## [1] 3\n# Vector lógico: mayores que 1 y menores que 7\nvector_num > 1 & vector_num < 7## [1] FALSE FALSE FALSE  TRUE\n# ¿Son todos positivos?\nall(vector_num > 0)## [1] FALSE\n# Vector\nx <- c(-1, 0, 4, 5, -2)\n\n# ¿Cuáles son ausentes tras aplicar la raíz cuadrada?\nis.nan(sqrt(x))## [1]  TRUE FALSE FALSE FALSE  TRUE\n# Vector de impares (de 1 a 21 saltando de dos en dos)\nx <- seq(1, 21, by = 2)\n\n# Seleccionamos elementos\nx[c(1, 4, 5, 8)]## [1]  1  7  9 15\n# Eliminamos elementos\ny <- x[-2]\ny##  [1]  1  5  7  9 11 13 15 17 19 21"},{"path":"datos.html","id":"datos","chapter":"Capítulo 8 Datos estructurados","heading":"Capítulo 8 Datos estructurados","text":"Scripts usados:script05.R: matrices y data.frames. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script05.RYa sabemos un poco la gramática y ortografía de nuestro lenguaje, y algunas de las funcionalidades básicas de nuestro «Word». Vamos aprender cómo escribir la mejor trama para la novela: hablemos por fin de datos.","code":""},{"path":"datos.html","id":"matrices","chapter":"Capítulo 8 Datos estructurados","heading":"8.1 Matrices","text":"Hasta ahora, si quisiéramos trabajar con los datos de una persona y lo imaginamos en un Excel, hemos aprendido algunos tipos básicos que pueden tomar las celdas, y hemos aprendido formar columnas (vectores, colecciones de elementos del mismo tipo).Pero hasta ahora cada columna la hemos tratado por separado: una colección de números, otra de caracteres, otra de fechas… De momento solo hemos visto solo datos en una dimensión: una sola variable de \\(n\\) elementos.Pero cuando analizamos datos solemos tener varias variables distintas de cada individuo, por ejemplo, la estatura y el peso de una persona. Necesitamos una «tabla». Necesitamos una manera de unir distintas variables numéricas, todas de IGUAL longitud. Y ese conjunto de variables (del mismo tipo e igual longitud), dispuestas en columnas, es lo que conocemos como matrices: una «tabla» de valores del mismo tipo, con filas y columnas.Vamos empezar definiendo una matriz sencilla: imagina que tenemos las estaturas y pesos de 5 personas.¿Cómo juntar las dos variables creando nuestro primer conjunto de datos? Vamos crear una matriz, un conjunto de números organizado en 2 columnas (una por variable) y 5 filas o registros (una por persona). Para ello usaremos la función cbind(), que nos concatena vectores de igual longitud en columnas.Nuestro primer conjunto de datos :) Podemos visualizar la matriz en un formato «excelizado» con la función View()\nImagen/gráfica 8.1: Nuestra primera matriz de datos\nTambién podemos construir la matriz por filas con el comando rbind(), que nos permite añadir filas una matriz o construirla desde cero (aunque lo habitual es tener cada variable en una columna y cada individuo en una fila).Para practicar vamos definir otro ejemplo, con las edades, teléfonos y códigos postales de una serie de individuos (fíjate que metido adrede datos ausentes, ya que veces tendremos datos de algunas personas).De nuevo tenemos una tabla de números: una columna por variable y una fila por registro. Los comandos cbind() y rbind() solo nos permiten crear matrices desde cero sino también añadir filas o columnas matrices existentes.Como ves, ahora nuestros datos están tabulados, tienen dos dimensiones. ¿Cómo saber las dimensiones que tiene una matriz? Prueba ejecutar la función dim().Fíjate que dim() devuelve un vector de 2 elementos (las dos dimensiones), por lo que para acceder al número de filas deberemos ejecutar dim(x)[1] (y dim(x)[2] para el número de columnas).También tenemos nuestra disposición las funciones nrow() y ncol(), que nos devuelven directamente el número de filas y columnas.Igual que veces es útil generar un vector de elementos repetidos, también podemos definir una matriz de números repetidos (por ejemplo, de ceros), con la función matrix(), indicándole el número de filas y columnas.También podemos definir una matriz partir de un vector numérico, reorganizando los valores en forma de matriz (con una dimensión tal que filas * columnas = longitud del vector), sabiendo que los elementos se van colocando por columnas (primeros valores en la primera columna, de arriba abajo). Dada una matriz también podemos «darle vuelta» (lo que se conoce como matriz transpuesta, donde filas pasan ser columnas y viceversa) con la función t().Con las matrices sucede como con los vectores: cuando aplicamos una operación aritmética, se la estamos aplicando elemento elemento, por ejemplo, dividir entre 5 o sumar una constanteTambién podemos crear matrices de otros tipos de datos, siempre y cuando las columnas sean del mismo tipo e igual longitud, por ejemplo una matriz de caracteres o una matriz de valores lógicos","code":"\n# Ejemplos de variables unidimensionales (vectores)\nc(1, 4, NA, -2, 0)## [1]  1  4 NA -2  0\nc(\"a\", NA, \"b\", \"c\")## [1] \"a\" NA  \"b\" \"c\"\nc(TRUE, TRUE, FALSE, TRUE)## [1]  TRUE  TRUE FALSE  TRUE\nestaturas <- c(150, 160, 170, 180, 190)\npesos <- c(60, 70, 80, 90, 100)\ndatos_matriz <- cbind(estaturas, pesos) # Construimos la matriz por columnas\ndatos_matriz # nuestra primera matriz##      estaturas pesos\n## [1,]       150    60\n## [2,]       160    70\n## [3,]       170    80\n## [4,]       180    90\n## [5,]       190   100\nView(datos_matriz)\nrbind(estaturas, pesos) # Construimos la matriz por filas##           [,1] [,2] [,3] [,4] [,5]\n## estaturas  150  160  170  180  190\n## pesos       60   70   80   90  100\nedades <- c(14, 24, 56, 31, 20, 87, 73) # vector numérico de longitud 7\ntlf <- c(NA, 683839390, 621539732, 618211286, NA, 914727164, NA)\ncp <- c(33007, 28019, 37005, 18003, 33091, 25073, 17140)\n\n# Construimos la matriz por columnas\ndatos_matriz <- cbind(edades, tlf, cp) \ndatos_matriz##      edades       tlf    cp\n## [1,]     14        NA 33007\n## [2,]     24 683839390 28019\n## [3,]     56 621539732 37005\n## [4,]     31 618211286 18003\n## [5,]     20        NA 33091\n## [6,]     87 914727164 25073\n## [7,]     73        NA 17140\n# Añadimos una fila\nrbind(datos_matriz, c(27, 620125780, 28051))##      edades       tlf    cp\n## [1,]     14        NA 33007\n## [2,]     24 683839390 28019\n## [3,]     56 621539732 37005\n## [4,]     31 618211286 18003\n## [5,]     20        NA 33091\n## [6,]     87 914727164 25073\n## [7,]     73        NA 17140\n## [8,]     27 620125780 28051\n# Añadimos una columna\ncbind(datos_matriz, \"estaturas\" = c(160, 155, 170, 181, 174, NA, 165))##      edades       tlf    cp estaturas\n## [1,]     14        NA 33007       160\n## [2,]     24 683839390 28019       155\n## [3,]     56 621539732 37005       170\n## [4,]     31 618211286 18003       181\n## [5,]     20        NA 33091       174\n## [6,]     87 914727164 25073        NA\n## [7,]     73        NA 17140       165\ndim(datos_matriz)## [1] 7 3\ndim(datos_matriz)[1]## [1] 7\ndim(datos_matriz)[2]## [1] 3\nnrow(datos_matriz)## [1] 7\nncol(datos_matriz)## [1] 3\nmatrix(0, nrow = 5, ncol = 3) # 5 filas, 3 columnas, todo 0's##      [,1] [,2] [,3]\n## [1,]    0    0    0\n## [2,]    0    0    0\n## [3,]    0    0    0\n## [4,]    0    0    0\n## [5,]    0    0    0\nz <- matrix(1:15, ncol = 5) # Matriz con el vector 1:5 con 5 columnas (ergo 3 filas)\nz##      [,1] [,2] [,3] [,4] [,5]\n## [1,]    1    4    7   10   13\n## [2,]    2    5    8   11   14\n## [3,]    3    6    9   12   15\ndatos_matriz##      edades       tlf    cp\n## [1,]     14        NA 33007\n## [2,]     24 683839390 28019\n## [3,]     56 621539732 37005\n## [4,]     31 618211286 18003\n## [5,]     20        NA 33091\n## [6,]     87 914727164 25073\n## [7,]     73        NA 17140\nt(datos_matriz) # Matriz transpuesta##         [,1]      [,2]      [,3]      [,4]  [,5]      [,6]  [,7]\n## edades    14        24        56        31    20        87    73\n## tlf       NA 683839390 621539732 618211286    NA 914727164    NA\n## cp     33007     28019     37005     18003 33091     25073 17140\ndatos_matriz / 5##      edades       tlf     cp\n## [1,]    2.8        NA 6601.4\n## [2,]    4.8 136767878 5603.8\n## [3,]   11.2 124307946 7401.0\n## [4,]    6.2 123642257 3600.6\n## [5,]    4.0        NA 6618.2\n## [6,]   17.4 182945433 5014.6\n## [7,]   14.6        NA 3428.0\ndatos_matriz + 3##      edades       tlf    cp\n## [1,]     17        NA 33010\n## [2,]     27 683839393 28022\n## [3,]     59 621539735 37008\n## [4,]     34 618211289 18006\n## [5,]     23        NA 33094\n## [6,]     90 914727167 25076\n## [7,]     76        NA 17143\n# matriz de caracteres\nnombres <- c(\"Javier\", \"Carlos\", \"María\", \"Paloma\")\napellidos <- c(\"Álvarez\", \"García\", \"Pérez\", \"Liébana\")\ncbind(nombres, apellidos)##      nombres  apellidos\n## [1,] \"Javier\" \"Álvarez\"\n## [2,] \"Carlos\" \"García\" \n## [3,] \"María\"  \"Pérez\"  \n## [4,] \"Paloma\" \"Liébana\"\n# matriz de valores lógicos\nvar1 <- c(TRUE, TRUE, FALSE, FALSE, TRUE)\nvar2 <- c(TRUE, FALSE, FALSE, TRUE, TRUE)\ncbind(var1, var2)##       var1  var2\n## [1,]  TRUE  TRUE\n## [2,]  TRUE FALSE\n## [3,] FALSE FALSE\n## [4,] FALSE  TRUE\n## [5,]  TRUE  TRUE\ncbind(var1, var2) + 1##      var1 var2\n## [1,]    2    2\n## [2,]    2    1\n## [3,]    1    1\n## [4,]    1    2\n## [5,]    2    2"},{"path":"datos.html","id":"acceder-a-elementos","chapter":"Capítulo 8 Datos estructurados","heading":"8.1.1 Acceder a elementos","text":"Si recuerdas para los vectores, usábamos el operador [] para acceder al elemento -ésimo.En el caso de las matrices la lógica será la misma: para acceder la fila -ésima de la matriz se usa el operador [, ] (dejando libre el índice de la columna), mientras que para acceder la columna j-ésima de la matriz se usaría el operador [, j] (dejando libre el índice de la fila). Para acceder conjuntamente al elemento (, j) se usa el operador [, j].Si las columnas tienen nombres también podemos hacer uso de ellos para acceder las columnasIncluso podemos asignar nombres las filas de una matriz con row.names() y acceder filas y columnas por nombres.","code":"\nx <- c(1, 2, 10, 67, -1, 0)\nx[3] # accedemos al tercer elemento ## [1] 10\nx[c(3, 5)] # accedemos al tercer y quinto elemento## [1] 10 -1\nx[1:4] # accedemos al primero, segundo, tercero, cuarto elemento## [1]  1  2 10 67\ndatos_matriz##      edades       tlf    cp\n## [1,]     14        NA 33007\n## [2,]     24 683839390 28019\n## [3,]     56 621539732 37005\n## [4,]     31 618211286 18003\n## [5,]     20        NA 33091\n## [6,]     87 914727164 25073\n## [7,]     73        NA 17140\ndatos_matriz[1, 3] # elemento (1, 3)##    cp \n## 33007\ndatos_matriz[1, ] # fila 1## edades    tlf     cp \n##     14     NA  33007\ndatos_matriz[, 3] # columna 3## [1] 33007 28019 37005 18003 33091 25073 17140\ndatos_matriz[, c(\"edades\", \"tlf\")]##      edades       tlf\n## [1,]     14        NA\n## [2,]     24 683839390\n## [3,]     56 621539732\n## [4,]     31 618211286\n## [5,]     20        NA\n## [6,]     87 914727164\n## [7,]     73        NA\nrow.names(datos_matriz) <- c(\"Javi\", \"Laura\", \"Patricia\", \"Carlos\",\n                             \"Juan\", \"Luis\", \"Carla\")\ndatos_matriz[\"Javi\", \"edades\"]## [1] 14"},{"path":"datos.html","id":"operaciones-por-filas-y-columnas-apply","chapter":"Capítulo 8 Datos estructurados","heading":"8.1.2 Operaciones por filas y columnas (apply)","text":"Normalmente, para explicar las operaciones con matrices en un lenguaje de programación al uso, necesitaríamos hablar de una herramienta llamada bucles. Lo mencionaremos más adelante pero los vamos necesitar de momento.Imagina que tuviésemos nuestra matriz de estaturas y pesos.¿Cómo podemos aplicar una operación para cada una de las filas o columnas de una matriz? Imagina que queremos obtener la media de cada columna: con la función apply() le indicaremos como argumentos ) la matriz; b) el sentido de la operación (MARGIN = 1 hará la opearción por filas, MARGIN = 2 hará la opearción por columnas); y c) la función aplicar.El resultado es un vector de longitud 2 (la media de las estaturas y la media del peso). La misma operación la podemos realizar por filas con MARGIN = 1 (aunque en este caso tiene mucho sentido hacer la media de variables con magnitudes distintas)Si la función aplicar requiere de argumentos extras, por ejemplo indicarle que ignore los datos ausentes con na.rm = TRUE, se lo podemos indicar al final como argumento extra.","code":"\ndatos_matriz <- cbind(estaturas, pesos)\ndatos_matriz##      estaturas pesos\n## [1,]       150    60\n## [2,]       160    70\n## [3,]       170    80\n## [4,]       180    90\n## [5,]       190   100\n# Media por columnas (MARGIN = 2)\napply(datos_matriz, MARGIN = 2, FUN = \"mean\")## estaturas     pesos \n##       170        80\n# Media por filas (MARGIN = 1)\napply(datos_matriz, MARGIN = 1, FUN = \"mean\")## [1] 105 115 125 135 145\ndatos_matriz <- cbind(edades, tlf, cp) \n\n# Media por columnas (MARGIN = 2) ignorando los ausentes\napply(datos_matriz, MARGIN = 2, FUN = \"mean\", na.rm = TRUE)##       edades          tlf           cp \n## 4.357143e+01 7.095794e+08 2.733400e+04"},{"path":"datos.html","id":"tablas-data.frames","chapter":"Capítulo 8 Datos estructurados","heading":"8.2 Tablas: data.frames","text":"Recapitulando:Hemos visto los tipos de datos que podemos tener en cada celda.Hemos aprendido recolectar datos de distintos individuos (vectores de edades, vectores de fechas, vectores de nombres).Siempre que sean del mismo tipo y longitud, hemos aprendido juntar en un mismo objeto (matrices) variables distintas (edades, estaturas, alturas, por ejemplo).Retomemos nuestra matriz de datos, en la que teníamos para cada individuo guardado las edades (edades), teléfonos (tlf) y códigos postales (cp), y probemos ver que pasa cuando seleccionamos la columna de edades y le sumamos un año todas las personas¿Qué sucede si ahora añadimos una columna con los nombres de cada persona?¿visto lo que ha sucedido?Como una matriz SOLO puede tener un tipo de dato (todo números, todo texto, todo lógicas, etc), al añadir una variable de tipo texto, R se ha visto obligado convertir los números en texto poniéndole comillas los datos que tenemos: hemos roto la integridad de los datos. De hecho, como ahora los números con caracteres, podremos sumar un año cada persona como antes. Las matrices nos permiten almacenar distintas variables SIEMPRE Y CUANDO tenganMisma longitud (todas las columnas deben tener la misma longitud).Mismo tipo de dato (o todo números o todo caracteres, pero sin mezclar).Esto es bastante limitante ya que en la vida real nuestros datos tendrán variables de todo tipo. Veamos un ejemplo real: supongamos que queremos guardar de 7 personas las variables de texto nombres y apellidos.Hasta aquí habría ningún problema ya que podemos crear una matriz de caracteres.De esas 7 personas también disponemos información de si están o casadas (representado en un valor lógico, casado) y algunos valores numéricos (edades, cp y tlf).Por último, vamos añadir cada persona una fecha de registro en el sistema (fecha_creacion, imagina que fuese la fecha de expedición del DNI).En cada variable tenemos 7 registros, uno por persona, pero ahora tenemos un popurrí de variables, de la misma longitud pero de tipos distintos:(edades, tlf, cp) son variables numéricas.(nombres, apellidos) son variables de texto.casado es una variable lógica.fecha_creacion de tipo fecha.¿Qué sucedería si intentamos mezclar todo en una matriz? Vamos unir las columnas con cbind().Dado que en una matriz solo podemos almacenar datos del mismo tipo, los números los convierte texto, las variables lógicas las convierte texto (TRUE ahora es un valor lógico, \"TRUE\" es un texto, como \"Pepito\", sin significado lógico de verdadero/falso) y las fechas las ha convertido texto (aunque las veas igual, ya son de tipo de fecha, son texto y podemos operar con ellas). El último salto en nuestro camino hacia los conjuntos de datos en R será este: vamos aprender como juntar variables de distinto tipo, sin cambiar su naturaleza, como lo haríamos en una tabla de Excel.El formato de tabla de datos en R que vamos empezar usar desde ya se llama data.frame, y es más que una colección de variables de igual longitud pero cada una puede ser de un tipo distinto. Para crear un data.frame basta con usar la función data.frame(), pasándole como argumentos (separados por comas) las variables que queremos reunir.Al igual que con las matrices, podemos crearlas indicando además el nombre de las columnas.¡TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS! Puedes visualizarlo de nuevo escribiendo su nombre en consola o con la función View()","code":"\ndatos_matriz##      edades       tlf    cp\n## [1,]     14        NA 33007\n## [2,]     24 683839390 28019\n## [3,]     56 621539732 37005\n## [4,]     31 618211286 18003\n## [5,]     20        NA 33091\n## [6,]     87 914727164 25073\n## [7,]     73        NA 17140\n# Sumamos un año a todas las personas\ndatos_matriz[, \"edades\"] + 1## [1] 15 25 57 32 21 88 74\nnombres <- c(\"Sonia\", \"Carla\", \"Pepito\", \"Carlos\", \"Lara\", \"Sandra\", \"Javi\")\ndatos_matriz_nueva <- cbind(nombres, datos_matriz)\ndatos_matriz_nueva[, \"edades\"] + 1## Error in datos_matriz_nueva[, \"edades\"] + 1: argumento no-numérico para operador binario\n# Nombres\nnombres <- c(\"Sonia\", \"Carla\", \"Pepito\", \"Carlos\", \"Lara\", \"Sandra\", \"Javi\")\n\n# Apellidos\napellidos <- c(NA, \"González\", \"Fernández\", \"Martínez\", \"Liébana\", \"García\", \"Ortiz\")\nmatriz <- cbind(nombres, apellidos)\nmatriz##      nombres  apellidos  \n## [1,] \"Sonia\"  NA         \n## [2,] \"Carla\"  \"González\" \n## [3,] \"Pepito\" \"Fernández\"\n## [4,] \"Carlos\" \"Martínez\" \n## [5,] \"Lara\"   \"Liébana\"  \n## [6,] \"Sandra\" \"García\"   \n## [7,] \"Javi\"   \"Ortiz\"\n# Código postal\ncp <- c(28019, 28001, 34005, 18410, 33007, 34500, 28017)\n\n# Edades\nedades <- c(45, 67, NA, 31, 27, 19, 50)\n\n# Teléfono\ntlf <- c(618910564, 914718475, 934567891, 620176565, NA, NA, 688921344)\n\n# Estado civil (no lo sabemos de una persona)\ncasado <- c(TRUE, FALSE, FALSE, NA, TRUE, FALSE, FALSE)\n# Fecha de creación (fecha en el que esa persona entra en el sistema)\n# lo convertimos a tipo fecha\nfecha_creacion <-\n  as.Date(c(\"2021-03-04\", \"2020-10-12\", \"1990-04-05\",\n            \"2019-09-10\", \"2017-03-21\", \"2020-07-07\",\n            \"2000-01-28\"))\n# Juntamos todo en una matriz (juntamos por columnas)\ndatos_matriz <-\n  cbind(nombres, apellidos, edades, tlf, cp, casado, fecha_creacion)\ndatos_matriz##      nombres  apellidos   edades tlf         cp      casado  fecha_creacion\n## [1,] \"Sonia\"  NA          \"45\"   \"618910564\" \"28019\" \"TRUE\"  \"18690\"       \n## [2,] \"Carla\"  \"González\"  \"67\"   \"914718475\" \"28001\" \"FALSE\" \"18547\"       \n## [3,] \"Pepito\" \"Fernández\" NA     \"934567891\" \"34005\" \"FALSE\" \"7399\"        \n## [4,] \"Carlos\" \"Martínez\"  \"31\"   \"620176565\" \"18410\" NA      \"18149\"       \n## [5,] \"Lara\"   \"Liébana\"   \"27\"   NA          \"33007\" \"TRUE\"  \"17246\"       \n## [6,] \"Sandra\" \"García\"    \"19\"   NA          \"34500\" \"FALSE\" \"18450\"       \n## [7,] \"Javi\"   \"Ortiz\"     \"50\"   \"688921344\" \"28017\" \"FALSE\" \"10984\"\n# Días entre la primera y el segundo elemento de fecha de creación\nfecha_creacion[1] - fecha_creacion[2]## Time difference of 143 days\ndatos_matriz[1, 7] - datos_matriz[2, 7]## Error in datos_matriz[1, 7] - datos_matriz[2, 7]: argumento no-numérico para operador binario\n# Creamos nuestro primer data.frame\ntabla <- data.frame(nombres, apellidos, edades, tlf, cp,\n                    casado, fecha_creacion)\ntabla##   nombres apellidos edades       tlf    cp casado fecha_creacion\n## 1   Sonia      <NA>     45 618910564 28019   TRUE     2021-03-04\n## 2   Carla  González     67 914718475 28001  FALSE     2020-10-12\n## 3  Pepito Fernández     NA 934567891 34005  FALSE     1990-04-05\n## 4  Carlos  Martínez     31 620176565 18410     NA     2019-09-10\n## 5    Lara   Liébana     27        NA 33007   TRUE     2017-03-21\n## 6  Sandra    García     19        NA 34500  FALSE     2020-07-07\n## 7    Javi     Ortiz     50 688921344 28017  FALSE     2000-01-28\nclass(tabla)## [1] \"data.frame\"\ntabla <- data.frame(\"nombre\" = nombres, \"apellido\" = apellidos, \n                    \"edad\" = edades, \"teléfono\" = tlf, \n                    \"cp\" = cp, \"casado\" = casado,\n                    \"fecha_registro\" = fecha_creacion)\ntabla##   nombre  apellido edad  teléfono    cp casado fecha_registro\n## 1  Sonia      <NA>   45 618910564 28019   TRUE     2021-03-04\n## 2  Carla  González   67 914718475 28001  FALSE     2020-10-12\n## 3 Pepito Fernández   NA 934567891 34005  FALSE     1990-04-05\n## 4 Carlos  Martínez   31 620176565 18410     NA     2019-09-10\n## 5   Lara   Liébana   27        NA 33007   TRUE     2017-03-21\n## 6 Sandra    García   19        NA 34500  FALSE     2020-07-07\n## 7   Javi     Ortiz   50 688921344 28017  FALSE     2000-01-28\nView(tabla)"},{"path":"datos.html","id":"selección-de-columnas-y-filas","chapter":"Capítulo 8 Datos estructurados","heading":"8.2.1 Selección de columnas y filas","text":"Si tenemos un data.frame ya creado y queremos añadir una columna es tan simple como usar la función data.frame() que ya hemos visto para concatenar la columna. Vamos añadir por ejemplo una nueva variable, el número de hermanos de cada individuo.Si queremos acceder una columna, fila o elemento en concreto, los data.frame tienen las mismas ventajas que una matriz, así que bastaría con usar los mismos operadores.Un data.frame solo tiene las ventajas de una matriz si que también tiene las ventajas de una «base» de datos. Por ejemplo, podemos aceder las variables por el índice de columna que ocupan pero también acceder las columnas por su nombre, poniendo el nombre de la tabla, el símbolo $ y, con el tabulador, nos aparecerá un menú de columnas elegir.\nImagen/gráfica 8.2: Menú desplegable de variables (columnas) de un data.frame.\n","code":"\n# Añadimos una nueva columna con nº de hermanos/as\nhermanos <- c(0, 0, 1, 5, 2, 3, 0)\ntabla <- data.frame(tabla, \"n_hermanos\" = hermanos)\ntabla##   nombre  apellido edad  teléfono    cp casado fecha_registro n_hermanos\n## 1  Sonia      <NA>   45 618910564 28019   TRUE     2021-03-04          0\n## 2  Carla  González   67 914718475 28001  FALSE     2020-10-12          0\n## 3 Pepito Fernández   NA 934567891 34005  FALSE     1990-04-05          1\n## 4 Carlos  Martínez   31 620176565 18410     NA     2019-09-10          5\n## 5   Lara   Liébana   27        NA 33007   TRUE     2017-03-21          2\n## 6 Sandra    García   19        NA 34500  FALSE     2020-07-07          3\n## 7   Javi     Ortiz   50 688921344 28017  FALSE     2000-01-28          0\ntabla[, 3] # Accedemos a la tercera columna## [1] 45 67 NA 31 27 19 50\ntabla[5, ] # Accedemos a la quinta fila##   nombre apellido edad teléfono    cp casado fecha_registro n_hermanos\n## 5   Lara  Liébana   27       NA 33007   TRUE     2017-03-21          2\ntabla[5, 3] # Accedemos a la tercera variable del quinto registro## [1] 27"},{"path":"datos.html","id":"primer-análisis-de-datos-arrestos-en-ee.-uu.","chapter":"Capítulo 8 Datos estructurados","heading":"8.2.2 Primer análisis de datos: arrestos en EE. UU.","text":"Además del conjunto de datos tabla que hemos construido artificialmente, vamos instalar (sino lo hemos hecho nunca en este ordenador) un paquete muy útil en R llamado {datasets}.Ahora si escribimos datasets:: y pulsamos tabulador, se nos abre un desplegable con distintos conjuntos de datos reales para ser usados: el paquete datasets nos proporciona data.frames de prueba para que podamos usarlos.Vamos jugar con el conjunto de datos datasets::USArrests, que contiene estadísticas de arrestos en 1973 (por cada 100 000 habitantes) por agresión, asesinato y violación, en cada uno de los 50 estados de Estaods Unidos.¿Cómo visualizar la cabecera de la tabla? Con la función head().¿Cómo obtener el nombre de las variables? Con la función names().El conjunto contiene los 3 tipos de delito mencionados (para cada estado), y además el porcentaje de población que vive en áreas urbanas. Esto lo podemos saber ejecutando la ayuda con ? datasets::USArrests.¿Cómo obtener el nombre de las filas (de los estados)? Con la función row.names().¿Cómo averiguar el número de registros y el número de variables? Con las funciones dim(), nrow() y ncol().¿Cómo seleccionar solo las columnas Murder y Assault para el segundo y el décimo estado? ¿Cómo cambiar el nombre de las variables? Con la función names(). ¿Cómo seleccionar y filtrar datos?En el caso de los data.frame tenemos además nuestro disposición una herramienta muy potente: la función subset(). Dicha función nos va permitir seleccionar filas y columnas la vez, tomando de entrada los siguientes argumentosx: una tabla de entrada, un data.frame de entrada.subset: la condición lógica que queramos usar para seleccionar registros (filas).select: un vector que contenga el nombre de las columnas que queremos seleccionar (lo mejor solo queremos filtrar por filas pero quizás también por columnas).Por ejemplo, vamos seleccionar solo los delitos de asesinato de aquellos estados cuyo porcentaje de población urbana sea superior al 70%.Como sucedía en otros contextos, podemos combinar condiciones lógicas, seleccionando por ejemplo aquellos estados cuyo porcentaje de población urbana sea inferior al 70% y donde las agresiones sean superiores 250 por cada 100 000 habitantes, pero luego seleccionando solo dos variables.","code":"\n# Paquetes necesarios\n# install.packages(\"datasets\") # Descomentar si nunca se ha instalado\nlibrary(datasets)\ndatasets::USArrests\nView(USArrests)\nhead(USArrests)##            Murder Assault UrbanPop Rape\n## Alabama      13.2     236       58 21.2\n## Alaska       10.0     263       48 44.5\n## Arizona       8.1     294       80 31.0\n## Arkansas      8.8     190       50 19.5\n## California    9.0     276       91 40.6\n## Colorado      7.9     204       78 38.7\nnames(USArrests)## [1] \"Murder\"   \"Assault\"  \"UrbanPop\" \"Rape\"\nrow.names(USArrests)##  [1] \"Alabama\"        \"Alaska\"         \"Arizona\"        \"Arkansas\"      \n##  [5] \"California\"     \"Colorado\"       \"Connecticut\"    \"Delaware\"      \n##  [9] \"Florida\"        \"Georgia\"        \"Hawaii\"         \"Idaho\"         \n## [13] \"Illinois\"       \"Indiana\"        \"Iowa\"           \"Kansas\"        \n## [17] \"Kentucky\"       \"Louisiana\"      \"Maine\"          \"Maryland\"      \n## [21] \"Massachusetts\"  \"Michigan\"       \"Minnesota\"      \"Mississippi\"   \n## [25] \"Missouri\"       \"Montana\"        \"Nebraska\"       \"Nevada\"        \n## [29] \"New Hampshire\"  \"New Jersey\"     \"New Mexico\"     \"New York\"      \n## [33] \"North Carolina\" \"North Dakota\"   \"Ohio\"           \"Oklahoma\"      \n## [37] \"Oregon\"         \"Pennsylvania\"   \"Rhode Island\"   \"South Carolina\"\n## [41] \"South Dakota\"   \"Tennessee\"      \"Texas\"          \"Utah\"          \n## [45] \"Vermont\"        \"Virginia\"       \"Washington\"     \"West Virginia\" \n## [49] \"Wisconsin\"      \"Wyoming\"\ndim(USArrests)## [1] 50  4\nnrow(USArrests)## [1] 50\nncol(USArrests)## [1] 4\nUSArrests[c(2, 10), c(\"Murder\", \"Assault\")]##         Murder Assault\n## Alaska    10.0     263\n## Georgia   17.4     211\nnames(USArrests) <- c(\"asesinato\", \"agresion\",\n                      \"pobl_urbana\", \"violacion\")\nsubset(USArrests, subset = pobl_urbana > 70,\n       select = c(\"asesinato\"))##               asesinato\n## Arizona             8.1\n## California          9.0\n## Colorado            7.9\n## Connecticut         3.3\n## Delaware            5.9\n## Florida            15.4\n## Hawaii              5.3\n## Illinois           10.4\n## Massachusetts       4.4\n## Michigan           12.1\n## Nevada             12.2\n## New Jersey          7.4\n## New York           11.1\n## Ohio                7.3\n## Pennsylvania        6.3\n## Rhode Island        3.4\n## Texas              12.7\n## Utah                3.2\n## Washington          4.0\nsubset(USArrests, subset = pobl_urbana < 70 & agresion > 250,\n       select = c(\"asesinato\", \"violacion\"))##                asesinato violacion\n## Alaska              10.0      44.5\n## Maryland            11.3      27.8\n## Mississippi         16.1      17.1\n## North Carolina      13.0      16.1\n## South Carolina      14.4      22.5"},{"path":"datos.html","id":"consejos-5","chapter":"Capítulo 8 Datos estructurados","heading":"8.3 Consejos","text":"CONSEJOS Acceder las funciones de los paquetesA veces puede que queramos cargar todo un paquete sino solo una función del mismo, para lo que es suficiente nombre_paquete::nombre_funcion. Recuerda que instalar un paquete es cómo comprar un libro, cargar el paquete con library() es cómo traer el libro comprado de la estantería tu mesa, y usar solo una función con nombre_paquete::nombre_funcion es cómo pedirle alguien que te arranque solo una página y te la traiga la mesa. ","code":""},{"path":"datos.html","id":"ejercicios-4","chapter":"Capítulo 8 Datos estructurados","heading":"8.4 📝 Ejercicios","text":"(haz click en las flechas para ver soluciones)Ejercicio 1: modifica el código para definir una matriz x de ceros de 3 filas y 7 columnas.Solución: Ejercicio 2: la matriz anterior, suma un 1 cada número de la matriz y divide el resultado entre 5.Solución: Ejercicio 3: tras definir la matriz x calcula su transpuesta y obtén sus dimensionesSolución: Ejercicio 4: el siguiente código define una matriz de dimensiones 4 x 3 y calcula la suma por columnas. Modifica el código para que realice la suma por filas.Solución: Ejercicio 5: con la matriz anterior definida como matrix(1:12, nrow = 4), calcula la media de todos los elementos, la media de cada fila y la media de cada columna.Solución: Ejercicio 6: el data.frame llamado airquality, del paquete {datasets}, contiene variables de la calidad del aire de la ciudad de Nueva York desde mayo hasta septiembre de 1973. Obtén el nombre de las variables.\nSolución: Ejercicio 7: obtén las dimensiones del conjunto de datos. ¿Cuántas variables hay? ¿Cuántos días se han medido?Solución: Ejercicio 8: modifica el código inferior para que nos filtre solo los datos del mes de julio.{r eval = fFALSE # Filtramos filas filtro_fila <- subset(., subset = Month < 6) filtro_fila\nSolución: Ejercicio 9: del conjunto airquality selecciona aquellos datos que sean ni de julio ni de agosto.Solución: Ejercicio 10: modifica el siguiente código para quedarte solo con las variable Ozone y Temp.Solución: Ejercicio 11: del conjunto airquality selecciona los datos de temperatura y viento de agosto.Solución: Ejercicio 12: calcula el número de filas borradas del ejercicio anterior. Tras hacer todo ello, traduce castellano el nombre de las columnas del data.frame filtrado.Solución: Ejercicio 13: añade los datos originales una columna con la fecha completa (recuerda que es del año 1973 todas las observaciones.Solución: ","code":"\n# Matriz\nx <- matrix(0, nrow = 2, ncol = 3)\nx\n# Matriz\nx <- matrix(0, nrow = 3, ncol = 7)\nx##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n## [1,]    0    0    0    0    0    0    0\n## [2,]    0    0    0    0    0    0    0\n## [3,]    0    0    0    0    0    0    0\n(x + 1) / 5##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n## [1,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n## [2,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n## [3,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n# Transpuesta\nt(x)##      [,1] [,2] [,3]\n## [1,]    0    0    0\n## [2,]    0    0    0\n## [3,]    0    0    0\n## [4,]    0    0    0\n## [5,]    0    0    0\n## [6,]    0    0    0\n## [7,]    0    0    0\n# Dimensiones transpuesta: pasa de ser 3x7 a 7x3\ndim(t(x))## [1] 7 3\nncol(t(x)) # número de columnas de la transpuesta## [1] 3\nnrow(t(x)) # número de filas de la transpuesta## [1] 7\n# Matriz\nmatriz <- matrix(1:12, nrow = 4)\n\n# Suma por columnas\napply(matriz, MARGIN = 2, FUN = \"sum\")## [1] 10 26 42\n# Matriz\nmatriz <- matrix(1:12, nrow = 4)\n\n# Suma por filas\napply(matriz, MARGIN = 1, FUN = \"sum\")## [1] 15 18 21 24\n# Matriz\nmatriz <- matrix(1:12, nrow = 4)\n\n#  media de todos\nmean(matriz)## [1] 6.5\n# Media por filas (MARGIN = 1 ya que es una operación por filas)\napply(matriz, MARGIN = 1, FUN = \"mean\")## [1] 5 6 7 8\n# Media por filas (MARGIN = 2 ya que es una operación por filas)\napply(matriz, MARGIN = 2, FUN = \"mean\")## [1]  2.5  6.5 10.5\nlibrary(datasets)\nnames(airquality)## [1] \"Ozone\"   \"Solar.R\" \"Wind\"    \"Temp\"    \"Month\"   \"Day\"\n# Dimensiones\ndim(airquality)## [1] 153   6\nnrow(airquality)## [1] 153\nncol(airquality)## [1] 6\n# Filtramos filas\nfiltro_fila <- subset(airquality, subset = Month == 7)\nfiltro_fila##    Ozone Solar.R Wind Temp Month Day\n## 62   135     269  4.1   84     7   1\n## 63    49     248  9.2   85     7   2\n## 64    32     236  9.2   81     7   3\n## 65    NA     101 10.9   84     7   4\n## 66    64     175  4.6   83     7   5\n## 67    40     314 10.9   83     7   6\n## 68    77     276  5.1   88     7   7\n## 69    97     267  6.3   92     7   8\n## 70    97     272  5.7   92     7   9\n## 71    85     175  7.4   89     7  10\n## 72    NA     139  8.6   82     7  11\n## 73    10     264 14.3   73     7  12\n## 74    27     175 14.9   81     7  13\n## 75    NA     291 14.9   91     7  14\n## 76     7      48 14.3   80     7  15\n## 77    48     260  6.9   81     7  16\n## 78    35     274 10.3   82     7  17\n## 79    61     285  6.3   84     7  18\n## 80    79     187  5.1   87     7  19\n## 81    63     220 11.5   85     7  20\n## 82    16       7  6.9   74     7  21\n## 83    NA     258  9.7   81     7  22\n## 84    NA     295 11.5   82     7  23\n## 85    80     294  8.6   86     7  24\n## 86   108     223  8.0   85     7  25\n## 87    20      81  8.6   82     7  26\n## 88    52      82 12.0   86     7  27\n## 89    82     213  7.4   88     7  28\n## 90    50     275  7.4   86     7  29\n## 91    64     253  7.4   83     7  30\n## 92    59     254  9.2   81     7  31\n# Filtramos filas\nfiltro_fila <-\n  subset(airquality, subset = !(Month %in% c(7, 8)))\nfiltro_fila##     Ozone Solar.R Wind Temp Month Day\n## 1      41     190  7.4   67     5   1\n## 2      36     118  8.0   72     5   2\n## 3      12     149 12.6   74     5   3\n## 4      18     313 11.5   62     5   4\n## 5      NA      NA 14.3   56     5   5\n## 6      28      NA 14.9   66     5   6\n## 7      23     299  8.6   65     5   7\n## 8      19      99 13.8   59     5   8\n## 9       8      19 20.1   61     5   9\n## 10     NA     194  8.6   69     5  10\n## 11      7      NA  6.9   74     5  11\n## 12     16     256  9.7   69     5  12\n## 13     11     290  9.2   66     5  13\n## 14     14     274 10.9   68     5  14\n## 15     18      65 13.2   58     5  15\n## 16     14     334 11.5   64     5  16\n## 17     34     307 12.0   66     5  17\n## 18      6      78 18.4   57     5  18\n## 19     30     322 11.5   68     5  19\n## 20     11      44  9.7   62     5  20\n## 21      1       8  9.7   59     5  21\n## 22     11     320 16.6   73     5  22\n## 23      4      25  9.7   61     5  23\n## 24     32      92 12.0   61     5  24\n## 25     NA      66 16.6   57     5  25\n## 26     NA     266 14.9   58     5  26\n## 27     NA      NA  8.0   57     5  27\n## 28     23      13 12.0   67     5  28\n## 29     45     252 14.9   81     5  29\n## 30    115     223  5.7   79     5  30\n## 31     37     279  7.4   76     5  31\n## 32     NA     286  8.6   78     6   1\n## 33     NA     287  9.7   74     6   2\n## 34     NA     242 16.1   67     6   3\n## 35     NA     186  9.2   84     6   4\n## 36     NA     220  8.6   85     6   5\n## 37     NA     264 14.3   79     6   6\n## 38     29     127  9.7   82     6   7\n## 39     NA     273  6.9   87     6   8\n## 40     71     291 13.8   90     6   9\n## 41     39     323 11.5   87     6  10\n## 42     NA     259 10.9   93     6  11\n## 43     NA     250  9.2   92     6  12\n## 44     23     148  8.0   82     6  13\n## 45     NA     332 13.8   80     6  14\n## 46     NA     322 11.5   79     6  15\n## 47     21     191 14.9   77     6  16\n## 48     37     284 20.7   72     6  17\n## 49     20      37  9.2   65     6  18\n## 50     12     120 11.5   73     6  19\n## 51     13     137 10.3   76     6  20\n## 52     NA     150  6.3   77     6  21\n## 53     NA      59  1.7   76     6  22\n## 54     NA      91  4.6   76     6  23\n## 55     NA     250  6.3   76     6  24\n## 56     NA     135  8.0   75     6  25\n## 57     NA     127  8.0   78     6  26\n## 58     NA      47 10.3   73     6  27\n## 59     NA      98 11.5   80     6  28\n## 60     NA      31 14.9   77     6  29\n## 61     NA     138  8.0   83     6  30\n## 124    96     167  6.9   91     9   1\n## 125    78     197  5.1   92     9   2\n## 126    73     183  2.8   93     9   3\n## 127    91     189  4.6   93     9   4\n## 128    47      95  7.4   87     9   5\n## 129    32      92 15.5   84     9   6\n## 130    20     252 10.9   80     9   7\n## 131    23     220 10.3   78     9   8\n## 132    21     230 10.9   75     9   9\n## 133    24     259  9.7   73     9  10\n## 134    44     236 14.9   81     9  11\n## 135    21     259 15.5   76     9  12\n## 136    28     238  6.3   77     9  13\n## 137     9      24 10.9   71     9  14\n## 138    13     112 11.5   71     9  15\n## 139    46     237  6.9   78     9  16\n## 140    18     224 13.8   67     9  17\n## 141    13      27 10.3   76     9  18\n## 142    24     238 10.3   68     9  19\n## 143    16     201  8.0   82     9  20\n## 144    13     238 12.6   64     9  21\n## 145    23      14  9.2   71     9  22\n## 146    36     139 10.3   81     9  23\n## 147     7      49 10.3   69     9  24\n## 148    14      20 16.6   63     9  25\n## 149    30     193  6.9   70     9  26\n## 150    NA     145 13.2   77     9  27\n## 151    14     191 14.3   75     9  28\n## 152    18     131  8.0   76     9  29\n## 153    20     223 11.5   68     9  30\nfiltro_col <- subset(.,  select = c(\"Ozone\"))\nfiltro_col\n# Filtramos columnas\nfiltro_col <- subset(airquality,  select = c(\"Ozone\", \"Temp\"))\nfiltro_col##     Ozone Temp\n## 1      41   67\n## 2      36   72\n## 3      12   74\n## 4      18   62\n## 5      NA   56\n## 6      28   66\n## 7      23   65\n## 8      19   59\n## 9       8   61\n## 10     NA   69\n## 11      7   74\n## 12     16   69\n## 13     11   66\n## 14     14   68\n## 15     18   58\n## 16     14   64\n## 17     34   66\n## 18      6   57\n## 19     30   68\n## 20     11   62\n## 21      1   59\n## 22     11   73\n## 23      4   61\n## 24     32   61\n## 25     NA   57\n## 26     NA   58\n## 27     NA   57\n## 28     23   67\n## 29     45   81\n## 30    115   79\n## 31     37   76\n## 32     NA   78\n## 33     NA   74\n## 34     NA   67\n## 35     NA   84\n## 36     NA   85\n## 37     NA   79\n## 38     29   82\n## 39     NA   87\n## 40     71   90\n## 41     39   87\n## 42     NA   93\n## 43     NA   92\n## 44     23   82\n## 45     NA   80\n## 46     NA   79\n## 47     21   77\n## 48     37   72\n## 49     20   65\n## 50     12   73\n## 51     13   76\n## 52     NA   77\n## 53     NA   76\n## 54     NA   76\n## 55     NA   76\n## 56     NA   75\n## 57     NA   78\n## 58     NA   73\n## 59     NA   80\n## 60     NA   77\n## 61     NA   83\n## 62    135   84\n## 63     49   85\n## 64     32   81\n## 65     NA   84\n## 66     64   83\n## 67     40   83\n## 68     77   88\n## 69     97   92\n## 70     97   92\n## 71     85   89\n## 72     NA   82\n## 73     10   73\n## 74     27   81\n## 75     NA   91\n## 76      7   80\n## 77     48   81\n## 78     35   82\n## 79     61   84\n## 80     79   87\n## 81     63   85\n## 82     16   74\n## 83     NA   81\n## 84     NA   82\n## 85     80   86\n## 86    108   85\n## 87     20   82\n## 88     52   86\n## 89     82   88\n## 90     50   86\n## 91     64   83\n## 92     59   81\n## 93     39   81\n## 94      9   81\n## 95     16   82\n## 96     78   86\n## 97     35   85\n## 98     66   87\n## 99    122   89\n## 100    89   90\n## 101   110   90\n## 102    NA   92\n## 103    NA   86\n## 104    44   86\n## 105    28   82\n## 106    65   80\n## 107    NA   79\n## 108    22   77\n## 109    59   79\n## 110    23   76\n## 111    31   78\n## 112    44   78\n## 113    21   77\n## 114     9   72\n## 115    NA   75\n## 116    45   79\n## 117   168   81\n## 118    73   86\n## 119    NA   88\n## 120    76   97\n## 121   118   94\n## 122    84   96\n## 123    85   94\n## 124    96   91\n## 125    78   92\n## 126    73   93\n## 127    91   93\n## 128    47   87\n## 129    32   84\n## 130    20   80\n## 131    23   78\n## 132    21   75\n## 133    24   73\n## 134    44   81\n## 135    21   76\n## 136    28   77\n## 137     9   71\n## 138    13   71\n## 139    46   78\n## 140    18   67\n## 141    13   76\n## 142    24   68\n## 143    16   82\n## 144    13   64\n## 145    23   71\n## 146    36   81\n## 147     7   69\n## 148    14   63\n## 149    30   70\n## 150    NA   77\n## 151    14   75\n## 152    18   76\n## 153    20   68\n# Todo de una vez\nfiltro <- subset(airquality, subset = Month == 8,\n                 select = c(\"Temp\", \"Wind\"))\nfiltro##     Temp Wind\n## 93    81  6.9\n## 94    81 13.8\n## 95    82  7.4\n## 96    86  6.9\n## 97    85  7.4\n## 98    87  4.6\n## 99    89  4.0\n## 100   90 10.3\n## 101   90  8.0\n## 102   92  8.6\n## 103   86 11.5\n## 104   86 11.5\n## 105   82 11.5\n## 106   80  9.7\n## 107   79 11.5\n## 108   77 10.3\n## 109   79  6.3\n## 110   76  7.4\n## 111   78 10.9\n## 112   78 10.3\n## 113   77 15.5\n## 114   72 14.3\n## 115   75 12.6\n## 116   79  9.7\n## 117   81  3.4\n## 118   86  8.0\n## 119   88  5.7\n## 120   97  9.7\n## 121   94  2.3\n## 122   96  6.3\n## 123   94  6.3\n# Filas borradas\nnrow(airquality) - nrow(filtro)## [1] 122\n# Cambiamos nombres a castellano del conjunto filtrado\nnames(filtro) <- c(\"temperatura\", \"viento\")\n# Construimos las fechas (pegamos año-mes-día con \"-\")\nfechas <- \n  as.Date(paste(\"1973\", airquality$Month, airquality$Day,\n                sep = \"-\"))\n\n# Añadimos\ndata.frame(airquality, fechas)##     Ozone Solar.R Wind Temp Month Day     fechas\n## 1      41     190  7.4   67     5   1 1973-05-01\n## 2      36     118  8.0   72     5   2 1973-05-02\n## 3      12     149 12.6   74     5   3 1973-05-03\n## 4      18     313 11.5   62     5   4 1973-05-04\n## 5      NA      NA 14.3   56     5   5 1973-05-05\n## 6      28      NA 14.9   66     5   6 1973-05-06\n## 7      23     299  8.6   65     5   7 1973-05-07\n## 8      19      99 13.8   59     5   8 1973-05-08\n## 9       8      19 20.1   61     5   9 1973-05-09\n## 10     NA     194  8.6   69     5  10 1973-05-10\n## 11      7      NA  6.9   74     5  11 1973-05-11\n## 12     16     256  9.7   69     5  12 1973-05-12\n## 13     11     290  9.2   66     5  13 1973-05-13\n## 14     14     274 10.9   68     5  14 1973-05-14\n## 15     18      65 13.2   58     5  15 1973-05-15\n## 16     14     334 11.5   64     5  16 1973-05-16\n## 17     34     307 12.0   66     5  17 1973-05-17\n## 18      6      78 18.4   57     5  18 1973-05-18\n## 19     30     322 11.5   68     5  19 1973-05-19\n## 20     11      44  9.7   62     5  20 1973-05-20\n## 21      1       8  9.7   59     5  21 1973-05-21\n## 22     11     320 16.6   73     5  22 1973-05-22\n## 23      4      25  9.7   61     5  23 1973-05-23\n## 24     32      92 12.0   61     5  24 1973-05-24\n## 25     NA      66 16.6   57     5  25 1973-05-25\n## 26     NA     266 14.9   58     5  26 1973-05-26\n## 27     NA      NA  8.0   57     5  27 1973-05-27\n## 28     23      13 12.0   67     5  28 1973-05-28\n## 29     45     252 14.9   81     5  29 1973-05-29\n## 30    115     223  5.7   79     5  30 1973-05-30\n## 31     37     279  7.4   76     5  31 1973-05-31\n## 32     NA     286  8.6   78     6   1 1973-06-01\n## 33     NA     287  9.7   74     6   2 1973-06-02\n## 34     NA     242 16.1   67     6   3 1973-06-03\n## 35     NA     186  9.2   84     6   4 1973-06-04\n## 36     NA     220  8.6   85     6   5 1973-06-05\n## 37     NA     264 14.3   79     6   6 1973-06-06\n## 38     29     127  9.7   82     6   7 1973-06-07\n## 39     NA     273  6.9   87     6   8 1973-06-08\n## 40     71     291 13.8   90     6   9 1973-06-09\n## 41     39     323 11.5   87     6  10 1973-06-10\n## 42     NA     259 10.9   93     6  11 1973-06-11\n## 43     NA     250  9.2   92     6  12 1973-06-12\n## 44     23     148  8.0   82     6  13 1973-06-13\n## 45     NA     332 13.8   80     6  14 1973-06-14\n## 46     NA     322 11.5   79     6  15 1973-06-15\n## 47     21     191 14.9   77     6  16 1973-06-16\n## 48     37     284 20.7   72     6  17 1973-06-17\n## 49     20      37  9.2   65     6  18 1973-06-18\n## 50     12     120 11.5   73     6  19 1973-06-19\n## 51     13     137 10.3   76     6  20 1973-06-20\n## 52     NA     150  6.3   77     6  21 1973-06-21\n## 53     NA      59  1.7   76     6  22 1973-06-22\n## 54     NA      91  4.6   76     6  23 1973-06-23\n## 55     NA     250  6.3   76     6  24 1973-06-24\n## 56     NA     135  8.0   75     6  25 1973-06-25\n## 57     NA     127  8.0   78     6  26 1973-06-26\n## 58     NA      47 10.3   73     6  27 1973-06-27\n## 59     NA      98 11.5   80     6  28 1973-06-28\n## 60     NA      31 14.9   77     6  29 1973-06-29\n## 61     NA     138  8.0   83     6  30 1973-06-30\n## 62    135     269  4.1   84     7   1 1973-07-01\n## 63     49     248  9.2   85     7   2 1973-07-02\n## 64     32     236  9.2   81     7   3 1973-07-03\n## 65     NA     101 10.9   84     7   4 1973-07-04\n## 66     64     175  4.6   83     7   5 1973-07-05\n## 67     40     314 10.9   83     7   6 1973-07-06\n## 68     77     276  5.1   88     7   7 1973-07-07\n## 69     97     267  6.3   92     7   8 1973-07-08\n## 70     97     272  5.7   92     7   9 1973-07-09\n## 71     85     175  7.4   89     7  10 1973-07-10\n## 72     NA     139  8.6   82     7  11 1973-07-11\n## 73     10     264 14.3   73     7  12 1973-07-12\n## 74     27     175 14.9   81     7  13 1973-07-13\n## 75     NA     291 14.9   91     7  14 1973-07-14\n## 76      7      48 14.3   80     7  15 1973-07-15\n## 77     48     260  6.9   81     7  16 1973-07-16\n## 78     35     274 10.3   82     7  17 1973-07-17\n## 79     61     285  6.3   84     7  18 1973-07-18\n## 80     79     187  5.1   87     7  19 1973-07-19\n## 81     63     220 11.5   85     7  20 1973-07-20\n## 82     16       7  6.9   74     7  21 1973-07-21\n## 83     NA     258  9.7   81     7  22 1973-07-22\n## 84     NA     295 11.5   82     7  23 1973-07-23\n## 85     80     294  8.6   86     7  24 1973-07-24\n## 86    108     223  8.0   85     7  25 1973-07-25\n## 87     20      81  8.6   82     7  26 1973-07-26\n## 88     52      82 12.0   86     7  27 1973-07-27\n## 89     82     213  7.4   88     7  28 1973-07-28\n## 90     50     275  7.4   86     7  29 1973-07-29\n## 91     64     253  7.4   83     7  30 1973-07-30\n## 92     59     254  9.2   81     7  31 1973-07-31\n## 93     39      83  6.9   81     8   1 1973-08-01\n## 94      9      24 13.8   81     8   2 1973-08-02\n## 95     16      77  7.4   82     8   3 1973-08-03\n## 96     78      NA  6.9   86     8   4 1973-08-04\n## 97     35      NA  7.4   85     8   5 1973-08-05\n## 98     66      NA  4.6   87     8   6 1973-08-06\n## 99    122     255  4.0   89     8   7 1973-08-07\n## 100    89     229 10.3   90     8   8 1973-08-08\n## 101   110     207  8.0   90     8   9 1973-08-09\n## 102    NA     222  8.6   92     8  10 1973-08-10\n## 103    NA     137 11.5   86     8  11 1973-08-11\n## 104    44     192 11.5   86     8  12 1973-08-12\n## 105    28     273 11.5   82     8  13 1973-08-13\n## 106    65     157  9.7   80     8  14 1973-08-14\n## 107    NA      64 11.5   79     8  15 1973-08-15\n## 108    22      71 10.3   77     8  16 1973-08-16\n## 109    59      51  6.3   79     8  17 1973-08-17\n## 110    23     115  7.4   76     8  18 1973-08-18\n## 111    31     244 10.9   78     8  19 1973-08-19\n## 112    44     190 10.3   78     8  20 1973-08-20\n## 113    21     259 15.5   77     8  21 1973-08-21\n## 114     9      36 14.3   72     8  22 1973-08-22\n## 115    NA     255 12.6   75     8  23 1973-08-23\n## 116    45     212  9.7   79     8  24 1973-08-24\n## 117   168     238  3.4   81     8  25 1973-08-25\n## 118    73     215  8.0   86     8  26 1973-08-26\n## 119    NA     153  5.7   88     8  27 1973-08-27\n## 120    76     203  9.7   97     8  28 1973-08-28\n## 121   118     225  2.3   94     8  29 1973-08-29\n## 122    84     237  6.3   96     8  30 1973-08-30\n## 123    85     188  6.3   94     8  31 1973-08-31\n## 124    96     167  6.9   91     9   1 1973-09-01\n## 125    78     197  5.1   92     9   2 1973-09-02\n## 126    73     183  2.8   93     9   3 1973-09-03\n## 127    91     189  4.6   93     9   4 1973-09-04\n## 128    47      95  7.4   87     9   5 1973-09-05\n## 129    32      92 15.5   84     9   6 1973-09-06\n## 130    20     252 10.9   80     9   7 1973-09-07\n## 131    23     220 10.3   78     9   8 1973-09-08\n## 132    21     230 10.9   75     9   9 1973-09-09\n## 133    24     259  9.7   73     9  10 1973-09-10\n## 134    44     236 14.9   81     9  11 1973-09-11\n## 135    21     259 15.5   76     9  12 1973-09-12\n## 136    28     238  6.3   77     9  13 1973-09-13\n## 137     9      24 10.9   71     9  14 1973-09-14\n## 138    13     112 11.5   71     9  15 1973-09-15\n## 139    46     237  6.9   78     9  16 1973-09-16\n## 140    18     224 13.8   67     9  17 1973-09-17\n## 141    13      27 10.3   76     9  18 1973-09-18\n## 142    24     238 10.3   68     9  19 1973-09-19\n## 143    16     201  8.0   82     9  20 1973-09-20\n## 144    13     238 12.6   64     9  21 1973-09-21\n## 145    23      14  9.2   71     9  22 1973-09-22\n## 146    36     139 10.3   81     9  23 1973-09-23\n## 147     7      49 10.3   69     9  24 1973-09-24\n## 148    14      20 16.6   63     9  25 1973-09-25\n## 149    30     193  6.9   70     9  26 1973-09-26\n## 150    NA     145 13.2   77     9  27 1973-09-27\n## 151    14     191 14.3   75     9  28 1973-09-28\n## 152    18     131  8.0   76     9  29 1973-09-29\n## 153    20     223 11.5   68     9  30 1973-09-30"},{"path":"repaso-1.html","id":"repaso-1","chapter":"Capítulo 9 Repaso: empezando a trastear con datos","heading":"Capítulo 9 Repaso: empezando a trastear con datos","text":"Scripts usados:script06.R: repaso de la iniciación los datos. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script06.RVamos hacer un alto en el camino y hacer un repaso de lo que hemos aprendido con un conjunto nuevo, el conjunto de datos swiss del paquete {datasets}. Intenta contestar las preguntas planteadas antes de que sean resueltas. Si te resulta aún un poco complicado, pasa nada, la solución es seguir trasteando hasta que rompas algo (es broma). 1. ¿Cómo cargarías los datos sabiendo su nombre y el paquete en el que está? Nuestros datos se llaman swiss y son del paquete {datasets}, así que lo primero que debemos hacer es instalar el paquete (en caso de tenerlo, con install.packages(\"datasets\")), después llamar ese paquete (tenemos el libro comprado y lo sacamos de la estantería) con library(datasets) y escribir el nombre del conjunto de datos para mostrarlo.Podríamos pedirle el libro entero sino solo esa página, de ese conjunto de datos, usando datasets::swiss (sin hacer uso del library() previo). 2. Tenemos los datos guardados en swiss, ¿qué tipo de objeto es? Al mostrarlos ya lo habrás intuido pero nuestro conjunto swiss es de tipo data.frame. Para comprobarlo podemos usar la función class().Si somos un poco observadores/vemos que todas las variables parecen numéricas así que…podríamos tener una matriz de números. ¿Cómo convertimos los datos una matriz? 3. ¿Cómo podríamos tener una descripción detallada de los datos? La forma más inmediata es hacerlo es con la función ? swiss, que nos permite ver la documentación en el panel de ayuda.También podemos ver el nombre de las columnas con names() y el nombre de las filas con row.names()Los datos representan algunos indicadores de fertilidad y socioeconómicos (estandarizados, entre 0 y 100) de las 47 provincias francoparlantes de Suiza, con datos del año 1888. Como podemos leer en la ayuda, en la web https://opr.princeton.edu/archive/pefp/switz.aspx tenemos los datos de 182 distritos para dicho año. 4. ¿Cómo podríamos «ver» los datos? ¿Cuántas provincias hay incluidas? ¿Cuántas variables han sido medidas en cada una de ellas? Podemos hacerlo de varias maneras, y una de ellas es pedirle una cabecera de la tabla (las primeras filas) con head().También podemos ver una versión «excelizada» de los datos con `View()Para ver las dimensiones de los datos podemos recurrir dim() (nos dará un vector de longitud 2 con el número de filas y columnas) o nrow() y ncol() 5. ¿Cómo podríamos definir una nueva variable de tipo texto con los nombres de filas que obtenemos de row.names()? La función row.names() nos devuelve los nombres de las filas, que vamos guardar en una variable (por ejemplo, en nombres).Esa variable la vamos añadir como primera columna, haciendo uso de data.frame(), concatenando dicha columna las que ya tenemos.Podemos incluso eliminar el nombre de las filas (ya las tenemos guardadas como variables). 6. ¿Cómo podemos decidir cual de las provincias tiene un indicador estandarizado de la fertilidad superior 80? La opción más inmediata es obtener la variable Fertility con $ y ejecutar la condición lógica: si es mayor que 80 devolverá TRUE; en caso contrario, FALSE.Para saber las filas exactas que cumplen dicha condición (sus índices) podemos usar la función (). 7. ¿Cómo podemos filtrar la tabla y seleccionar solo dichas provincias, las que tienen fertilidad superior 80? Podemos hacerlo principalmente de dos maneras. La primera es tratar los datos como una matriz con el operador [], dejando las columnas libres y pasándole como índices en las filas precisamente la condición lógica: seleccionará las TRUE y seleccionará las FALSE.La otra manera, más corta y concisa, es usando subset(), que además nos permitiría seleccionar columnas si quisiéramos filtrarlas. 8. ¿Cómo podemos añadir una nueva variable lógica que nos guarde TRUE si la fertilidad es superior 80 y FALSE en caso contrario? Vamos guardar el resultado de la condición lógica en una variable y vamos incluirla en el data.frame igual que hemos incluido los nombres.Podemos realizar el filtro anterior haciendo uso de esa nueva variable. 9. ¿Cómo podemos definir una nueva variable de tipo fecha, que empiece el 1 de enero de 1888, acabe el 31 de diciembre de 1888, y las fechas estén equiespaciadas en el tiempo? Si recuerdas las fechas internamente son guardadas como números así que podemos definir una secuencia de fechas, desde una fecha inicial hasta una fecha final, con la misma longitud que filas tenemos en los datos.Podemos comprobar que son fechas usando class() pero también intentando sumar días las fechas (sin que aparezca un error).Para añadir la tabla dicha variable basta con hacer de nuevo data.frame() concatenando la tabla que teníamos con la nueva columna.","code":"\nlibrary(datasets)\nswiss##              Fertility Agriculture Examination Education Catholic\n## Courtelary        80.2        17.0          15        12     9.96\n## Delemont          83.1        45.1           6         9    84.84\n## Franches-Mnt      92.5        39.7           5         5    93.40\n## Moutier           85.8        36.5          12         7    33.77\n## Neuveville        76.9        43.5          17        15     5.16\n## Porrentruy        76.1        35.3           9         7    90.57\n## Broye             83.8        70.2          16         7    92.85\n## Glane             92.4        67.8          14         8    97.16\n## Gruyere           82.4        53.3          12         7    97.67\n## Sarine            82.9        45.2          16        13    91.38\n## Veveyse           87.1        64.5          14         6    98.61\n## Aigle             64.1        62.0          21        12     8.52\n## Aubonne           66.9        67.5          14         7     2.27\n## Avenches          68.9        60.7          19        12     4.43\n## Cossonay          61.7        69.3          22         5     2.82\n## Echallens         68.3        72.6          18         2    24.20\n## Grandson          71.7        34.0          17         8     3.30\n## Lausanne          55.7        19.4          26        28    12.11\n## La Vallee         54.3        15.2          31        20     2.15\n## Lavaux            65.1        73.0          19         9     2.84\n## Morges            65.5        59.8          22        10     5.23\n## Moudon            65.0        55.1          14         3     4.52\n## Nyone             56.6        50.9          22        12    15.14\n## Orbe              57.4        54.1          20         6     4.20\n## Oron              72.5        71.2          12         1     2.40\n## Payerne           74.2        58.1          14         8     5.23\n## Paysd'enhaut      72.0        63.5           6         3     2.56\n## Rolle             60.5        60.8          16        10     7.72\n## Vevey             58.3        26.8          25        19    18.46\n## Yverdon           65.4        49.5          15         8     6.10\n## Conthey           75.5        85.9           3         2    99.71\n## Entremont         69.3        84.9           7         6    99.68\n## Herens            77.3        89.7           5         2   100.00\n## Martigwy          70.5        78.2          12         6    98.96\n## Monthey           79.4        64.9           7         3    98.22\n## St Maurice        65.0        75.9           9         9    99.06\n## Sierre            92.2        84.6           3         3    99.46\n## Sion              79.3        63.1          13        13    96.83\n## Boudry            70.4        38.4          26        12     5.62\n## La Chauxdfnd      65.7         7.7          29        11    13.79\n## Le Locle          72.7        16.7          22        13    11.22\n## Neuchatel         64.4        17.6          35        32    16.92\n## Val de Ruz        77.6        37.6          15         7     4.97\n## ValdeTravers      67.6        18.7          25         7     8.65\n## V. De Geneve      35.0         1.2          37        53    42.34\n## Rive Droite       44.7        46.6          16        29    50.43\n## Rive Gauche       42.8        27.7          22        29    58.33\n##              Infant.Mortality\n## Courtelary               22.2\n## Delemont                 22.2\n## Franches-Mnt             20.2\n## Moutier                  20.3\n## Neuveville               20.6\n## Porrentruy               26.6\n## Broye                    23.6\n## Glane                    24.9\n## Gruyere                  21.0\n## Sarine                   24.4\n## Veveyse                  24.5\n## Aigle                    16.5\n## Aubonne                  19.1\n## Avenches                 22.7\n## Cossonay                 18.7\n## Echallens                21.2\n## Grandson                 20.0\n## Lausanne                 20.2\n## La Vallee                10.8\n## Lavaux                   20.0\n## Morges                   18.0\n## Moudon                   22.4\n## Nyone                    16.7\n## Orbe                     15.3\n## Oron                     21.0\n## Payerne                  23.8\n## Paysd'enhaut             18.0\n## Rolle                    16.3\n## Vevey                    20.9\n## Yverdon                  22.5\n## Conthey                  15.1\n## Entremont                19.8\n## Herens                   18.3\n## Martigwy                 19.4\n## Monthey                  20.2\n## St Maurice               17.8\n## Sierre                   16.3\n## Sion                     18.1\n## Boudry                   20.3\n## La Chauxdfnd             20.5\n## Le Locle                 18.9\n## Neuchatel                23.0\n## Val de Ruz               20.0\n## ValdeTravers             19.5\n## V. De Geneve             18.0\n## Rive Droite              18.2\n## Rive Gauche              19.3\ndatasets::swiss\nclass(swiss)## [1] \"data.frame\"\nas.matrix(swiss)##              Fertility Agriculture Examination Education Catholic\n## Courtelary        80.2        17.0          15        12     9.96\n## Delemont          83.1        45.1           6         9    84.84\n## Franches-Mnt      92.5        39.7           5         5    93.40\n## Moutier           85.8        36.5          12         7    33.77\n## Neuveville        76.9        43.5          17        15     5.16\n## Porrentruy        76.1        35.3           9         7    90.57\n## Broye             83.8        70.2          16         7    92.85\n## Glane             92.4        67.8          14         8    97.16\n## Gruyere           82.4        53.3          12         7    97.67\n## Sarine            82.9        45.2          16        13    91.38\n## Veveyse           87.1        64.5          14         6    98.61\n## Aigle             64.1        62.0          21        12     8.52\n## Aubonne           66.9        67.5          14         7     2.27\n## Avenches          68.9        60.7          19        12     4.43\n## Cossonay          61.7        69.3          22         5     2.82\n## Echallens         68.3        72.6          18         2    24.20\n## Grandson          71.7        34.0          17         8     3.30\n## Lausanne          55.7        19.4          26        28    12.11\n## La Vallee         54.3        15.2          31        20     2.15\n## Lavaux            65.1        73.0          19         9     2.84\n## Morges            65.5        59.8          22        10     5.23\n## Moudon            65.0        55.1          14         3     4.52\n## Nyone             56.6        50.9          22        12    15.14\n## Orbe              57.4        54.1          20         6     4.20\n## Oron              72.5        71.2          12         1     2.40\n## Payerne           74.2        58.1          14         8     5.23\n## Paysd'enhaut      72.0        63.5           6         3     2.56\n## Rolle             60.5        60.8          16        10     7.72\n## Vevey             58.3        26.8          25        19    18.46\n## Yverdon           65.4        49.5          15         8     6.10\n## Conthey           75.5        85.9           3         2    99.71\n## Entremont         69.3        84.9           7         6    99.68\n## Herens            77.3        89.7           5         2   100.00\n## Martigwy          70.5        78.2          12         6    98.96\n## Monthey           79.4        64.9           7         3    98.22\n## St Maurice        65.0        75.9           9         9    99.06\n## Sierre            92.2        84.6           3         3    99.46\n## Sion              79.3        63.1          13        13    96.83\n## Boudry            70.4        38.4          26        12     5.62\n## La Chauxdfnd      65.7         7.7          29        11    13.79\n## Le Locle          72.7        16.7          22        13    11.22\n## Neuchatel         64.4        17.6          35        32    16.92\n## Val de Ruz        77.6        37.6          15         7     4.97\n## ValdeTravers      67.6        18.7          25         7     8.65\n## V. De Geneve      35.0         1.2          37        53    42.34\n## Rive Droite       44.7        46.6          16        29    50.43\n## Rive Gauche       42.8        27.7          22        29    58.33\n##              Infant.Mortality\n## Courtelary               22.2\n## Delemont                 22.2\n## Franches-Mnt             20.2\n## Moutier                  20.3\n## Neuveville               20.6\n## Porrentruy               26.6\n## Broye                    23.6\n## Glane                    24.9\n## Gruyere                  21.0\n## Sarine                   24.4\n## Veveyse                  24.5\n## Aigle                    16.5\n## Aubonne                  19.1\n## Avenches                 22.7\n## Cossonay                 18.7\n## Echallens                21.2\n## Grandson                 20.0\n## Lausanne                 20.2\n## La Vallee                10.8\n## Lavaux                   20.0\n## Morges                   18.0\n## Moudon                   22.4\n## Nyone                    16.7\n## Orbe                     15.3\n## Oron                     21.0\n## Payerne                  23.8\n## Paysd'enhaut             18.0\n## Rolle                    16.3\n## Vevey                    20.9\n## Yverdon                  22.5\n## Conthey                  15.1\n## Entremont                19.8\n## Herens                   18.3\n## Martigwy                 19.4\n## Monthey                  20.2\n## St Maurice               17.8\n## Sierre                   16.3\n## Sion                     18.1\n## Boudry                   20.3\n## La Chauxdfnd             20.5\n## Le Locle                 18.9\n## Neuchatel                23.0\n## Val de Ruz               20.0\n## ValdeTravers             19.5\n## V. De Geneve             18.0\n## Rive Droite              18.2\n## Rive Gauche              19.3\nclass(as.matrix(swiss))## [1] \"matrix\"\n? swiss\nnames(swiss)## [1] \"Fertility\"        \"Agriculture\"      \"Examination\"      \"Education\"       \n## [5] \"Catholic\"         \"Infant.Mortality\"\nrow.names(swiss)##  [1] \"Courtelary\"   \"Delemont\"     \"Franches-Mnt\" \"Moutier\"      \"Neuveville\"  \n##  [6] \"Porrentruy\"   \"Broye\"        \"Glane\"        \"Gruyere\"      \"Sarine\"      \n## [11] \"Veveyse\"      \"Aigle\"        \"Aubonne\"      \"Avenches\"     \"Cossonay\"    \n## [16] \"Echallens\"    \"Grandson\"     \"Lausanne\"     \"La Vallee\"    \"Lavaux\"      \n## [21] \"Morges\"       \"Moudon\"       \"Nyone\"        \"Orbe\"         \"Oron\"        \n## [26] \"Payerne\"      \"Paysd'enhaut\" \"Rolle\"        \"Vevey\"        \"Yverdon\"     \n## [31] \"Conthey\"      \"Entremont\"    \"Herens\"       \"Martigwy\"     \"Monthey\"     \n## [36] \"St Maurice\"   \"Sierre\"       \"Sion\"         \"Boudry\"       \"La Chauxdfnd\"\n## [41] \"Le Locle\"     \"Neuchatel\"    \"Val de Ruz\"   \"ValdeTravers\" \"V. De Geneve\"\n## [46] \"Rive Droite\"  \"Rive Gauche\"\nhead(swiss)##              Fertility Agriculture Examination Education Catholic\n## Courtelary        80.2        17.0          15        12     9.96\n## Delemont          83.1        45.1           6         9    84.84\n## Franches-Mnt      92.5        39.7           5         5    93.40\n## Moutier           85.8        36.5          12         7    33.77\n## Neuveville        76.9        43.5          17        15     5.16\n## Porrentruy        76.1        35.3           9         7    90.57\n##              Infant.Mortality\n## Courtelary               22.2\n## Delemont                 22.2\n## Franches-Mnt             20.2\n## Moutier                  20.3\n## Neuveville               20.6\n## Porrentruy               26.6\nView(swiss)\ndim(swiss)## [1] 47  6\nnrow(swiss)## [1] 47\nncol(swiss)## [1] 6\nnombres <- row.names(swiss)\nnombres##  [1] \"Courtelary\"   \"Delemont\"     \"Franches-Mnt\" \"Moutier\"      \"Neuveville\"  \n##  [6] \"Porrentruy\"   \"Broye\"        \"Glane\"        \"Gruyere\"      \"Sarine\"      \n## [11] \"Veveyse\"      \"Aigle\"        \"Aubonne\"      \"Avenches\"     \"Cossonay\"    \n## [16] \"Echallens\"    \"Grandson\"     \"Lausanne\"     \"La Vallee\"    \"Lavaux\"      \n## [21] \"Morges\"       \"Moudon\"       \"Nyone\"        \"Orbe\"         \"Oron\"        \n## [26] \"Payerne\"      \"Paysd'enhaut\" \"Rolle\"        \"Vevey\"        \"Yverdon\"     \n## [31] \"Conthey\"      \"Entremont\"    \"Herens\"       \"Martigwy\"     \"Monthey\"     \n## [36] \"St Maurice\"   \"Sierre\"       \"Sion\"         \"Boudry\"       \"La Chauxdfnd\"\n## [41] \"Le Locle\"     \"Neuchatel\"    \"Val de Ruz\"   \"ValdeTravers\" \"V. De Geneve\"\n## [46] \"Rive Droite\"  \"Rive Gauche\"\ntabla_nueva <- data.frame(\"provincias\" = nombres, swiss)\nhead(tabla_nueva)##                provincias Fertility Agriculture Examination Education Catholic\n## Courtelary     Courtelary      80.2        17.0          15        12     9.96\n## Delemont         Delemont      83.1        45.1           6         9    84.84\n## Franches-Mnt Franches-Mnt      92.5        39.7           5         5    93.40\n## Moutier           Moutier      85.8        36.5          12         7    33.77\n## Neuveville     Neuveville      76.9        43.5          17        15     5.16\n## Porrentruy     Porrentruy      76.1        35.3           9         7    90.57\n##              Infant.Mortality\n## Courtelary               22.2\n## Delemont                 22.2\n## Franches-Mnt             20.2\n## Moutier                  20.3\n## Neuveville               20.6\n## Porrentruy               26.6\nrow.names(tabla_nueva) <- NULL # anulamos nombre de filas\nhead(tabla_nueva)##     provincias Fertility Agriculture Examination Education Catholic\n## 1   Courtelary      80.2        17.0          15        12     9.96\n## 2     Delemont      83.1        45.1           6         9    84.84\n## 3 Franches-Mnt      92.5        39.7           5         5    93.40\n## 4      Moutier      85.8        36.5          12         7    33.77\n## 5   Neuveville      76.9        43.5          17        15     5.16\n## 6   Porrentruy      76.1        35.3           9         7    90.57\n##   Infant.Mortality\n## 1             22.2\n## 2             22.2\n## 3             20.2\n## 4             20.3\n## 5             20.6\n## 6             26.6\ntabla_nueva$Fertility > 80##  [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [37]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\nwhich(tabla_nueva$Fertility > 80)##  [1]  1  2  3  4  7  8  9 10 11 37\ntabla_nueva$Fertility > 80##  [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [37]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\ntabla_nueva[tabla_nueva$Fertility > 80, ]##      provincias Fertility Agriculture Examination Education Catholic\n## 1    Courtelary      80.2        17.0          15        12     9.96\n## 2      Delemont      83.1        45.1           6         9    84.84\n## 3  Franches-Mnt      92.5        39.7           5         5    93.40\n## 4       Moutier      85.8        36.5          12         7    33.77\n## 7         Broye      83.8        70.2          16         7    92.85\n## 8         Glane      92.4        67.8          14         8    97.16\n## 9       Gruyere      82.4        53.3          12         7    97.67\n## 10       Sarine      82.9        45.2          16        13    91.38\n## 11      Veveyse      87.1        64.5          14         6    98.61\n## 37       Sierre      92.2        84.6           3         3    99.46\n##    Infant.Mortality\n## 1              22.2\n## 2              22.2\n## 3              20.2\n## 4              20.3\n## 7              23.6\n## 8              24.9\n## 9              21.0\n## 10             24.4\n## 11             24.5\n## 37             16.3\n# sin filtrar columnas\nsubset(tabla_nueva, subset = Fertility > 80)##      provincias Fertility Agriculture Examination Education Catholic\n## 1    Courtelary      80.2        17.0          15        12     9.96\n## 2      Delemont      83.1        45.1           6         9    84.84\n## 3  Franches-Mnt      92.5        39.7           5         5    93.40\n## 4       Moutier      85.8        36.5          12         7    33.77\n## 7         Broye      83.8        70.2          16         7    92.85\n## 8         Glane      92.4        67.8          14         8    97.16\n## 9       Gruyere      82.4        53.3          12         7    97.67\n## 10       Sarine      82.9        45.2          16        13    91.38\n## 11      Veveyse      87.1        64.5          14         6    98.61\n## 37       Sierre      92.2        84.6           3         3    99.46\n##    Infant.Mortality\n## 1              22.2\n## 2              22.2\n## 3              20.2\n## 4              20.3\n## 7              23.6\n## 8              24.9\n## 9              21.0\n## 10             24.4\n## 11             24.5\n## 37             16.3\n# filtrando columnas\nsubset(tabla_nueva, subset = Fertility > 80,\n       select = c(\"provincias\", \"Fertility\", \"Education\"))##      provincias Fertility Education\n## 1    Courtelary      80.2        12\n## 2      Delemont      83.1         9\n## 3  Franches-Mnt      92.5         5\n## 4       Moutier      85.8         7\n## 7         Broye      83.8         7\n## 8         Glane      92.4         8\n## 9       Gruyere      82.4         7\n## 10       Sarine      82.9        13\n## 11      Veveyse      87.1         6\n## 37       Sierre      92.2         3\nvar_logica <- tabla_nueva$Fertility > 80\ntabla_nueva_2 <- data.frame(tabla_nueva, \"alta_fertilidad\" = var_logica)\n# sin filtrar columnas\nsubset(tabla_nueva_2, subset = alta_fertilidad == TRUE)##      provincias Fertility Agriculture Examination Education Catholic\n## 1    Courtelary      80.2        17.0          15        12     9.96\n## 2      Delemont      83.1        45.1           6         9    84.84\n## 3  Franches-Mnt      92.5        39.7           5         5    93.40\n## 4       Moutier      85.8        36.5          12         7    33.77\n## 7         Broye      83.8        70.2          16         7    92.85\n## 8         Glane      92.4        67.8          14         8    97.16\n## 9       Gruyere      82.4        53.3          12         7    97.67\n## 10       Sarine      82.9        45.2          16        13    91.38\n## 11      Veveyse      87.1        64.5          14         6    98.61\n## 37       Sierre      92.2        84.6           3         3    99.46\n##    Infant.Mortality alta_fertilidad\n## 1              22.2            TRUE\n## 2              22.2            TRUE\n## 3              20.2            TRUE\n## 4              20.3            TRUE\n## 7              23.6            TRUE\n## 8              24.9            TRUE\n## 9              21.0            TRUE\n## 10             24.4            TRUE\n## 11             24.5            TRUE\n## 37             16.3            TRUE\n# igual (sin filtrar columnas)\nsubset(tabla_nueva_2, subset = alta_fertilidad)##      provincias Fertility Agriculture Examination Education Catholic\n## 1    Courtelary      80.2        17.0          15        12     9.96\n## 2      Delemont      83.1        45.1           6         9    84.84\n## 3  Franches-Mnt      92.5        39.7           5         5    93.40\n## 4       Moutier      85.8        36.5          12         7    33.77\n## 7         Broye      83.8        70.2          16         7    92.85\n## 8         Glane      92.4        67.8          14         8    97.16\n## 9       Gruyere      82.4        53.3          12         7    97.67\n## 10       Sarine      82.9        45.2          16        13    91.38\n## 11      Veveyse      87.1        64.5          14         6    98.61\n## 37       Sierre      92.2        84.6           3         3    99.46\n##    Infant.Mortality alta_fertilidad\n## 1              22.2            TRUE\n## 2              22.2            TRUE\n## 3              20.2            TRUE\n## 4              20.3            TRUE\n## 7              23.6            TRUE\n## 8              24.9            TRUE\n## 9              21.0            TRUE\n## 10             24.4            TRUE\n## 11             24.5            TRUE\n## 37             16.3            TRUE\n# filtrando columnas\nsubset(tabla_nueva_2, subset = alta_fertilidad,\n       select = c(\"provincias\", \"Fertility\", \"Education\"))##      provincias Fertility Education\n## 1    Courtelary      80.2        12\n## 2      Delemont      83.1         9\n## 3  Franches-Mnt      92.5         5\n## 4       Moutier      85.8         7\n## 7         Broye      83.8         7\n## 8         Glane      92.4         8\n## 9       Gruyere      82.4         7\n## 10       Sarine      82.9        13\n## 11      Veveyse      87.1         6\n## 37       Sierre      92.2         3\nfechas <-\n  seq(as.Date(\"1888-01-01\"), as.Date(\"1888-12-31\"), l = nrow(tabla_nueva_2))\nfechas##  [1] \"1888-01-01\" \"1888-01-08\" \"1888-01-16\" \"1888-01-24\" \"1888-02-01\"\n##  [6] \"1888-02-09\" \"1888-02-17\" \"1888-02-25\" \"1888-03-04\" \"1888-03-12\"\n## [11] \"1888-03-20\" \"1888-03-28\" \"1888-04-05\" \"1888-04-13\" \"1888-04-21\"\n## [16] \"1888-04-29\" \"1888-05-06\" \"1888-05-14\" \"1888-05-22\" \"1888-05-30\"\n## [21] \"1888-06-07\" \"1888-06-15\" \"1888-06-23\" \"1888-07-01\" \"1888-07-09\"\n## [26] \"1888-07-17\" \"1888-07-25\" \"1888-08-02\" \"1888-08-10\" \"1888-08-18\"\n## [31] \"1888-08-26\" \"1888-09-02\" \"1888-09-10\" \"1888-09-18\" \"1888-09-26\"\n## [36] \"1888-10-04\" \"1888-10-12\" \"1888-10-20\" \"1888-10-28\" \"1888-11-05\"\n## [41] \"1888-11-13\" \"1888-11-21\" \"1888-11-29\" \"1888-12-07\" \"1888-12-15\"\n## [46] \"1888-12-23\" \"1888-12-31\"\nclass(fechas)## [1] \"Date\"\nfechas + 1##  [1] \"1888-01-02\" \"1888-01-09\" \"1888-01-17\" \"1888-01-25\" \"1888-02-02\"\n##  [6] \"1888-02-10\" \"1888-02-18\" \"1888-02-26\" \"1888-03-05\" \"1888-03-13\"\n## [11] \"1888-03-21\" \"1888-03-29\" \"1888-04-06\" \"1888-04-14\" \"1888-04-22\"\n## [16] \"1888-04-30\" \"1888-05-07\" \"1888-05-15\" \"1888-05-23\" \"1888-05-31\"\n## [21] \"1888-06-08\" \"1888-06-16\" \"1888-06-24\" \"1888-07-02\" \"1888-07-10\"\n## [26] \"1888-07-18\" \"1888-07-26\" \"1888-08-03\" \"1888-08-11\" \"1888-08-19\"\n## [31] \"1888-08-27\" \"1888-09-03\" \"1888-09-11\" \"1888-09-19\" \"1888-09-27\"\n## [36] \"1888-10-05\" \"1888-10-13\" \"1888-10-21\" \"1888-10-29\" \"1888-11-06\"\n## [41] \"1888-11-14\" \"1888-11-22\" \"1888-11-30\" \"1888-12-08\" \"1888-12-16\"\n## [46] \"1888-12-24\" \"1889-01-01\"\ntabla_final <- data.frame(tabla_nueva_2, fechas)\nhead(tabla_final)##     provincias Fertility Agriculture Examination Education Catholic\n## 1   Courtelary      80.2        17.0          15        12     9.96\n## 2     Delemont      83.1        45.1           6         9    84.84\n## 3 Franches-Mnt      92.5        39.7           5         5    93.40\n## 4      Moutier      85.8        36.5          12         7    33.77\n## 5   Neuveville      76.9        43.5          17        15     5.16\n## 6   Porrentruy      76.1        35.3           9         7    90.57\n##   Infant.Mortality alta_fertilidad     fechas\n## 1             22.2            TRUE 1888-01-01\n## 2             22.2            TRUE 1888-01-08\n## 3             20.2            TRUE 1888-01-16\n## 4             20.3            TRUE 1888-01-24\n## 5             20.6           FALSE 1888-02-01\n## 6             26.6           FALSE 1888-02-09"},{"path":"if-else.html","id":"if-else","chapter":"Capítulo 10 Estructuras condicionales if-else","heading":"Capítulo 10 Estructuras condicionales if-else","text":"Scripts usados:script07.R: estructuras -else. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script07.RHasta ahora hemos trasteado con datos: hemos empezado desde una celda, para luego construir columnas, para luego juntarlas en algo parecido una base de datos.Para poder manejarnos con soltura con dichos datos es importante que conozcamos como se usan las expresiones de control más típicas. Una expresión de control será un conjunto de órdenes que nos permiten decidir por donde queremos que avance nuestro programa: ¿qué hacemos si sucede ? ¿Y si sucede B?Si programado en algún otro lenguaje, estarás familiarizado/con elementos como un (blabla) {...} else {...} (que los usaremos veces) o bucles y . Si es la primera que programas en algún lenguaje, te preocupes, las empezamos desde cero, empezando por las estructuras condicionalesif (condición) { código } else { código B }: si condición (por ejemplo, x == 1) es cierta, se ejecuta código ; si es falsa, se ejecuta código B.","code":""},{"path":"if-else.html","id":"if","chapter":"Capítulo 10 Estructuras condicionales if-else","heading":"10.1 if","text":"Una de las estructuras de control más famosas de cualquier lenguaje de programación: SI las condiciones impuestas se cumplen (TRUE), ejecuta las órdenes que tengamos dentro del {}. Definamos por ejemplo una variable sencilla, las edades de 8 personas.Para comprobar cuales son menores de edades podemos aplicar lo aprendido en temas anteriores, realizando una comparación lógica: si es menor de edad, devuelve un TRUE; en caso contrario, devuelve un FALSE.Con las funciones () y () podemos saber si todos o alguno de los elementos de un vector cumplen una condición.Con dichos elementos vamos construir nuestra primera estructura condicional: queremos que si existe algún menor de edad, nos imprima un mensaje indicándolo.En caso de que se cumplan las condiciones dentro del () (condiciones que devuelvan un FALSE), sucederá nada.Fíjate que en este caso hemos obtenido ningún mensaje porque la condición (edades >= 18) es cierta (son todos mayores de 18 años).","code":"\nedades <- c(14, 17, 24, 56, 31, 20, 87, 73)\nedades < 18## [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\nall(edades >= 18) # todos mayores de edad## [1] FALSE\nany(edades < 18) # existe algun menor de edad## [1] TRUE\nif (any(edades < 18)) { # TRUE si al menos una persona mayor de edad\n  \n  print(\"existe alguna persona mayor de edad\")\n  \n}## [1] \"existe alguna persona mayor de edad\"\nif (all(edades >= 18)) { # TRUE si TODOS son mayores de edad\n  \n  print(\"todas las personas son mayores de edad\")\n  \n}"},{"path":"if-else.html","id":"if---else","chapter":"Capítulo 10 Estructuras condicionales if-else","heading":"10.2 if - else","text":"La estructura (condicion) { } puede ser combinada con un else { }, de forma que cuando la condición se cumpla (como en el último ejemplo), se ejecutará el código que haya dentro del else { }, permitiéndonos decidir que sucede cuando SÍ se cumple y cuando se cumplePodemos ya complicar un poco el código con lo que hemos aprendido de temas anteriores: en caso de que haya alguno menor de edad, queremos extraer la edad por pantalla (con edades[edades < 18] extraeremos las edades que cumplen la condición de ser menor de edad).","code":"\nif (all(edades >= 18)) { # TRUE si TODOS son mayores de edad\n  \n  print(\"todas las personas son mayores de edad\")\n  \n} else { # si hay alguno menor de edad \n  \n  print(\"existe alguna persona menor de edad\")\n}## [1] \"existe alguna persona menor de edad\"\nif (all(edades >= 18)) { # TRUE si TODOS son mayores de edad\n  \n  print(\"todas las personas son mayores de edad\")\n  \n} else { # si hay alguno menor de edad \n  \n  print(glue(\"Existe alguna persona menor de edad. Sus edades son: {edades[edades < 18]}\"))\n}## Existe alguna persona menor de edad. Sus edades son: 14\n## Existe alguna persona menor de edad. Sus edades son: 17"},{"path":"if-else.html","id":"if---else-anidados","chapter":"Capítulo 10 Estructuras condicionales if-else","heading":"10.3 if - else anidados","text":"Dicha estructura - else puede anidarse, de forma que vayamos concatenando dichas estructuras, como en el ejemplo que tenemos debajo. Imagina que queremos realizar una acción si todos fuesen mayores de edad; en caso contrario, pero si todos los menores de edad tienen 16 años o más, realizar otra acción; en caso contrario, otra acción","code":"\nif (all(edades >= 18)) { # TRUE si TODOS son mayores de edad\n  \n  print(\"todas las personas son mayores de edad\")\n  \n} else if (all(edades >= 16)) { # si todos los menores de edad tienen >=16\n  \n  print(\"Existe alguna persona menor de edad pero todos con 16 años o más\")\n  \n} else {\n  \n  print(\"Existe alguna persona menor de 16 años\")\n\n}## [1] \"Existe alguna persona menor de 16 años\""},{"path":"if-else.html","id":"ifelse-vectorizado","chapter":"Capítulo 10 Estructuras condicionales if-else","heading":"10.4 ifelse () vectorizado","text":"Esta estructura condicional puede ser vectorizada, de forma que podamos reunir en una sola fila un número elevado de estructuras de comparación la función ifelse(), cuyos argumentos de entrada serán la condición evaluar, lo que sucede cuando se cumple y lo que , que aplicará cada elemento del vector de entrada. Con el ejemplo de las edades, vamos dejar el dato ausente si son menores de edad, y si son mayores de edad se queda como está.Todas estas estructuras solo sirven para datos numéricos. Vamos definir un vector de nombres con algunos ausentes (NA), y vamos sustituir los ausentes por el texto \"nombre_desconocido\" (los que sean ausentes se quedan como están).Esta función ifelse() es muy util para codificar variables o averiguar cuales cumplen una condición.","code":"\n# NA si no cumple la condición, la edad si se cumple.\nifelse(edades >= 18, edades, NA)## [1] NA NA 24 56 31 20 87 73\nnombres <- c(\"Juan\", \"María\", NA, NA, \"Lucía\", \"Carmen\", \"Javier\",\n             NA, \"Carlos\", NA, \"Gregorio\", \"Paloma\")\n\n# Si tiene ausente --> \"nombre_desconocido\"\n# Si no tiene ausente --> nombres originales\nnombres <- ifelse(is.na(nombres), \"nombre_desconocido\", nombres)\nnombres##  [1] \"Juan\"               \"María\"              \"nombre_desconocido\"\n##  [4] \"nombre_desconocido\" \"Lucía\"              \"Carmen\"            \n##  [7] \"Javier\"             \"nombre_desconocido\" \"Carlos\"            \n## [10] \"nombre_desconocido\" \"Gregorio\"           \"Paloma\""},{"path":"if-else.html","id":"consejos-6","chapter":"Capítulo 10 Estructuras condicionales if-else","heading":"10.5 Consejos","text":"CONSEJOS Rainbow parenthesesUno de los errores más habituales, y que seguirás cometiendo aunque lleves años programando, es cerrar un paréntesis que abierto, por lo que el programa sabe si acabado de llamar una orden o . Para ello en las nuevas versiones de RStudio, en el menú Tools < Global Options < Code < Display podemos habilitar la opción Rainbow Parentheses que nos escribe cada par de () de un color distinto\nImagen/gráfica 10.1: Activando Rainbow Parentheses.\n Minimiza estructuras de control en el códigoPuedes colapsar las estructuras de control pulsando en la flecha que aparece la izquierda de ellas en tu script. ","code":""},{"path":"if-else.html","id":"ejercicios-5","chapter":"Capítulo 10 Estructuras condicionales if-else","heading":"10.6 📝 Ejercicios","text":"(haz click en las flechas para ver soluciones)📝Ejercicio 1: modifica el código inferior para imprimir un mensaje por pantalla si todos los mamíferos del conjunto MASS::mammals pesan menos de una tonelada (variable body).Solución: 📝Ejercicio 2: modifica el código inferior para imprimir un mensaje por pantalla si alguno de los mamíferos del conjunto MASS::mammals pesan menos de una tonelada (variable body).Solución: 📝Ejercicio 3: modifica el código inferior para imprimir un mensaje por pantalla si el tercer mamífero del conjunto MASS::mammals tiene un cerebro que pesa más de 100 gr (variable brain).Solución:imprime nada porque cumple la condición. 📝Ejercicio 4: del paquete lubridate, la función hour() nos devuelve la hora de una fecha dada, y la función now() nos devuelve fecha y hora del momento actual. Con ambas funciones, y usando , imprime por pantalla \"buenas noches\" solo partir de las 21 horas. Solución: 📝Ejercicio 5: con las funciones del ejercicio anterior, y usando una estructura -else, imprime por pantalla \"buenos días\" (de 6 14 horas), \"buenas tardes\" (de 14 21 horas) o \"buenas noches\" (de las 21 las 6 horas). Solución: 📝Ejercicio 6: realiza el ejercicio anterior pero sin estructura de llaves, de forma concisa con ifelse(). Mira la ayuda si la necesitases poniendo ? ifelse. Solución: ","code":"\npeso <- MASS::mammals$body\n\nif (peso[1] == 1000) {\n  \n  print(\"Todos los mamíferos guardados pesan menos de una tonelada\")\n  \n}\npeso <- MASS::mammals$body\n\nif (all(peso < 1000)) {\n  \n  print(\"Todos los mamíferos guardados pesan menos de una tonelada\")\n  \n}\npeso <- MASS::mammals$body\n\nif (peso[1] == 1000) {\n  \n  print(\"Alguno de los mamíferos guardados pesan menos de una tonelada\")\n  \n}\npeso <- MASS::mammals$body\n\nif (any(peso < 1000)) {\n  \n  print(\"Alguno de los mamíferos guardados pesan menos de una tonelada\")\n  \n}## [1] \"Alguno de los mamíferos guardados pesan menos de una tonelada\"\npeso <- MASS::mammals$body\n\nif (peso[1] == 1000) {\n  \n  print(\"El tercer mamífero tiene un cerebro que pesa más de 100 gr.\")\n  \n}\ncerebro <- MASS::mammals$brain\n\nif (cerebro[3] > 100) {\n  \n  print(\"El tercer mamífero tiene un cerebro que pesa más de 100 gr.\")\n  \n}\n# Cargamos librería\nlibrary(lubridate)\n\n# Fecha-hora actual\nfecha_actual <- now()\n\n# Estructura if\nif (hour(fecha_actual) > 21) {\n  \n  cat(\"Buenas noches\") # print/cat dos formas de imprimir por pantalla\n}\n# Fecha actual\nfecha_actual <- now()\n\n# Estructura if-else\nif (hour(fecha_actual) > 6 & hour(fecha_actual) < 14) {\n  \n  cat(\"Buenos días\")\n  \n} else if (hour(fecha_actual) > 14 & hour(fecha_actual) < 21) {\n  \n  cat(\"Buenas tardes\")\n  \n} else {\n  \n  cat(\"Buenas noches\")\n}## Buenas noches\n# Fecha actual\nfecha_actual <- now()\n\n# Estructura if-else\ncat(ifelse(hour(fecha_actual) > 6 & hour(fecha_actual) < 14,\n           \"Buenos días\",\n           ifelse(hour(fecha_actual) > 14 &\n                    hour(fecha_actual) < 21,\n                  \"Buenas tardes\", \"Buenas noches\")))## Buenas noches"},{"path":"bucles.html","id":"bucles","chapter":"Capítulo 11 Bucles","heading":"Capítulo 11 Bucles","text":"Scripts usados:script08.R: bucles. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script08.RAunque la mayoría de veces son sustituibles por otras expresiones más legibles y eficientes, es importante que conozcamos otra archiconocida expresion de control: los bucles.\n* : bucle que permite repetir el mismo código un número fijo de veces (normalmente en función de un índice).\n* : bucle que permite repetir el mismo código un número indeterminado de veces hasta que se deje de cumplir una condición.","code":""},{"path":"bucles.html","id":"for","chapter":"Capítulo 11 Bucles","heading":"11.1 for","text":"Aunque la mayoría de las veces los bucles pueden ser sustituidos por expresiones mucho más eficientes (fíjate que ya hemos filtrado columnas, filas y aplicado operaciones por fulas y columnas, sin necesitarlo), veces nos quedará más remedio que usarlos por lo que nunca viene mal conocer su estructura.Un bucle {} es una estructura que nos permite repetir un conjunto de órdenes un número finito y conocido de veces: dado un conjunto de índices, el bucle irá recorriendo cada elemento de dicho conjunto, y para cada uno de ellos ejecutará lo que tenga dentro de las llaves.Por ejemplo, vamos definir de nuevo un vector de edades y nombres, y vamos recorrer cada uno imprimiento un mensaje por pantalla.Lo que tenemos dentro de los paréntesis, en la línea del , es más que la secuencia de números que hemos aprendido construir.Fíjate que si nos queremos preocupar de si añadimos otra persona, podemos hacer que el bucle empiece en 1 y termine en el último lugar (sea el que sea).Aunque normalmente el conjunto que recorre el bucle suelen ser índices numéricos, podemos recorrer cualquier tipo de objeto.Además de imprimir por pantalla podemos asignar valores variables o cambiarlas. Por ejemplo, vamos recorrer nuestro conjunto swiss de {datasets} y vamos pasar dato ausente todos los valores de fertilidad superiores 80. Para ello recorreremos cada fila para después ejecutar un .¿Te acuerdas de las operaciones por filas y columnas que hicimos con los apply()? Podemos hacer lo mismo (aunque menos eficiente) con un bucle: vamos sumar las filas del conjunto swiss. Para ello antes definiremos una variable llena de ceros que luego rellenaremos, de tamaño igual al número de filas, con suma <- rep(0, nrow(swiss)) ","code":"\nlibrary(glue)\nnombres <- c(\"Javi\", \"Laura\", \"Carlos\", \"Lucía\", \"Mar\")\nedades <- c(32, 51, 18, 43, 29)\n\n# Recorremos cada uno de los 5 elementos e imprimimos un mensaje que depende de i\nfor (i in 1:5) { \n  \n  print(glue(\"{nombres[i]} tiene {edades[i]} años\")) \n  \n}## Javi tiene 32 años\n## Laura tiene 51 años\n## Carlos tiene 18 años\n## Lucía tiene 43 años\n## Mar tiene 29 años\n1:5## [1] 1 2 3 4 5\nfor (i in 1:length(nombres)) { \n  \n  print(glue(\"{nombres[i]} tiene {edades[i]} años\")) \n  \n}## Javi tiene 32 años\n## Laura tiene 51 años\n## Carlos tiene 18 años\n## Lucía tiene 43 años\n## Mar tiene 29 años\ndias_semana <- c(\"lunes\", \"martes\", \"miércoles\", \"jueves\",\n                 \"viernes\", \"sábado\", \"domingo\")\nnombre_mayuscula <- NULL\nfor (dias in dias_semana) { # dias recorre los días de la semana tomando sus valores\n  \n  print(toupper(dias)) # Imprimimos en mayúsculas el día\n}## [1] \"LUNES\"\n## [1] \"MARTES\"\n## [1] \"MIÉRCOLES\"\n## [1] \"JUEVES\"\n## [1] \"VIERNES\"\n## [1] \"SÁBADO\"\n## [1] \"DOMINGO\"\nfor (i in 1:nrow(swiss)) {\n  \n  # si cumple la condición dicha fila, ponemos ausente.\n  if (swiss$Fertility[i] > 80) { \n    \n    swiss$Fertility[i] <- NA\n    \n  }\n}\nswiss##              Fertility Agriculture Examination Education Catholic\n## Courtelary          NA        17.0          15        12     9.96\n## Delemont            NA        45.1           6         9    84.84\n## Franches-Mnt        NA        39.7           5         5    93.40\n## Moutier             NA        36.5          12         7    33.77\n## Neuveville        76.9        43.5          17        15     5.16\n## Porrentruy        76.1        35.3           9         7    90.57\n## Broye               NA        70.2          16         7    92.85\n## Glane               NA        67.8          14         8    97.16\n## Gruyere             NA        53.3          12         7    97.67\n## Sarine              NA        45.2          16        13    91.38\n## Veveyse             NA        64.5          14         6    98.61\n## Aigle             64.1        62.0          21        12     8.52\n## Aubonne           66.9        67.5          14         7     2.27\n## Avenches          68.9        60.7          19        12     4.43\n## Cossonay          61.7        69.3          22         5     2.82\n## Echallens         68.3        72.6          18         2    24.20\n## Grandson          71.7        34.0          17         8     3.30\n## Lausanne          55.7        19.4          26        28    12.11\n## La Vallee         54.3        15.2          31        20     2.15\n## Lavaux            65.1        73.0          19         9     2.84\n## Morges            65.5        59.8          22        10     5.23\n## Moudon            65.0        55.1          14         3     4.52\n## Nyone             56.6        50.9          22        12    15.14\n## Orbe              57.4        54.1          20         6     4.20\n## Oron              72.5        71.2          12         1     2.40\n## Payerne           74.2        58.1          14         8     5.23\n## Paysd'enhaut      72.0        63.5           6         3     2.56\n## Rolle             60.5        60.8          16        10     7.72\n## Vevey             58.3        26.8          25        19    18.46\n## Yverdon           65.4        49.5          15         8     6.10\n## Conthey           75.5        85.9           3         2    99.71\n## Entremont         69.3        84.9           7         6    99.68\n## Herens            77.3        89.7           5         2   100.00\n## Martigwy          70.5        78.2          12         6    98.96\n## Monthey           79.4        64.9           7         3    98.22\n## St Maurice        65.0        75.9           9         9    99.06\n## Sierre              NA        84.6           3         3    99.46\n## Sion              79.3        63.1          13        13    96.83\n## Boudry            70.4        38.4          26        12     5.62\n## La Chauxdfnd      65.7         7.7          29        11    13.79\n## Le Locle          72.7        16.7          22        13    11.22\n## Neuchatel         64.4        17.6          35        32    16.92\n## Val de Ruz        77.6        37.6          15         7     4.97\n## ValdeTravers      67.6        18.7          25         7     8.65\n## V. De Geneve      35.0         1.2          37        53    42.34\n## Rive Droite       44.7        46.6          16        29    50.43\n## Rive Gauche       42.8        27.7          22        29    58.33\n##              Infant.Mortality\n## Courtelary               22.2\n## Delemont                 22.2\n## Franches-Mnt             20.2\n## Moutier                  20.3\n## Neuveville               20.6\n## Porrentruy               26.6\n## Broye                    23.6\n## Glane                    24.9\n## Gruyere                  21.0\n## Sarine                   24.4\n## Veveyse                  24.5\n## Aigle                    16.5\n## Aubonne                  19.1\n## Avenches                 22.7\n## Cossonay                 18.7\n## Echallens                21.2\n## Grandson                 20.0\n## Lausanne                 20.2\n## La Vallee                10.8\n## Lavaux                   20.0\n## Morges                   18.0\n## Moudon                   22.4\n## Nyone                    16.7\n## Orbe                     15.3\n## Oron                     21.0\n## Payerne                  23.8\n## Paysd'enhaut             18.0\n## Rolle                    16.3\n## Vevey                    20.9\n## Yverdon                  22.5\n## Conthey                  15.1\n## Entremont                19.8\n## Herens                   18.3\n## Martigwy                 19.4\n## Monthey                  20.2\n## St Maurice               17.8\n## Sierre                   16.3\n## Sion                     18.1\n## Boudry                   20.3\n## La Chauxdfnd             20.5\n## Le Locle                 18.9\n## Neuchatel                23.0\n## Val de Ruz               20.0\n## ValdeTravers             19.5\n## V. De Geneve             18.0\n## Rive Droite              18.2\n## Rive Gauche              19.3\nsuma <- rep(0, nrow(swiss))\nfor (i in 1:nrow(swiss)) {\n  \n  suma[i] <- sum(swiss[i, ])\n}\nsuma##  [1]     NA     NA     NA     NA 178.16 244.57     NA     NA     NA     NA\n## [11]     NA 184.12 176.77 187.73 179.52 206.30 154.00 161.41 133.45 188.94\n## [21] 180.53 164.02 173.34 157.00 180.10 183.33 165.06 171.32 168.46 166.50\n## [31] 281.21 286.68 292.30 285.06 272.72 275.76     NA 283.33 172.72 147.69\n## [41] 154.52 188.92 162.17 146.45 186.54 204.93 199.13"},{"path":"bucles.html","id":"while","chapter":"Capítulo 11 Bucles","heading":"11.2 while","text":"Otra manera de diseñar un bucle es con la estructura {}, que ejecutará el bucle un número de veces pero que priori es desconocido, lo hará hasta que la condición impuesta deje de ser TRUE (en el sabemos de antemano el número de iteraciones).¿Y qué sucede cuando la condición nunca llega ser FALSE? Compruébalo tú mismo/.","code":"\nmax_ciclos <- 10\nciclos <- 1\n\n# Mientras el número de ciclos sea inferior 10, imprime\nwhile(ciclos <= max_ciclos) {\n  \n  print(paste(\"Todavía no, vamos por el ciclo \", ciclos)) # Pegamos la frase al número de ciclo por el que vayamos con paste\n  ciclos <- ciclos + 1\n  \n}## [1] \"Todavía no, vamos por el ciclo  1\"\n## [1] \"Todavía no, vamos por el ciclo  2\"\n## [1] \"Todavía no, vamos por el ciclo  3\"\n## [1] \"Todavía no, vamos por el ciclo  4\"\n## [1] \"Todavía no, vamos por el ciclo  5\"\n## [1] \"Todavía no, vamos por el ciclo  6\"\n## [1] \"Todavía no, vamos por el ciclo  7\"\n## [1] \"Todavía no, vamos por el ciclo  8\"\n## [1] \"Todavía no, vamos por el ciclo  9\"\n## [1] \"Todavía no, vamos por el ciclo  10\"\nwhile (1 > 0) { # Nunca va a dejar de ser cierto\n  \n  print(\"Presiona ESC para salir del bucle\")\n  \n}"},{"path":"bucles.html","id":"breaknext","chapter":"Capítulo 11 Bucles","heading":"11.3 break/next","text":"En R tenemos dos comandos reservados para poder abortar un bucle o avanzar forzosamente un bucle: dichas palabras son break y next. La primera nos habilita para parar un bucle aunque haya llegado al final de su conjunto de índices recorrer (o se siga cumpliendo la condición del {}).Vamos hacer un bucle de 1 10: cuando el índice es igual 7, el bucle se para.Mientras que la segunda, el next obliga al bucle avanzar la siguiente interacción, abortando la iteración actual en la que se encuentra. Vamos ahora hacer un bucle de 1 10: cuando el índice es igual 7, el bucle salta al = 8.","code":"\nfor(i in 1:10) {\n  if (i == 7) {\n    \n    break # si i es 7, el bucle frena aquí (nunca llegará a imprimir el 7 ni los sucesivos)\n    \n  }\n  print(i)\n}## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\nfor(i in 1:10) {\n  if (i == 7) {\n    \n    next # si i es 7, la iteración frenará aquí y pasará a la siguiente por lo que imprimirá todos menos el 7\n    \n  }\n  print(i)\n}## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\n## [1] 8\n## [1] 9\n## [1] 10"},{"path":"bucles.html","id":"repeat","chapter":"Capítulo 11 Bucles","heading":"11.4 repeat","text":"Aunque es una opción muy poco usada, existe una estructura de control llamada repeat{} que nos ejecuta un bucle de forma infinita hasta que le ordenemos parar con un break. WARNING: cuidado con los bucles infinitosLas estucturas {} y repeat{} son de las menos usadas por su peligrosidad, ya que si incluimos un break o la condición nunca llega ser TRUE, el bucle seguirá ejecutándose de forma infinita y solo podrá ser detenido abortando la ejecución con la tecla ESC. ","code":"\nconteo <- 0\nrepeat { \n  \n  conteo <- conteo + 1\n  if (conteo >= 100) { break }\n  \n}\nconteo## [1] 100"},{"path":"bucles.html","id":"consejos-7","chapter":"Capítulo 11 Bucles","heading":"11.5 Consejos","text":"CONSEJOS Evita bucles (si puedes)Recuerda: por lo general, di los bucles en R (intenta evitarlos, en la mayoría de casos hay una alternativa mejor). Evita bucles (parte II)Evita al máximo los bucles en R: suele existir una forma más eficiente de programarlo. Veamos un ejemplo muy sencillo: dado un vector de índices idx, queremos calcular su cuadrado y guardarlo. Vamos comparar como sería con un sencillo bucle y de forma vectorial, repitiéndolo 1000 veces para sacar tiempos medios, haciendo uso del paquete microbenchmark.Una tarea tan sencilla, programada en un bucle (segunda fila), tarda 40 veces más que hacerlo de forma vectorial (primera fila) (elevando cada elemento al cuadrado, iterando internamente, sin necesidad de implementar un bucle).","code":"\nidx <- 1:10000\nx <- y <- rep(0, length(idx))\nmicrobenchmark::microbenchmark(x <- idx^2, \n                               for (i in idx) {  y[i] <- idx[i]^2},\n                               times = 1e3)## Unit: microseconds\n##                                     expr      min       lq       mean    median\n##                               x <- idx^2   18.631   49.874   54.98471   55.5605\n##  for (i in idx) {     y[i] <- idx[i]^2 } 1821.947 1957.937 2172.37245 2028.9530\n##         uq      max neval cld\n##    62.7185  192.113  1000  a \n##  2156.3040 8348.379  1000   b"},{"path":"bucles.html","id":"ejercicios-6","chapter":"Capítulo 11 Bucles","heading":"11.6 📝 Ejercicios","text":"(haz click en las flechas para ver soluciones)📝Ejercicio 1: modifica el código interior para diseñar un bucle de 5 iteraciones que recorra los 5 primeros impares y les sume uno.Solución: 📝Ejercicio 2: modifica el código interior para diseñar un bucle que parta con una variable conteo <- 1 y pare cuando llegue 6.Solución: 📝Ejercicio 3: construye un bucle que recorra las primeras 8 filas del conjunto de datos MASS::mammals y que imprima el peso del animal (en kg) multiplicado por 1000 (gramos).Solución: 📝Ejercicio 4: diseña un bucle de 200 iteraciones que, empezando en un valor inicial de 100 (euros), te sume 3€ si el número actual es par y te reste 5€ si es impar.Un número par o impar: un número par será todo aquel número que al dividir entre 2, la división es exacta, es decir, que su resto es nulo. Por ejemplo, al dividir 5 entre 2, el resto es 1, pero al dividir 12 entre 2 el resto es 0. Para calcula ese resto usaremos la función %%.Solución: 📝Ejercicio 5: diseña el anterior bucle pero guardando el dinero de cada iteración.Solución: 📝Ejercicio 6: diseña el bucle del ejercicio 4 parando cuando nos quede dinero.Solución:","code":"\nfor (i in 1:5) {\n  \n  print(i)\n}## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\n# Una forma\nfor (i in seq(1, 9, by = 2)) {\n  \n  print(i + 1)\n}## [1] 2\n## [1] 4\n## [1] 6\n## [1] 8\n## [1] 10\n# Otra\nfor (i in c(1, 3, 5, 7, 9)) {\n  \n  print(i + 1)\n}## [1] 2\n## [1] 4\n## [1] 6\n## [1] 8\n## [1] 10\nconteo <- 1\nwhile (conteo == 2) {\n  \n  print(conteo)\n}\nconteo <- 1\nwhile (conteo < 6) {\n  \n  print(conteo)\n  conteo <- conteo <- conteo + 1\n}## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\nfor (i in 1:8) {\n  \n  print(MASS::mammals$body[i] * 1000)\n}## [1] 3385\n## [1] 480\n## [1] 1350\n## [1] 465000\n## [1] 36330\n## [1] 27660\n## [1] 14830\n## [1] 1040\n5 %% 2## [1] 1\n12 %% 2## [1] 0\n23 %% 2## [1] 1\n46 %% 2## [1] 0\n# dinero inicial\ndinero <- 100\n\n# Bucle for\nfor (i in 1:200) {\n  \n  dinero <- ifelse(dinero %% 2 == 0, dinero + 3, dinero  - 5)\n  \n}\ndinero## [1] -100\n# vector de importes\ndinero <- rep(0, 201)\ndinero[1] <- 100 # dinero inicial\n\n# Bucle for\nfor (i in 2:201) {\n  \n  # si dinero[i - 1] es par o  impar\n  dinero[i] <- ifelse(dinero[i - 1] %% 2 == 0, dinero[i - 1] + 3,\n                      dinero[i - 1]  - 5)\n  \n}\ndinero##   [1]  100  103   98  101   96   99   94   97   92   95   90   93   88   91   86\n##  [16]   89   84   87   82   85   80   83   78   81   76   79   74   77   72   75\n##  [31]   70   73   68   71   66   69   64   67   62   65   60   63   58   61   56\n##  [46]   59   54   57   52   55   50   53   48   51   46   49   44   47   42   45\n##  [61]   40   43   38   41   36   39   34   37   32   35   30   33   28   31   26\n##  [76]   29   24   27   22   25   20   23   18   21   16   19   14   17   12   15\n##  [91]   10   13    8   11    6    9    4    7    2    5    0    3   -2    1   -4\n## [106]   -1   -6   -3   -8   -5  -10   -7  -12   -9  -14  -11  -16  -13  -18  -15\n## [121]  -20  -17  -22  -19  -24  -21  -26  -23  -28  -25  -30  -27  -32  -29  -34\n## [136]  -31  -36  -33  -38  -35  -40  -37  -42  -39  -44  -41  -46  -43  -48  -45\n## [151]  -50  -47  -52  -49  -54  -51  -56  -53  -58  -55  -60  -57  -62  -59  -64\n## [166]  -61  -66  -63  -68  -65  -70  -67  -72  -69  -74  -71  -76  -73  -78  -75\n## [181]  -80  -77  -82  -79  -84  -81  -86  -83  -88  -85  -90  -87  -92  -89  -94\n## [196]  -91  -96  -93  -98  -95 -100\ndinero <- 100 # dinero inicial\n\n# Bucle while\nwhile (dinero > 0) {\n  \n  dinero <- ifelse(dinero %% 2 == 0, dinero + 3, dinero - 5)\n  \n}\ndinero## [1] 0"},{"path":"proyecto.html","id":"proyecto","chapter":"Capítulo 12 Primer proyecto de trabajo","heading":"Capítulo 12 Primer proyecto de trabajo","text":"Estamos listos/para crear nuestro primer proyecto de R para trabajar ordenadicos/.Cuando se empieza programar para un trabajo concreto de R es recomendable crearnos lo que se conoce como un proyecto de R: en lugar de ir abriendo ventanas sueltas para programar (las pestañas de los scripts, los archivos con extensión .R que hemos comentado), podemos agruparlos en distintos proyectos, de forma que podamos acceder ellos de forma ordenada (algo así como crear carpetas en nuestro disco duro, pero en RStudio).","code":""},{"path":"proyecto.html","id":"crear-proyecto","chapter":"Capítulo 12 Primer proyecto de trabajo","heading":"12.1 Crear proyecto","text":"Para crear nuestro proyecto deberemos de ir al menú superior File << New Project (ver 12.1)\nImagen/gráfica 12.1: Crear un nuevo proyecto en R.\nSe nos abrirá una ventana con 3 opciones:New directory: crear un proyecto desde el inicio (opción recomendable).New directory: crear un proyecto desde el inicio (opción recomendable).Existing directory: crear un proyecto con los códigos que tienes ya guardados en una carpeta.Existing directory: crear un proyecto con los códigos que tienes ya guardados en una carpeta.Version control: para importar el proyecto de algún repositorio y vincularlo él.Version control: para importar el proyecto de algún repositorio y vincularlo él.\nImagen/gráfica 12.2: Opciones de creación.\n\nImagen/gráfica 12.3: Clickar en «New project».\nDeberemos elegir el directorio de nuestro ordenador donde queremos que se guarde (una carpeta que contendrá todos los códigos y datos de ese proyecto), así como el nombre del proyecto (que será su vez el nombre de la subcarpeta que se os creará en el ordenador).\nImagen/gráfica 12.4: Nombre del proyecto.\nUna vez que el proyecto está creado, abriremos un script de R (donde escribiremos el código), escribiremos si queremos una descripción del proyecto en la primera línea y guardaremos el archivo (archivo de extensión .R).\nImagen/gráfica 12.5: Abrir nuestro primer script de R.\n\nImagen/gráfica 12.6: Descripción al inicio del código.\n\nImagen/gráfica 12.7: Guardamos el código.\n\nImagen/gráfica 12.8: Guardamos el código.\nEste será nuestro código principal (puedes ponerle el nombre que quieras, normalmente se le llama main.R para diferenciarlo del resto), desde el que iremos construyendo nuestro código e iremos llamando otros archivos si es necesario. Recuerda que programar es como escribir: cuanto más limpio y estructurado, mejor se entenderá. La ventaja de tener los códigos agrupados por proyectos es que si estamos trabajando en varios la vez podemos saltar de uno otro, visualizando solo los códigos de un proyecto, y los 100 archivos que vayamos creando.\nImagen/gráfica 12.9: Saltar de proyecto en proyecto.\n","code":""},{"path":"proyecto.html","id":"directorios-de-trabajo-y-cabecera","chapter":"Capítulo 12 Primer proyecto de trabajo","heading":"12.2 Directorios de trabajo y cabecera","text":"Como luego veremos, es altamente recomendable que todos los archivos (códigos, datos, imágenes, recursos, etc) estén dentro de la misma carpeta del proyecto (aunque podamos crear subdirectorios), para que trabajar en el proyecto sea más sencillo e intuitivo. Vamos crearnos dentro de la carpeta del proyecto, una subcarpeta que se llame DATOS, en donde debemos descargar todos los ficheros que hay en https://github.com/dadosdelaplace/courses-intro-r/tree/main/DATOS, y otra llamada CODIGOS, donde guardar nuestros archivos .R (por eso de ser ordenadicos).\nImagen/gráfica 12.10: Subcarpeta «CODIGOS».\nEn esa carpeta de códigos vamos crear de prueba el código llamado variables.R donde vamos definir algunas variables que luego usaremos en el código principal (suele suceder con variables que van ser fijas como nombres, fechas o codificaciones de variables).\nImagen/gráfica 12.11: Escribimos una serie de variables fijas para luego ser usadas.\nes obligatorio pero es altamente recomendable tener muy estructurado nuestros códigos, de forma que el archivo .R haga una tarea concreta y definida (uno carga archivos, otro preprocesa, otro hace un modelo, otro hace las gráficas), y sea el código principal el que haga una llamada limpia todos ellos, para que en caso de error, la detección del mismo sea más sencilla.Así que eso haremos: desde nuestro archivo principal main.R llamaremos ese archivo variables.R, para luego usar las variables definidas en él.¿Cómo indicarle R donde está nuestro fichero?En R, como en todo lenguaje de programación, podemos consultar lo que el ordenador llama directorio de trabajo: la carpeta «base» desde donde está ejecutando tu código. Dicha ruta de directorio se puede consultar con la función getwd(), pudiendo ver los archivos y carpetas que hay dentro del mismo con el comando dir()\nImagen/gráfica 12.12: Consultar directorio de trabajo predeterminado y archivos contenidos en él.\nLo ideal es empezar el código fijando como directorio de trabajo el directorio donde tengamos nuestro archivo principalmain.R y para ello usaremos la función setwd(), cuyo argumento será la ruta donde queremos fijarlo. Para hacerlo de forma automática (y que el código pueda ser abierto por ti pero también por otros que tengan tu misma estructura de carpetas), obtendremos de forma automática la ruta del archivo main.R o del proyecto con la orden rstudioapi::getSourceEditorContext()$path, y después usaremos dirname() para quedarnos solo con la ruta de carpetas (eliminando el nombre del fichero al final). Esa será la ruta que le pasaremos setwd(), quedando nuestro directorio de trabajo automáticamente fijado, sin preocuparnos de la ruta\nImagen/gráfica 12.13: Fijamos de forma automático el directorio de trabajo.\nUna vez que hemos fijado nuestro directorio, para cargar código .R, basta que usemos la función source(), cuyo argumento será la ruta del archivo. Como tenemos de directorio base el directorio en el que tenemos nuestro archivo principal (./), bastará que empecemos escribir source(\"./\"), presionar el tabulador, y se nos abrirá el menú de archivos de nuestro directorio de trabajo, pudiendo ir seleccionando de forma sencilla la ruta de nuestro archivo.\nImagen/gráfica 12.14: Cargar archivos de nuestro directorio de trabajo.\n\nImagen/gráfica 12.15: Cargar archivos de nuestro directorio de trabajo.\n","code":"\n# Descripción: script de prueba con variables\n\n# Variables\nx <- c(1, 2, 0, -1, 71) # Vector de números\ny <- c(\"hola\", \"me\", \"llamo\", \"Javier\") # Vector de caracteres\napellido <- \"Álvarez\"\n\n# Fechas\nhoy <- as.Date(Sys.time()) # Convertir a tipo fecha la fecha de hoy\nfecha_origen <- as.Date(\"2021-01-01\") # Inicio de año\ngetwd()\ndir()\n# Fijamos directorio de trabajo automáticamente\nsetwd(dirname(rstudioapi::getSourceEditorContext()$path))"},{"path":"proyecto.html","id":"ejecución","chapter":"Capítulo 12 Primer proyecto de trabajo","heading":"12.3 Ejecución","text":"Ese archivo que hemos incluido en el código principal nos cargará las variables que hemos definido en él, pudiendo usarlas en el código. Vamos ejecutar lo que tenemos de momento, y para ello tenemos 2 opciones: o copiar el código del script en la consola y pulsar ENTER, o bien, activando la casilla source save y guardando el script (solo se guardará sino que se ejecutará).\nImagen/gráfica 12.16: Guardamos con la casilla «source save» activada para que además de guardar se ejecute el código.\nComo vemos en la imagen 12.16, una vez ejecutado, tenemos en nuestro panel de entorno (parte superior derecha) las variables ya cargadas que teníamos definidas en nuestro fichero variables.R.Prueba escribir algunas funciones que hemos aprendido con dichas variables y vuelve hacer click en «guardar» con source save activado.La función cat() nos muestra por consola el texto que le pasemos de argumento (función especial para mensajes de alerta por consola)\nImagen/gráfica 12.17: Cálculos con la variables definidas: suma, concatenación de texto y diferencia de fechas.\nYa hemos ejecutado nuestro primer proyecto en .R :) WARNING: guardar los scriptsLos scripts que tengas sin guardar tendrán un asterisco * al final del nombre en la pestaña superior de la ventana.","code":"\n# Sumamos 3 a cada elemento de x\nz <- x + 3\nz## [1]  4  5  3  2 74\n# Imprimimos por pantalla la frase unida, y a dicha frase\n# le pegamos nuestro apellido\ncat(paste(paste(y, collapse = \" \"), apellido))## hola me llamo Javier Álvarez\n# Días que han pasado desde el inicio de año\ndias <- hoy - fecha_origen\ndias## Time difference of 369 days"},{"path":"proyecto.html","id":"consejos-8","chapter":"Capítulo 12 Primer proyecto de trabajo","heading":"12.4 Consejos","text":"CONSEJOS Limpiar consolaPodemos limpiar la consola clickando en al escoba que tenemos en la parte superior derecha de la misma. Esta acción nos elimina ninguna variable, simplemente nos limpia la consola de mensajes. Comentarios en los códigosEs crucial que intentes documentar al máximo tu código y que te acostumbres ello desde el principio, dejando explícito que haces en cada paso, tanto para ti como para otra persona que pueda leer tu código y lo entienda. Para ello usaremos # comentario cuando queramos dejar comentarios en el código. Dichas partes, amén de estar en otro color, son leídas por R ni ejecutadas: son comentarios que el programa «ve», solo son para nosotros. ","code":""},{"path":"funciones.html","id":"funciones","chapter":"Capítulo 13 Funciones","heading":"Capítulo 13 Funciones","text":"Scripts usados:script09.R: funciones. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script09.REn R solo podemos usar las funciones predeterminadas que vienen ya cargadas, como o las de los paquetes que instalamos, como sum(), read.csv() o mean(), sino que además podemos crear nuestras propias funciones, para automatizar tareas que vayamos repetir lo largo de nuestro código.¿Cómo crear nuestra propia función? Veamos su esquema básico. Para crear una función necesitamosUn nombre, por ejemplo nombre_funcion (sin espacios ni caracteres extraños)dicho nombre le asignamos <- la palabra reservada function().Dentro de function() definimos los argumentos de entrada que usará la función.Dentro de {} incluiremos la órdenes.Finalizaremos la función con return(), indicando lo que queremos que devuelva la función.En el esquema anteriorargumento_1, argumento_2, …: serán los argumentos de entrada, los argumentos que toma la función para ejecutar el código que tiene dentrocódigo: líneas de código que queramos que ejecute la función. IMPORTANTE: todas las variables que definamos dentro de la función son variables locales, solo existirán dentro de la función salvo que especifiquemos lo contrario.return(variable_salida): dentro del comando return() se introducirá la salida de la función, que puede ser un número, un data.frame, una gráfica, una matriz…","code":"\nnombre_funcion <- function(argumento_1, argumento_2, ... ) {\n  \n  # Código que queramos ejecutar en la función\n  código\n  \n  # Salida\n  return(variable_salida)\n}"},{"path":"funciones.html","id":"primera-función","chapter":"Capítulo 13 Funciones","heading":"13.1 Primera función","text":"Veamos un ejemplo muy simple de función para calcular el área de un rectángulo: los argumentos de entrada serán los lados (lado_1 y lado_2), y el valor devolver será el área lado_1 * lado_2 (el producto de los lados).También podemos hacer la definición directa sin almacenar variables por el camino¿Cómo aplicar la función? Con el nombre y los valores de los argumentos: usamos calcular_area() y le pasamos los dos argumentos de entrada.Imagina ahora que nos damos cuenta que el 90% de las veces el área que nos toca calcular fuese la de un cuadrado (es decir, solo necesitamos un argumento, un lado): R nos permite definir argumentos por defecto en la función (tomarán dicho valor salvo que le asignemos otro). ¿Por qué asignar lado_2 = lado_1 por defecto, para ahorrar líneas de código y tiempo?Ahora, si indicamos nada, por defecto el segundo lado será igual al primero (un cuadrado).Compliquemos un poco la función y añadamos en la salida los valores de cada lado, etiquetados como lado_1 y lado_2.Veamos que nos devuelve ahoraAntes nos daba igual el orden de los argumentos pero ahora , ya que en la salida incluimos lado_1 y lado_2. Es altamente recomendable hacer la llamada la función indicando explícitamente los argumentos argumento_1 = valor_1 para mejorar la legibilidad e interpretabilidad de nuestro código (recuerda: programa como escribirías en castellano).","code":"\n# Definición del nombre de función y argumentos de entrada\ncalcular_area <- function(lado_1, lado_2) {\n  \n  # Cuerpo de la función (lo que hace)\n  area <- lado_1 * lado_2\n  \n  # Resultado (lo que devuelve)\n  return(area)\n  \n}\n# Definición del nombre de función y argumentos de entrada\ncalcular_area <- function(lado_1, lado_2) {\n\n  # Resultado que devolvemos\n  return(lado_1 * lado_2)\n  \n}\n# Aplicación de la función con los parámetros por defecto\ncalcular_area(5, 3) # área de un rectángulo 5 x 3 ## [1] 15\n# Definición del nombre de función y argumentos de entrada\ncalcular_area <- function(lado_1, lado_2 = lado_1) {\n  \n  # Cuerpo de la función\n  area <- lado_1 * lado_2\n  \n  # Resultado que devolvemos\n  return(area)\n  \n}\ncalcular_area(lado_1 = 5) # si no indicamos nada, lado_2 = lado_1## [1] 25\n# Definición del nombre de función y argumentos de entrada\ncalcular_area <- function(lado_1, lado_2 = lado_1) {\n  \n  # Cuerpo de la función\n  area <- lado_1 * lado_2\n  \n  # Resultado\n  return(c(\"area\" = area, \"lado_1\" = lado_1, \"lado_2\" = lado_2))\n  \n}\nsalida <- calcular_area(5, 3)\nsalida##   area lado_1 lado_2 \n##     15      5      3\nsalida[\"area\"]## area \n##   15\nsalida[\"lado_1\"]## lado_1 \n##      5\nsalida[\"lado_2\"]## lado_2 \n##      3\ncalcular_area(lado_1 = 5, lado_2 = 3)##   area lado_1 lado_2 \n##     15      5      3"},{"path":"funciones.html","id":"variables-localesglobales","chapter":"Capítulo 13 Funciones","heading":"13.2 Variables locales/globales","text":"¿Qué sucede si nombramos una variable dentro de una función que se nos ha olvidado asignar un valor dentro de la misma? Debemos ser cautos al usar funciones en R, ya que debido la «regla lexicográfica», si una variable se define dentro de la función, R buscará dicha variable en el entorno de variables.Construyamos una función de ejemplo que toma ningún argumento de entrada: solo imprime el valor de x. Como dentro de la función x está definida, usará el valor definido fuera de la función.Si una variable ya está definida fuera de la función (entorno global), y además es usada dentro de la misma cambiando su valor, el valor de dicha variable solo cambia dentro de la función pero en el entorno global.Si queremos que además de cambiar localmente lo haga globalmente deberemos usar la doble asignación (<<-).","code":"\nx <- 1\nfuncion_ejemplo <- function() {\n    \n  print(x) # No devuelve nada per se, solo realiza la acción de imprimir en consola\n}\nfuncion_ejemplo()## [1] 1\nx <- 1\nfuncion_ejemplo <- function() {\n    \n  x <- 2\n  print(x) # lo que vale dentro\n}\nfuncion_ejemplo() # lo que vale dentro## [1] 2\nprint(x) # lo que vale fuera## [1] 1\nx <- 1\ny <- 2\nfuncion_ejemplo <- function() {\n  \n  x <- 3 # no cambia globalmente, solo localmente\n  y <<- 0 # cambia globalmente\n  print(x)\n  print(y)\n}\n\nfuncion_ejemplo() # lo que vale dentro## [1] 3\n## [1] 0\nx # lo que vale fuera## [1] 1\ny # lo que vale fuera## [1] 0"},{"path":"funciones.html","id":"ejercicios-7","chapter":"Capítulo 13 Funciones","heading":"13.3 📝 Ejercicios","text":"Ejercicio 1: modifica el código inferior para definir una función llamada funcion_suma, de forma que dados dos elementos, devuelve su suma.Solución:&nsbp;Ejercicio 2: modifica el código inferior para definir una función llamada funcion_producto, de forma que dados dos elementos, devuelve su producto.Solución: Ejercicio 3: modifica el código inferior para definir una función llamada funcion_producto, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado (es decir, por defecto un solo argumento, y el resultado sea el número por sí mismo)Solución: Ejercicio 4: define una función llamada igualdad_nombres que, dados dos nombres persona_1 e persona_2, nos diga si son iguales o . Hazlo considerando importantes las mayúsculas, y sin que importen las mayúsculas. Recuerda que con toupper() podemos pasar todo un texto mayúscula. Solución: Ejercicio 5: define una función llamada pares que, dados dos números x e y, nos diga si la suma de ambos es par o .Recuerda que con %% podemos obtener el resto de un número al dividir entre 2.Solución: ","code":"\n# Definimos función\nnombre <- function(x, y) {\n  \n  # Sumamos\n  suma <- # código a ejecutar\n  \n  # ¿Qué devolvemos?\n  return()\n}\n\n# Aplicamos la función\nsuma(3, 7)\n# Definimos función\nfuncion_suma <- function(x, y) {\n  \n  # Sumamos\n  suma <- x + y\n  \n  # Devolvemos la salida\n  return(suma)\n}\n\n# Aplicamos la función\nfuncion_suma(3, 7)## [1] 10\n# Definimos función\nnombre <- function(x, y) {\n  \n  # Multiplicamos\n  producto <- # código de la multiplicación\n  \n  # ¿Qué devolvemos?\n  return()\n}\n\n# Aplicamos la función\nproducto(3, -7)\n# Definimos función\nfuncion_producto <- function(x, y) {\n  \n  # Multiplicamos\n  producto <- x * y\n  \n  # Devolvemos la salida\n  return(producto)\n}\n\n# Aplicamos la función\nfuncion_producto(3, -7)## [1] -21\n# Definimos función\nnombre <- function(x, y) {\n  \n  # Multiplicamos\n  producto <- # código de la multiplicación\n  \n  # ¿Qué devolvemos?\n  return()\n}\n\n# Aplicamos la función solo con un argumento\nproducto(3)\n\n# Aplicamos la función con dos argumentos\nproducto(3, -7)\n# Definimos función\nfuncion_producto <- function(x, y = x) {\n  \n  # Multiplicamos\n  producto <- x * y\n  \n  # Devolvemos la salida\n  return(producto)\n}\n\n# Aplicamos la función\nfuncion_producto(3) # por defecto x = 3, y = 3## [1] 9\nfuncion_producto(3, -7)## [1] -21\n# Distinguiendo mayúsculas\nigualdad_nombres <- function(persona_1, persona_2) {\n  \n  return(persona_1 == persona_2)\n}\nigualdad_nombres(\"Javi\", \"javi\")## [1] FALSE\nigualdad_nombres(\"Javi\", \"Lucía\")## [1] FALSE\n# Sin importar mayúsculas\nigualdad_nombres <- function(persona_1, persona_2) {\n  \n  return(toupper(persona_1) == toupper(persona_2))\n}\nigualdad_nombres(\"Javi\", \"javi\")## [1] TRUE\nigualdad_nombres(\"Javi\", \"Lucía\")## [1] FALSE\n2 %% 2 # par, resto 0## [1] 0\n3 %% 2 # impar, resto 1## [1] 1\n# Definimos función\npares <- function(x, y) {\n  \n  # Sumamos\n  suma <- x + y\n  \n  # Comprobamos si es par\n  par <- suma %% 2 == 0\n  \n  # Devolvemos la salida\n  return(par)\n}\n\n# Aplicamos la función\npares(1, 3) # suma 4 (par)## [1] TRUE\npares(2, 7) # suma 9 (impar)## [1] FALSE"},{"path":"listas.html","id":"listas","chapter":"Capítulo 14 Listas","heading":"Capítulo 14 Listas","text":"Scripts usados:script10.R: listas. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script10.RHasta ahora hemos hecho un resumen de los elementos básicos de R:vectores: colección de elementos de igual tipo. Recuerda que un elemento individual, por ejemplo x <- 1, es en realidad un vector (de longitud 1). Pueden ser números, caracteres, fechas o valores lógicos, entre otros.vectores: colección de elementos de igual tipo. Recuerda que un elemento individual, por ejemplo x <- 1, es en realidad un vector (de longitud 1). Pueden ser números, caracteres, fechas o valores lógicos, entre otros.matrices: colección BIDIMENSIONAL de elementos de igual tipo e igual longitud.matrices: colección BIDIMENSIONAL de elementos de igual tipo e igual longitud.data.frame: colección BIDIMENSIONAL de elementos de igual longitud pero de cualquier tipo, lo más parecido lo que conocemos como una tabla en Excel.data.frame: colección BIDIMENSIONAL de elementos de igual longitud pero de cualquier tipo, lo más parecido lo que conocemos como una tabla en Excel.Además hemos visto una serie de herramientas para tratar esos datos:estructuras condicionalesif-elsebucles para repetir trozos de código.organizar el código en proyectos para facilitar nuestro trabajoimportar/exportar datosfuncionesCon todos estos ingredientes estamos preparados/para ver el que probablemente sea el tipo de dato más importante en R: las listas.Las listas son colecciones de variables de diferente tipo pero que pueden ser también de diferente longitud, con estructuras totalmente heterógeneas, de ahí que sea el formato de salida de muchísimas funciones de R que te devuelven la vez un cadena de texto, un vector de números o una tabla, todo guardado en la misma variable (incluso una lista puede tener dentro su vez otra lista).Vamos crear nuestra primera lista con tres elementos: el nombre de nuestros padres/madres, nuestro lugar de nacimiento y edades de nuestros hermanos.Si observas el objeto que hemos definido como lista, su longitud del objeto es de 3: tenemos guardados tres elementosun vector de caracteres (de longitud 2)un caracter (vector de longitud 1)un vector de números (de longitud 3)Tenemos guardados elementos de distinto tipo (algo que ya podíamos con los data.frame pero de longitudes dispares).Para acceder un elemento de la lista tenemos dos opciones:Acceder por índice: con el operador [[]] accedemos al elemento -ésimo de la lista.Acceder por índice: con el operador [[]] accedemos al elemento -ésimo de la lista.Acceder por nombre: con el operador $nombre_elemento accedemos al elemento por su nombreAcceder por nombre: con el operador $nombre_elemento accedemos al elemento por su nombreDada su heterogeneidad y flexibilidad, para acceder un elemento particular, las listas tienen una forma peculiar de acceder (con el corchete doble, en contraposición con el corchete simple que nos permite acceder varios elementos la vez)Las listas nos dan tanta flexibilidad que es el formato de dato natural para guardar datos que están estructurados, como pueden ser los datos almacenados en el registro de una persona.Vamos definir, por ejemplo, los datos que tendría un instituto de un alumno.nacimiento: una fecha.notas_insti: un data.frame.teléfonos: vector de números.nombre_padres: vector de texto.Hemos creado una lista algo más compleja de 4 elementos, los cuales podemos acceder por índice o nombre.Como hemos comentado, también podemos aplicar la recursividad y hacer listas con otras listas dentro, de forma que para acceder cada nivel deberemos usar el operador [[]].¡Nos permiten guardar «datos n-dimensionales»!.Es un formato muy habitual para devolver argumentos en funciones. Imagina que la función igualdad_nombres que hemos definido en el Ejercicio 4Vamos reescribirla haciendo que devuelva solo si es igual o distinto, sino que devuelva los dos nombres de entrada. Al ser un tipo de distinto de dato (una variable lógica, y un vector de longitud de caracteres), lo más práctico es devolverlo en forma de lista. WARNING: operaciones aritméticas con listasUna lista se puede vectorizar de forma inmediata, por lo cualquier operación aritmética aplicada una lista dará error (para ello está disponible la función lapply(), cuyo uso corresponde otros cursos más avanzados). ","code":"\nvariable_1 <- c(\"Paloma\", \"Gregorio\")\nvariable_2 <- \"Madrid\"\nvariable_3 <- c(25, 30, 26)\n\nlista <- list(\"progenitores\" = variable_1,\n              \"lugar_nacimiento\" = variable_2,\n              \"edades_hermanos\" = variable_3)\nlista## $progenitores\n## [1] \"Paloma\"   \"Gregorio\"\n## \n## $lugar_nacimiento\n## [1] \"Madrid\"\n## \n## $edades_hermanos\n## [1] 25 30 26\nlength(lista)## [1] 3\ndim(lista) # devolverá NULL al no tener dos dimensiones## NULL\nlength(lista)## [1] 3\nclass(lista) # de tipo lista## [1] \"list\"\n# Accedemos por índice\nlista[[1]]## [1] \"Paloma\"   \"Gregorio\"\n# Accedemos por nombre\nlista$progenitores## [1] \"Paloma\"   \"Gregorio\"\n# Varios elementos\nlista[1:2]## $progenitores\n## [1] \"Paloma\"   \"Gregorio\"\n## \n## $lugar_nacimiento\n## [1] \"Madrid\"\n# Fecha de nacimiento\nfecha_nacimiento <- as.Date(\"1989-09-10\")\n\n# Notas de asignaturas en primer y segundo parcial\nnotas <- data.frame(\"biología\" = c(5, 7), \"física\" = c(4, 5),\n                    \"matemáticas\" = c(8, 9.5))\nrow.names(notas) <- # Nombre a las filas\n  c(\"primer_parcial\", \"segundo_parcial\")\n\n# Números de teléfono\ntlf <- c(\"914719567\", \"617920765\", \"716505013\")\n\n# Nombres\npadres <- c(\"Juan\", \"Julia\")\n\n# Guardamos TODO en una lista (con nombres de cada elemento)\ndatos <- list(\"nacimiento\" = fecha_nacimiento,\n              \"notas_insti\" = notas, \"teléfonos\" = tlf,\n              \"nombre_padres\" = padres)\ndatos## $nacimiento\n## [1] \"1989-09-10\"\n## \n## $notas_insti\n##                 biología física matemáticas\n## primer_parcial         5      4         8.0\n## segundo_parcial        7      5         9.5\n## \n## $teléfonos\n## [1] \"914719567\" \"617920765\" \"716505013\"\n## \n## $nombre_padres\n## [1] \"Juan\"  \"Julia\"\nnames(datos)## [1] \"nacimiento\"    \"notas_insti\"   \"teléfonos\"     \"nombre_padres\"\nlength(datos)## [1] 4\ndatos[[1]]## [1] \"1989-09-10\"\ndatos$nacimiento## [1] \"1989-09-10\"\ndatos[[2]]##                 biología física matemáticas\n## primer_parcial         5      4         8.0\n## segundo_parcial        7      5         9.5\ndatos$notas_insti##                 biología física matemáticas\n## primer_parcial         5      4         8.0\n## segundo_parcial        7      5         9.5\nlista_de_listas <- list(\"lista_1\" = datos[3:4], \"lista_2\" = datos[1:2])\nnames(lista_de_listas) # Nombres de los elementos del primer nivel## [1] \"lista_1\" \"lista_2\"\nnames(lista_de_listas[[1]]) # Nombres de los elementos guardados en el primer elemento, que es a su vez una lista## [1] \"teléfonos\"     \"nombre_padres\"\nlista_de_listas[[1]][[1]] # Elemento 1 de la lista guardada como elemento 1 de la lista superior## [1] \"914719567\" \"617920765\" \"716505013\"\n# Sin importar mayúsculas\nigualdad_nombres <- function(persona_1, persona_2) {\n  \n  return(toupper(persona_1) == toupper(persona_2))\n}\nigualdad_nombres(\"Javi\", \"javi\")## [1] TRUE\nigualdad_nombres(\"Javi\", \"Lucía\")## [1] FALSE\n# Sin importar mayúsculas\nigualdad_nombres <- function(persona_1, persona_2) {\n  \n  return(list(\"son_iguales\" = toupper(persona_1) == toupper(persona_2),\n              \"nombres\" = c(persona_1, persona_2)))\n}\nresultado <- igualdad_nombres(\"Javi\", \"Lucía\")\nresultado$son_iguales## [1] FALSE\nresultado$nombres## [1] \"Javi\"  \"Lucía\"\ndatos <- list(\"a\" = 1:5, \"b\" = 10:20)\ndatos / 2## Error in datos/2: argumento no-numérico para operador binario\nlapply(datos, FUN = function(x) { x / 2})## $a\n## [1] 0.5 1.0 1.5 2.0 2.5\n## \n## $b\n##  [1]  5.0  5.5  6.0  6.5  7.0  7.5  8.0  8.5  9.0  9.5 10.0"},{"path":"listas.html","id":"ejercicios-8","chapter":"Capítulo 14 Listas","heading":"14.1 📝 Ejercicios","text":"Ejercicio 1: define una lista de 4 elementos de tipos distintos y accede al segundo de ellos (yo incluiré uno que sea un data.frame para que veas que en una lista cabe de todo).Solución: Ejercicio 2: accede los elementos que ocupan los lugares 1 y 4 de la lista definida anteriormente.Solución:Otra opción es acceder con los nombres Ejercicio 3: define una lista de 4 elementos que contenga, en una sola variable, tu nombre, apellido, edad y si estás soltero/.Solución:","code":"\n# Ejemplo: lista con texto, numérico, lógico y un data.frame\nlista_ejemplo <- list(\"nombre\" = \"Javier\", \"cp\" = 28019,\n                      \"soltero\" = TRUE,\n                      \"notas\" = data.frame(\"mates\" = c(7.5, 8, 9),\n                                           \"lengua\" = c(10, 5, 6)))\nlista_ejemplo## $nombre\n## [1] \"Javier\"\n## \n## $cp\n## [1] 28019\n## \n## $soltero\n## [1] TRUE\n## \n## $notas\n##   mates lengua\n## 1   7.5     10\n## 2   8.0      5\n## 3   9.0      6\n# Longitud\nlength(lista_ejemplo)## [1] 4\n# Accedemos al elemento dos\nlista_ejemplo[[2]]## [1] 28019\n# Accedemos al 1 y al 4\nlista_ejemplo[c(1, 4)]## $nombre\n## [1] \"Javier\"\n## \n## $notas\n##   mates lengua\n## 1   7.5     10\n## 2   8.0      5\n## 3   9.0      6\n# Accedemos al 1 y al 4\nlista_ejemplo$nombre## [1] \"Javier\"\nlista_ejemplo$notas##   mates lengua\n## 1   7.5     10\n## 2   8.0      5\n## 3   9.0      6\nlista_ejemplo[c(\"nombre\", \"notas\")]## $nombre\n## [1] \"Javier\"\n## \n## $notas\n##   mates lengua\n## 1   7.5     10\n## 2   8.0      5\n## 3   9.0      6\nlibrary(lubridate)\n# Creamos lista: con lubridate calculamos la diferencia de años desde la fecha de nuestro nacimiento hasta hoy (sea cuando sea hoy)\nlista_personal <- list(\"nombre\" = \"Javier\",\n                       \"apellidos\" = \"Álvarez Liébana\",\n                       \"edad\" = 32,\n                       \"soltero\" = TRUE)\nlista_personal## $nombre\n## [1] \"Javier\"\n## \n## $apellidos\n## [1] \"Álvarez Liébana\"\n## \n## $edad\n## [1] 32\n## \n## $soltero\n## [1] TRUE"},{"path":"tidydata.html","id":"tidydata","chapter":"Capítulo 15 Tidy data: datos ordenadicos","heading":"Capítulo 15 Tidy data: datos ordenadicos","text":"Empieza lo interesante :)\nImagen/gráfica 15.1: Flujo deseable de datos según Hadley Wickham, extraída de https://r4ds..co.nz/wrangle-intro.html\nFíjate bien en el anterior flujo de trabajo: aunque el objetivo de este manual es muy introductorio, y vamos profundizar excesivamente en ninguna de las etapas, vamos intentar tener unas nociones básicas para preparar y manejar los datos.El primero de los pasos, la importación de datos, la hemos revisado de forma superficial en la Sección 16, pero nos bastará con lo aprendido para poder empezar manipular datos. Antes de pasar al segundo paso, la limpieza de los datos, vamos repasar los tipos de datos que hemos hasta ahora.","code":""},{"path":"tidydata.html","id":"repaso_datos","chapter":"Capítulo 15 Tidy data: datos ordenadicos","heading":"15.1 Repaso: tipos de datos","text":"¿Existen más tipos de datos de los que ya conocemos?La respuesta te la estarás imaginando: sí. De hecho es solo que existan más sino que puedes crear tus propios tipos de datos, pero seguramente acabarán siendo, en su nivel más profundo, una combinación de alguna de las estructuras que ya conocemos. El objetivo de este curso es empezar ser autónomo/en el análisis de datos, pero es un curso profundo de R, así que (de momento) vamos quedarnos como estamos. GLOSARIO:Si es importante entender las diferencias entre los datos que ya hemos definido.Vectores: es el tipo de dato más simple, una colección de valores PERO DEL MISMO TIPO. Los vectores pueden ser de longitud 1 (valores individuales secas), una colección de números, una colección de cadenas de texto o una colección de valores lógicos (pudiendo tener dentro datos ausentes, o valores especiales como Inf o NaN)Vectores: es el tipo de dato más simple, una colección de valores PERO DEL MISMO TIPO. Los vectores pueden ser de longitud 1 (valores individuales secas), una colección de números, una colección de cadenas de texto o una colección de valores lógicos (pudiendo tener dentro datos ausentes, o valores especiales como Inf o NaN)Matrices: se pueden entender como una especie de colección de vectores, una colección de colecciones, un tipo de dato BIDIMENSIONAL. Una matriz se conforma de filas y columnas pero, de nuevo, LOS DATOS DEBEN SER DEL MISMO TIPO, y los vectores concatenados que forma las filas y/o columnas DEBEN TENER LA MISMA LONGITUD.Matrices: se pueden entender como una especie de colección de vectores, una colección de colecciones, un tipo de dato BIDIMENSIONAL. Una matriz se conforma de filas y columnas pero, de nuevo, LOS DATOS DEBEN SER DEL MISMO TIPO, y los vectores concatenados que forma las filas y/o columnas DEBEN TENER LA MISMA LONGITUD.data,frame: son datos estructurados, lo que comunmente conocemos como «tablas». diferencia de las matrices, aunque deben SEGUIR TENIENDO LA MISMA LONGITUD, las variables que lo conforman pueden ser de TIPOS DIFERENTES, puediendo tener el mismo conjunto de datos numéricos, caracteres, lógicos, etc.\ndata,frame: son datos estructurados, lo que comunmente conocemos como «tablas». diferencia de las matrices, aunque deben SEGUIR TENIENDO LA MISMA LONGITUD, las variables que lo conforman pueden ser de TIPOS DIFERENTES, puediendo tener el mismo conjunto de datos numéricos, caracteres, lógicos, etc.Listas: las listas son una concatenación de elementos, secas, de forma que nos permite concatenar cualquier tipo de dato anterior, pudiendo ser de DIFERENTE LONGITUD Y DIFERENTE TIPO.\nListas: las listas son una concatenación de elementos, secas, de forma que nos permite concatenar cualquier tipo de dato anterior, pudiendo ser de DIFERENTE LONGITUD Y DIFERENTE TIPO. WARNING: cuidado con las listasComo hemos mencionado, una lista se puede vectorizar de forma inmediata, por lo cualquier operación aritmética aplicada una lista dará error. Para poder operar con ellas tenemos una opción que es aplicar la función lapply(), o directamente acudir al paquete purrr (te animo investigar en dicho paquete pero se escapa de los objetivos del curso).","code":""},{"path":"tidydata.html","id":"tibble","chapter":"Capítulo 15 Tidy data: datos ordenadicos","heading":"15.2 Mejorando los data.frame: tibble","text":"Antes de ordenar, limpiar y procesar nuestros datos, vamos ver un tipo de dato que quizás hayamos mencionado por encima: las tablas tibble. Los datos en formato tibble (del paquete tibble) son un tipo de data.frame mejorado, para una gestión más ágil, eficiente y coherente. Las tablas en formato tibble (su clase será tbl_df) tiene 4 ventajas principales frente los ya vistos data.frame:Permite imprimir por consola la tabla con mayor información de las variables, y solo imprime por defecto las primeras filas (todas si son 20 o menos, 10 si son más de 20 filas).Puedes imprimir las filas y columnas que quieras con print(), pero por defecto te aseguras de saturar la consola.Mantiene la integridad de los datos (cambia los tipos de las variables y hace una carga de datos inteligente, interpretando las fechas como tal).Mantiene la integridad de los datos (cambia los tipos de las variables y hace una carga de datos inteligente, interpretando las fechas como tal).La función tibble() construye las variables secuencialmente, pudiendo hacer uso en la propia definición de variables recién definidas en dicha definición.La función tibble() construye las variables secuencialmente, pudiendo hacer uso en la propia definición de variables recién definidas en dicha definición.Si accedes una columna que existe avisa con un warning.solo te cambiará el tipo de datos sino que te cambiará el nombre de las variables (los data.frame transforma los caracteres que sean letras).Realiza una carga de los datos más ágil Puedes consultar más funcionalidades de dichos datos en https://tibble.tidyverse.org/.","code":"\nlibrary(tibble)\n\n# data.frame\ntabla_df <-\n  data.frame(\"x\" = 1:50,\n             \"y\" = rep(c(\"a\", \"b\", \"c\", \"d\", \"e\"), 10),\n             \"z\" = 11:60,\n             \"logica\" = rep(c(TRUE, TRUE, FALSE, TRUE, FALSE), 10))\ntabla_df##     x y  z logica\n## 1   1 a 11   TRUE\n## 2   2 b 12   TRUE\n## 3   3 c 13  FALSE\n## 4   4 d 14   TRUE\n## 5   5 e 15  FALSE\n## 6   6 a 16   TRUE\n## 7   7 b 17   TRUE\n## 8   8 c 18  FALSE\n## 9   9 d 19   TRUE\n## 10 10 e 20  FALSE\n## 11 11 a 21   TRUE\n## 12 12 b 22   TRUE\n## 13 13 c 23  FALSE\n## 14 14 d 24   TRUE\n## 15 15 e 25  FALSE\n## 16 16 a 26   TRUE\n## 17 17 b 27   TRUE\n## 18 18 c 28  FALSE\n## 19 19 d 29   TRUE\n## 20 20 e 30  FALSE\n## 21 21 a 31   TRUE\n## 22 22 b 32   TRUE\n## 23 23 c 33  FALSE\n## 24 24 d 34   TRUE\n## 25 25 e 35  FALSE\n## 26 26 a 36   TRUE\n## 27 27 b 37   TRUE\n## 28 28 c 38  FALSE\n## 29 29 d 39   TRUE\n## 30 30 e 40  FALSE\n## 31 31 a 41   TRUE\n## 32 32 b 42   TRUE\n## 33 33 c 43  FALSE\n## 34 34 d 44   TRUE\n## 35 35 e 45  FALSE\n## 36 36 a 46   TRUE\n## 37 37 b 47   TRUE\n## 38 38 c 48  FALSE\n## 39 39 d 49   TRUE\n## 40 40 e 50  FALSE\n## 41 41 a 51   TRUE\n## 42 42 b 52   TRUE\n## 43 43 c 53  FALSE\n## 44 44 d 54   TRUE\n## 45 45 e 55  FALSE\n## 46 46 a 56   TRUE\n## 47 47 b 57   TRUE\n## 48 48 c 58  FALSE\n## 49 49 d 59   TRUE\n## 50 50 e 60  FALSE\n# tibble\ntabla_tb <- tibble(\"x\" = 1:50,\n             \"y\" = rep(c(\"a\", \"b\", \"c\", \"d\", \"e\"), 10),\n             \"z\" = 11:60,\n             \"logica\" = rep(c(TRUE, TRUE, FALSE, TRUE, FALSE), 10))\ntabla_tb## # A tibble: 50 × 4\n##        x y         z logica\n##    <int> <chr> <int> <lgl> \n##  1     1 a        11 TRUE  \n##  2     2 b        12 TRUE  \n##  3     3 c        13 FALSE \n##  4     4 d        14 TRUE  \n##  5     5 e        15 FALSE \n##  6     6 a        16 TRUE  \n##  7     7 b        17 TRUE  \n##  8     8 c        18 FALSE \n##  9     9 d        19 TRUE  \n## 10    10 e        20 FALSE \n## # … with 40 more rows\nprint(tabla_tb, n = 13, width = Inf)## # A tibble: 50 × 4\n##        x y         z logica\n##    <int> <chr> <int> <lgl> \n##  1     1 a        11 TRUE  \n##  2     2 b        12 TRUE  \n##  3     3 c        13 FALSE \n##  4     4 d        14 TRUE  \n##  5     5 e        15 FALSE \n##  6     6 a        16 TRUE  \n##  7     7 b        17 TRUE  \n##  8     8 c        18 FALSE \n##  9     9 d        19 TRUE  \n## 10    10 e        20 FALSE \n## 11    11 a        21 TRUE  \n## 12    12 b        22 TRUE  \n## 13    13 c        23 FALSE \n## # … with 37 more rows\n# data.frame\ndata.frame(\"x\" = 1:5,\n           \"y\" = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n           \"z\" = 11:15,\n           \"logica\" = c(TRUE, TRUE, FALSE, TRUE, FALSE),\n           \"x*z\" = x * z)##   x y  z logica x.z\n## 1 1 a 11   TRUE   4\n## 2 2 b 12   TRUE   5\n## 3 3 c 13  FALSE   3\n## 4 4 d 14   TRUE   2\n## 5 5 e 15  FALSE  74\n# tibble\ntibble(\"x\" = 1:5,\n       \"y\" = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n       \"z\" = 11:15,\n       \"logica\" = c(TRUE, TRUE, FALSE, TRUE, FALSE),\n       \"x*z\" = x * z)## # A tibble: 5 × 5\n##       x y         z logica `x*z`\n##   <int> <chr> <int> <lgl>  <int>\n## 1     1 a        11 TRUE      11\n## 2     2 b        12 TRUE      24\n## 3     3 c        13 FALSE     39\n## 4     4 d        14 TRUE      56\n## 5     5 e        15 FALSE     75\n# data.frame\ntabla_df$variable_inexistente## NULL\n# tibble\ntabla_tb$variable_inexistente## Warning: Unknown or uninitialised column: `variable_inexistente`.## NULL\n# data.frame\ndata.frame(\":)\" = \"emoticono\", \" \" = \"en blanco\", \"2000\" = \"número\")##         X..        X.  X2000\n## 1 emoticono en blanco número\n# tibble\ntibble(\":)\" = \"emoticono\", \" \" = \"en blanco\", \"2000\" = \"número\")## # A tibble: 1 × 3\n##   `:)`      ` `       `2000`\n##   <chr>     <chr>     <chr> \n## 1 emoticono en blanco número\nlibrary(microbenchmark)\nlibrary(readr)\n\nruta <- \"./DATOS/datos_ES.csv\"\n\n# Comparamos read_csv (tibble) con read.csv (data.frame)\nmicrobenchmark(read_csv(file = ruta), read.csv(file = ruta), times = 10)## Unit: milliseconds\n##                   expr       min        lq     mean    median        uq\n##  read_csv(file = ruta) 57.088768 58.467769 85.61861 60.828409 68.128097\n##  read.csv(file = ruta)  5.772678  5.945846  7.22262  6.319473  6.870345\n##        max neval cld\n##  285.41842    10   b\n##   11.70318    10  a"},{"path":"tidydata.html","id":"tidy","chapter":"Capítulo 15 Tidy data: datos ordenadicos","heading":"15.3 Tidy data vs messy data","text":"Tidy datasets alike, every messy dataset messy way (Hadley Wickham, Chief Scientist en RStudio)Hasta ahora solo le hemos dado importancia al «qué» pero al «cómo» manejamos los datos. La organización de nuestros datos es fundamental para que la preparación y explotación de los datos sea lo más eficiente posible: la limpieza y preprocesamiento puede llevarnos hasta el 80% del tiempo en nuestro análisis si se hace forma correcta (Dasu Johnson 2003).El concepto tidy data fue introducido por Hadley Wickham (Wickham 2014) como objetivo del entorno de paquetes que posteriormente se fueron desarrollando en el entorno tidyverse. Los conjuntos tidy o datos ordenados tienen tres objetivosEstandarización en su estructura.Sencillez en su manipulación.Listos para ser modelizados y visualizados.Para ello, los datos ordenados o tidy data deben cumplir:Cada variable en una columna.Cada observación/registro/individuo en una fila diferente.Cada celda con un único valor.Cada conjunto o unidad observacional conforma una tabla.Si contamos con múltiples tablas, debemos tener una columna común en cada una que nos permita cruzarlas.\nImagen/gráfica 15.2: Infografía con datos ordenados (tidy data) extraída de https://r4ds..co.nz/tidy-data.html\nLo contrario lo llamaremos datos desordenados o messy data. Para trabajar con los datos vamos cargar tidyverse, un entorno de paquetes para el manejo de datos (ver más detalles en Transformando los datos: incursión al universo tidyverse).","code":"\ninstall.packages(\"tidyverse\") # SOLO la primera vez\nlibrary(tidyverse)"},{"path":"tidydata.html","id":"messy-data-valores-en-columnas-en-lugar-de-variables","chapter":"Capítulo 15 Tidy data: datos ordenadicos","heading":"15.3.1 Messy data: valores en columnas en lugar de variables","text":"Vamos visualizar la tabla table4a del paquete tidyr (que ya lo tenemos cargado del entorno tidyverse).Si te fijas, tenemos una columna country, representando una variable con el nombre de los países, ¡pero las otras columnas representan cada una una sola variable! Ambas son la misma variable, solo que medida en años distintos (que debería ser su vez otra variable): cada fila está representando dos observaciones (1999, 2000) en lugar de un solo registro. Lo que haremos será incluir una nueva columna llamada year que nos marque el año y otra values que nos diga el valor de la variable de interés en cada uno de esos años.Con la función pivot_longer del mencionada paquete le indicaremos lo siguiente:cols: el nombre de las columnas que vamos pivotar (con comillas porque son números, texto como nombre).names_to: el nombre de la columna la que vamos mandar los valores que figuran ahora en los nombres de las columnas.values_to: el nombre de la columna la que vamos mandar los valores.Ahora tenemos un registro por fila, una variable por columna y cada celda representa un único valor. Este ejemplo de messy data lo podemos encontrar muy menudo cuando construimos rangos de variables pensando que es mejor tener una tabla más compacta (alargar la tabla lo ancho en lugar de lo largo). Es el caso de la tabla relig_income.Salvo la primera, el resto de columnas tienen como nombre los valores de una variable en sí misma (ingresos). Para ordenar los datos vamos razonar de la misma manera solo que ahora, en lugar de indicarle el nombre de todas las columnas que queremos usar de entrada, vamos indicarle de forma más corta la columna que queremos seleccionar.Lo que hacemos con pivot_longer() es «ampliar» la tabla, haciéndola más larga (más filas) pero con menos columnas.","code":"\ntable4a## # A tibble: 3 × 3\n##   country     `1999` `2000`\n## * <chr>        <int>  <int>\n## 1 Afghanistan    745   2666\n## 2 Brazil       37737  80488\n## 3 China       212258 213766\ntable4a %>% pivot_longer(cols = c(\"1999\", \"2000\"),\n                         names_to = \"year\",\n                         values_to = \"values\")## # A tibble: 6 × 3\n##   country     year  values\n##   <chr>       <chr>  <int>\n## 1 Afghanistan 1999     745\n## 2 Afghanistan 2000    2666\n## 3 Brazil      1999   37737\n## 4 Brazil      2000   80488\n## 5 China       1999  212258\n## 6 China       2000  213766\nrelig_income## # A tibble: 18 × 11\n##    religion `<$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\n##    <chr>      <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>      <dbl>\n##  1 Agnostic      27        34        60        81        76       137        122\n##  2 Atheist       12        27        37        52        35        70         73\n##  3 Buddhist      27        21        30        34        33        58         62\n##  4 Catholic     418       617       732       670       638      1116        949\n##  5 Don’t k…      15        14        15        11        10        35         21\n##  6 Evangel…     575       869      1064       982       881      1486        949\n##  7 Hindu          1         9         7         9        11        34         47\n##  8 Histori…     228       244       236       238       197       223        131\n##  9 Jehovah…      20        27        24        24        21        30         15\n## 10 Jewish        19        19        25        25        30        95         69\n## 11 Mainlin…     289       495       619       655       651      1107        939\n## 12 Mormon        29        40        48        51        56       112         85\n## 13 Muslim         6         7         9        10         9        23         16\n## 14 Orthodox      13        17        23        32        32        47         38\n## 15 Other C…       9         7        11        13        13        14         18\n## 16 Other F…      20        33        40        46        49        63         46\n## 17 Other W…       5         2         3         4         2         7          3\n## 18 Unaffil…     217       299       374       365       341       528        407\n## # … with 3 more variables: $100-150k <dbl>, >150k <dbl>,\n## #   Don't know/refused <dbl>\n# No necesitamos las comillas en el nombre de columnas salvo que tengan caracteres que no sean letras\nrelig_income %>% pivot_longer(-religion, names_to = \"ingresos\",\n                              values_to = \"frecuencia\")## # A tibble: 180 × 3\n##    religion ingresos           frecuencia\n##    <chr>    <chr>                   <dbl>\n##  1 Agnostic <$10k                      27\n##  2 Agnostic $10-20k                    34\n##  3 Agnostic $20-30k                    60\n##  4 Agnostic $30-40k                    81\n##  5 Agnostic $40-50k                    76\n##  6 Agnostic $50-75k                   137\n##  7 Agnostic $75-100k                  122\n##  8 Agnostic $100-150k                 109\n##  9 Agnostic >150k                      84\n## 10 Agnostic Don't know/refused         96\n## # … with 170 more rows"},{"path":"tidydata.html","id":"messy-data-una-observación-guardada-en-varias-filas","chapter":"Capítulo 15 Tidy data: datos ordenadicos","heading":"15.3.2 Messy data: una observación guardada en varias filas","text":"Vamos visualizar ahora la tabla table2 del paquete tidyr.Fíjate en las cuatro primeras filas: los registros con el mismo año deberían ser el mismo, es la misma información, debería estar en la misma fila, pero está dividada en dos. Por un lado una fila para la variable cases y otra para population. Lo que haremos será lo opuesto antes: con pivot_wider() «ampliaremos» la tabla lo ancho, haciéndola menos (menos filas) pero con más columnas.names_from: el nombre de la columna de la que vamos sacar las nuevas columnas que vamos crear (cases y population).values_from: el nombre de la columna de la que vamos sacar los valores.Ahora tenemos cada registro en una fila, que nos indica país-año-casos-población.","code":"\ntable2## # A tibble: 12 × 4\n##    country      year type            count\n##    <chr>       <int> <chr>           <int>\n##  1 Afghanistan  1999 cases             745\n##  2 Afghanistan  1999 population   19987071\n##  3 Afghanistan  2000 cases            2666\n##  4 Afghanistan  2000 population   20595360\n##  5 Brazil       1999 cases           37737\n##  6 Brazil       1999 population  172006362\n##  7 Brazil       2000 cases           80488\n##  8 Brazil       2000 population  174504898\n##  9 China        1999 cases          212258\n## 10 China        1999 population 1272915272\n## 11 China        2000 cases          213766\n## 12 China        2000 population 1280428583\ntable2 %>% pivot_wider(names_from = type, values_from = count)## # A tibble: 6 × 4\n##   country      year  cases population\n##   <chr>       <int>  <int>      <int>\n## 1 Afghanistan  1999    745   19987071\n## 2 Afghanistan  2000   2666   20595360\n## 3 Brazil       1999  37737  172006362\n## 4 Brazil       2000  80488  174504898\n## 5 China        1999 212258 1272915272\n## 6 China        2000 213766 1280428583"},{"path":"tidydata.html","id":"messy-data-una-celda-con-múltiples-valores","chapter":"Capítulo 15 Tidy data: datos ordenadicos","heading":"15.3.3 Messy data: una celda con múltiples valores","text":"Por último vamos visualizar la tabla table3 del paquete tidyr.En la variable rate hay guardados dos valores, separados por /, lo que hace que en una celda tiene un único valor sino dos. La función separate() del paquete tidyr nos permitirá separar los múltiples valores de la columnarate simplemente indicándole el nombre de las nuevas columnas en el argumento = ..., creando una nueva columna para cada uno de ellos.Por defecto lo que hace es localizar como separador cualquier caracter que sea alfa-numérico. Si queremos un caracter concreto para dividir podemos indicárselo explícitamenteSi usas un separador que está en los datos te devolverá dichas columnas vacías ya que ha podido dividirlas.De la misma manera que podemos separar columnas también podemos unirlas. Para ello vamos usar la tabla table5 del ya mencionado paquete. Con la función unite() vamos unir el siglo (en century) y el año (en year), y al inicio le indicaremos como se llamará la nueva variable (año_completo).Como pasaba en separate(), tiene un argumento de separador por defecto, en este caso sep = \"_\". Si queremos cambiarlo podemos hacerlo indicándoselo explícitamente.","code":"\ntable3## # A tibble: 6 × 3\n##   country      year rate             \n## * <chr>       <int> <chr>            \n## 1 Afghanistan  1999 745/19987071     \n## 2 Afghanistan  2000 2666/20595360    \n## 3 Brazil       1999 37737/172006362  \n## 4 Brazil       2000 80488/174504898  \n## 5 China        1999 212258/1272915272\n## 6 China        2000 213766/1280428583\ntable3 %>% separate(rate, into = c(\"cases\", \"population\"))## # A tibble: 6 × 4\n##   country      year cases  population\n##   <chr>       <int> <chr>  <chr>     \n## 1 Afghanistan  1999 745    19987071  \n## 2 Afghanistan  2000 2666   20595360  \n## 3 Brazil       1999 37737  172006362 \n## 4 Brazil       2000 80488  174504898 \n## 5 China        1999 212258 1272915272\n## 6 China        2000 213766 1280428583\ntable3 %>% separate(rate, into = c(\"cases\", \"population\"), sep = \"/\")## # A tibble: 6 × 4\n##   country      year cases  population\n##   <chr>       <int> <chr>  <chr>     \n## 1 Afghanistan  1999 745    19987071  \n## 2 Afghanistan  2000 2666   20595360  \n## 3 Brazil       1999 37737  172006362 \n## 4 Brazil       2000 80488  174504898 \n## 5 China        1999 212258 1272915272\n## 6 China        2000 213766 1280428583\ntable3 %>% separate(rate, into = c(\"cases\", \"population\"), sep = \".\")## Warning: Expected 2 pieces. Additional pieces discarded in 6 rows [1, 2, 3, 4,\n## 5, 6].## # A tibble: 6 × 4\n##   country      year cases population\n##   <chr>       <int> <chr> <chr>     \n## 1 Afghanistan  1999 \"\"    \"\"        \n## 2 Afghanistan  2000 \"\"    \"\"        \n## 3 Brazil       1999 \"\"    \"\"        \n## 4 Brazil       2000 \"\"    \"\"        \n## 5 China        1999 \"\"    \"\"        \n## 6 China        2000 \"\"    \"\"\ntable5 %>% unite(año_completo, century, year)## # A tibble: 6 × 3\n##   country     año_completo rate             \n##   <chr>       <chr>        <chr>            \n## 1 Afghanistan 19_99        745/19987071     \n## 2 Afghanistan 20_00        2666/20595360    \n## 3 Brazil      19_99        37737/172006362  \n## 4 Brazil      20_00        80488/174504898  \n## 5 China       19_99        212258/1272915272\n## 6 China       20_00        213766/1280428583\ntable5 %>%\n  unite(año_completo, century, year, sep = \"\")## # A tibble: 6 × 3\n##   country     año_completo rate             \n##   <chr>       <chr>        <chr>            \n## 1 Afghanistan 1999         745/19987071     \n## 2 Afghanistan 2000         2666/20595360    \n## 3 Brazil      1999         37737/172006362  \n## 4 Brazil      2000         80488/174504898  \n## 5 China       1999         212258/1272915272\n## 6 China       2000         213766/1280428583"},{"path":"tidydata.html","id":"consejos-9","chapter":"Capítulo 15 Tidy data: datos ordenadicos","heading":"15.4 Consejos","text":"CONSEJOS Convertir tibbleSi ya tienes un data.frame es altamente recomendable convertirlo tibble con as_tibble() Convertir variables al procesarUna opción muy útil que podemos usar al aplicar la separación de los múltiples valores es convertir los datos al tipo adecuado. Los datos unidos en rate eran caracteres ya que tenía el separador / (podían ser numéricos). Al separarlos, por defecto, aunque ahora ya son solo números, los separa como si fueran textos. Con convert = TRUE podemos indicarle que identifique el tipo de dato y lo convierta (fíjate en la cabecera de las columnas ahora).Dicha función también puede ser usada para dividir cifras, como por ejemplo el año","code":"\nas_tibble(tabla_df)## # A tibble: 50 × 4\n##        x y         z logica\n##    <int> <fct> <int> <lgl> \n##  1     1 a        11 TRUE  \n##  2     2 b        12 TRUE  \n##  3     3 c        13 FALSE \n##  4     4 d        14 TRUE  \n##  5     5 e        15 FALSE \n##  6     6 a        16 TRUE  \n##  7     7 b        17 TRUE  \n##  8     8 c        18 FALSE \n##  9     9 d        19 TRUE  \n## 10    10 e        20 FALSE \n## # … with 40 more rows\ntable3 %>% \n  separate(rate, into = c(\"cases\", \"population\"), convert = TRUE)## # A tibble: 6 × 4\n##   country      year  cases population\n##   <chr>       <int>  <int>      <int>\n## 1 Afghanistan  1999    745   19987071\n## 2 Afghanistan  2000   2666   20595360\n## 3 Brazil       1999  37737  172006362\n## 4 Brazil       2000  80488  174504898\n## 5 China        1999 212258 1272915272\n## 6 China        2000 213766 1280428583\ntable3 %>% separate(year,\n                    into = c(\"siglo\", \"año\"),\n                    sep = 2)## # A tibble: 6 × 4\n##   country     siglo año   rate             \n##   <chr>       <chr> <chr> <chr>            \n## 1 Afghanistan 19    99    745/19987071     \n## 2 Afghanistan 20    00    2666/20595360    \n## 3 Brazil      19    99    37737/172006362  \n## 4 Brazil      20    00    80488/174504898  \n## 5 China       19    99    212258/1272915272\n## 6 China       20    00    213766/1280428583"},{"path":"tidydata.html","id":"ejercicios-9","chapter":"Capítulo 15 Tidy data: datos ordenadicos","heading":"15.5 📝 Ejercicios","text":"(haz click en las flechas para ver soluciones)📝Ejercicio 1: ¿es el conjunto de datos datasets::anscombe (del paquete {datasets}) de tipo tibble? Solución:Recuerda que podemos cargar elementos de un paquete (en este caso {datasets}) cargando library(datasets) y luego el elemento, o bien datasets::anscombe (prefijo::nombre).La respuesta: . Tienes muchas formas de comprobarlo si imprimes el conjunto por defecto.Imprime por defecto todas las filas (tiene 32 filas, debería imprimir solo 10 si fuese un tibble, para saturar consola).especifica al imprimir que es de tipo tibble.especifica al imprimir el tipo de dato de las columnas.Imprime el nombre de las filas (el nombre de los modelos) como si fuera una variable (¡que existe!).Así debería de salir si fuera tibble. 📝Ejercicio 2: define un tibble con tres variables numéricas , b, c, tal que la tercera sea el producto de las dos primeras c = * b. Inténtalo hacer con un data.frameSolución:Un ejemplo:Si lo intentamos con un data.frame, intentará buscar una variable real que tengamos guardada que se llame y b, sin encontrarlas. 📝Ejercicio 3: define un tibble con tres variables de nombres variable, 2, tercera :), e intenta acceder ellas.Solución:Las variables solo con caracteres del alfabeto se podrán acceder sin necesidad de comillas.También se puede acceder por el orden que ocupan:Y también por el nombre entre corchetes (doble corchete extrae la variable fuera del tibble, corchete simple en formato tibble): 📝Ejercicio 4: convierte en tidy data el siguiente data.frame.Solución:El problema es que las dos columnas con nombres de año son en realidad valores que deberían pasar ser variables, así que deberíamos disminuir aplicar pivot_longer() 📝Ejercicio 5: convierte en tidy data el siguiente data.frame.Solución:El problema es que las filas que comparten año son el mismo registro (pero con dos características que tenemos divididas en dos filas), así que deberíamos disminuir aplicar pivot_wider() 📝Ejercicio 6: convierte en tidy data la tabla table5 del paquete tidyr.Solución:Primero uniremos el siglo y las dos últimas cifras del año para obtener el año completo (guardado en año)Tras ello deberemos separar el valor del ratio en denominador y numerador (ya que ahora hay dos valores en una celda), y convertiremos el tipo de dato en la salida para que sea número.","code":"\nmtcars##                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n## Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n## Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n## Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n## Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n## Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n## Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n## Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n## Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n## Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n## Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n## Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n## Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n## Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n## Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n## Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n## Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n## Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n## Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n## Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n## Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n## Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n## AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n## Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n## Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\n## Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n## Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n## Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n## Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n## Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n## Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n## Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\nclass(mtcars)## [1] \"data.frame\"\nas_tibble(mtcars)## # A tibble: 32 × 11\n##      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n##    <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n##  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n##  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n##  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n##  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n##  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n##  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n##  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n##  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n##  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n## 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n## # … with 22 more rows\nclass(as_tibble(mtcars))## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\ntibble(\"a\" = 1:7, \"b\" = 11:17, \"c\" = a * b)## # A tibble: 7 × 3\n##       a     b     c\n##   <int> <int> <int>\n## 1     1    11    11\n## 2     2    12    24\n## 3     3    13    39\n## 4     4    14    56\n## 5     5    15    75\n## 6     6    16    96\n## 7     7    17   119\ndata.frame(\"a\" = 1:7, \"b\" = 11:17, \"c\" = a * b)##   a  b   c\n## 1 1 11 -35\n## 2 2 12 -35\n## 3 3 13 -35\n## 4 4 14 -35\n## 5 5 15 -35\n## 6 6 16 -35\n## 7 7 17 -35\n# Definimos el tibble\ndatos_tb <- tibble(\"variable\" = 1:7, \"tercera falsa :)\" = 0,\n                   \"2\" = 11:17)\n\n# Accedemos a sus columnas\ndatos_tb$variable## [1] 1 2 3 4 5 6 7\ndatos_tb$`tercera falsa :)`## [1] 0 0 0 0 0 0 0\ndatos_tb$`2`## [1] 11 12 13 14 15 16 17\ndatos_tb[1]## # A tibble: 7 × 1\n##   variable\n##      <int>\n## 1        1\n## 2        2\n## 3        3\n## 4        4\n## 5        5\n## 6        6\n## 7        7\ndatos_tb[2]## # A tibble: 7 × 1\n##   `tercera falsa :)`\n##                <dbl>\n## 1                  0\n## 2                  0\n## 3                  0\n## 4                  0\n## 5                  0\n## 6                  0\n## 7                  0\ndatos_tb[3]## # A tibble: 7 × 1\n##     `2`\n##   <int>\n## 1    11\n## 2    12\n## 3    13\n## 4    14\n## 5    15\n## 6    16\n## 7    17\ndatos_tb[\"variable\"]## # A tibble: 7 × 1\n##   variable\n##      <int>\n## 1        1\n## 2        2\n## 3        3\n## 4        4\n## 5        5\n## 6        6\n## 7        7\ndatos_tb[[\"variable\"]]## [1] 1 2 3 4 5 6 7\ndatos_tb[\"tercera falsa :)\"]## # A tibble: 7 × 1\n##   `tercera falsa :)`\n##                <dbl>\n## 1                  0\n## 2                  0\n## 3                  0\n## 4                  0\n## 5                  0\n## 6                  0\n## 7                  0\ndatos_tb[\"2\"]## # A tibble: 7 × 1\n##     `2`\n##   <int>\n## 1    11\n## 2    12\n## 3    13\n## 4    14\n## 5    15\n## 6    16\n## 7    17\ntabla_tb <- tibble(\"trimestre\" = c(\"T1\", \"T2\", \"T3\"),\n                   \"2020\" = c(10, 12, 7.5),\n                   \"2021\" = c(8, 0, 9))\n# Aplicamos pivot_longer\ntabla_tb %>% pivot_longer(cols = c(\"2020\", \"2021\"),\n                          names_to = \"año\", values_to = \"valores\")## # A tibble: 6 × 3\n##   trimestre año   valores\n##   <chr>     <chr>   <dbl>\n## 1 T1        2020     10  \n## 2 T1        2021      8  \n## 3 T2        2020     12  \n## 4 T2        2021      0  \n## 5 T3        2020      7.5\n## 6 T3        2021      9\ntabla_tb <- tibble(\"año\" = c(2019, 2019, 2020, 2020, 2021, 2021),\n                   \"variable\" = c(\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"),\n                   \"valor\" = c(10, 9383, 7.58, 10839, 9, 32949))\n# Aplicamos pivot_wider\ntabla_tb %>% pivot_wider(names_from = \"variable\", values_from = \"valor\")## # A tibble: 3 × 3\n##     año     A     B\n##   <dbl> <dbl> <dbl>\n## 1  2019 10     9383\n## 2  2020  7.58 10839\n## 3  2021  9    32949\ntable5 %>%\n  unite(año, century, year, sep = \"\")## # A tibble: 6 × 3\n##   country     año   rate             \n##   <chr>       <chr> <chr>            \n## 1 Afghanistan 1999  745/19987071     \n## 2 Afghanistan 2000  2666/20595360    \n## 3 Brazil      1999  37737/172006362  \n## 4 Brazil      2000  80488/174504898  \n## 5 China       1999  212258/1272915272\n## 6 China       2000  213766/1280428583\ntable5 %>%\n  unite(año, century, year, sep = \"\") %>%\n  separate(rate, c(\"numerador\", \"denominador\"), convert = TRUE)## # A tibble: 6 × 4\n##   country     año   numerador denominador\n##   <chr>       <chr>     <int>       <int>\n## 1 Afghanistan 1999        745    19987071\n## 2 Afghanistan 2000       2666    20595360\n## 3 Brazil      1999      37737   172006362\n## 4 Brazil      2000      80488   174504898\n## 5 China       1999     212258  1272915272\n## 6 China       2000     213766  1280428583"},{"path":"importar-exportar.html","id":"importar-exportar","chapter":"Capítulo 16 Sacando datos de las piedras","heading":"Capítulo 16 Sacando datos de las piedras","text":":::: {.blackbox data-latex=\"\"}* 13 FuncionesScripts usados:script09.R: importar datos. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script09.R\n::::Hemos aprendido crear nuestros propios datos pero muchas veces los cargaremos de distintos archivos, fuentes, etc. Vamos ver algunas formas que tenemos para importar (cargar) datos.","code":""},{"path":"importar-exportar.html","id":"importación-de-datos","chapter":"Capítulo 16 Sacando datos de las piedras","heading":"16.1 Importación de datos","text":"","code":""},{"path":"importar-exportar.html","id":"archivo-.rdata","chapter":"Capítulo 16 Sacando datos de las piedras","heading":"16.2 Archivo .RData","text":"La forma más sencilla de guardar datos y variables en R, y que además ocupa menos espacio en nuestro disco duro, es guardarlo en archivos propios que tiene R como son los archivos con extensiones .rda y .RData.Es recomendable tener los datos en la misma carpeta del proyecto pero una carpeta separada, ya que podemos tener muchos archivos y así mezclamos dichos ficheros con los códigos que escirbamos. En la carpeta DATOS del proyecto tenemos 1 archivo .RData: titanic.RData, un conjunto de datos obtenidos de la plataforma de aprendizaje y predicción https://www.kaggle.com/c/titanic/overview, con los datos de los pasajeros del Titanic (nombre, título, cabina, si sobrevivió o , edad, etc)¿Cómo cargar archivos .RData?Muy sencillo: como son ficheros nativos de R, basta con usar la función de carga load(), y dentro la ruta del archivo que queramos cargarEn el panel de entorno de la parte superior derecha ahora tendremos un data.frame que antes teníamos. Ya hemos visto que una función muy útil es head(), con argumento el nombre de un data.frame, que nos permite visualizar las primeras columnas.","code":"\n# Al fijar directorio de trabajo, no necesitamos toda la ruta, solo \"./\" y la ruta dentro de la carpeta del proyecto\nload(\"./DATOS/titanic.RData\")\nhead(titanic)##   PassengerId Survived Pclass\n## 1           1        0      3\n## 2           2        1      1\n## 3           3        1      3\n## 4           4        1      1\n## 5           5        0      3\n## 6           6        0      3\n##                                                  Name    Sex Age SibSp Parch\n## 1                             Braund, Mr. Owen Harris   male  22     1     0\n## 2 Cumings, Mrs. John Bradley (Florence Briggs Thayer) female  38     1     0\n## 3                              Heikkinen, Miss. Laina female  26     0     0\n## 4        Futrelle, Mrs. Jacques Heath (Lily May Peel) female  35     1     0\n## 5                            Allen, Mr. William Henry   male  35     0     0\n## 6                                    Moran, Mr. James   male  NA     0     0\n##             Ticket    Fare Cabin Embarked\n## 1        A/5 21171  7.2500              S\n## 2         PC 17599 71.2833   C85        C\n## 3 STON/O2. 3101282  7.9250              S\n## 4           113803 53.1000  C123        S\n## 5           373450  8.0500              S\n## 6           330877  8.4583              Q"},{"path":"importar-exportar.html","id":"archivo-.csv-o-.txt","chapter":"Capítulo 16 Sacando datos de las piedras","heading":"16.2.1 Archivo .csv o .txt","text":"Otra opción habitual son los archivos .csv (comma separated values): son archivos separados por comas (u otro caracter como puntos, puntos y comas, o tabuladores). En apariencia cuando los abrimos en el ordenador son como un Excel (ya que los abre el Excel), pero ocupan mucho menos que un Excel y su lectura es universal (independiente de tener instalado o el Excel) ya que son archivos de texto sin formato.Para leer un archivo .csv basta con usar la función read.csv()e indicarle la ruta del archivo para su lectura (argumento file, aunque tiene otros argumentos extras por si queremos especifiar el caracter que separa las columnas, si incluímos o una cabecera de la tabla, y otros argumentos que puedes consultar con ? read.csv).Ya tenemos nuestro archivo .csv cargado y además en formato data.frame.Una de las ventajas de la carga de estos archivos en R es que podemos hacerlo sin ni siquiera tener el archivo en nuestro ordenador, través de un enlace web. Vamos ver un ejemplo con los datos del ISCIII sobre la pandemia. En su web https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos tienen varios archivos colgados, que podemos o bien descargarlos, o haciendo click derecho «Copiar dirección de enlace» obtenemos un enlace. Por ejemplo, para el archivo casos_tecnica_ccaa.csv, que nos almacena el número de casos por técnica diagnóstica y CCAA, tenemos el enlace https://cnecovid.isciii.es/covid19/resources/casos_tecnica_ccaa.csv. Dicho enlace es el que se abre cuando pulsamos en Descargar, pero podemos introducirlo directamente en R, sustituyendo nuestra ruta.El archivo tiene 8 columnas: un código identificador de las CCAA, la fecha, y 6 variables relativas casos detectados (en función de la técnica con la que se ha detectado). Y además tiene un número de filas igual las 19 CCAA (17 + Ceuta + Melilla) por el número de días en los que hay registros.¿Cuál es la ventaja de cargarlo así? Ese enlace es fijo, y tendrá siempre el último archivo, actualizado, sin preocuparnos de tener que bajarnos cada día el archivo: simplemente ejecutamos dicha carga, y tenemos asegurado que nos bajaremos el archivo más actualizado posible.Vamos ver otro ejemplo con el repositorio de Github de la experta en lingüística computacional Elena Álvarez Mellado. En su repositorio tiene guardados los discursos navideños de los jefes de Estado (los democráticos y los democráticos, desde Franco hasta Felipe VI), desde 1937 hasta 2021.\nImagen/gráfica 16.1: Discursos guardados en el repositorio de https://github.com/lirondos/discursos-de-navidad.\nCada discurso está guardado en un archivo .txt, un archivo que tiene una estructura tabular (con filas y columnas, separadas por caracteres) como los archivos .csv. Para este tipo de archivos podemos usar read.delim.Ya veremos como analizar textos y palabras, o de como hacer un bucle para bajarnos todos.","code":"\ntitanic <- read.csv(file = \"./DATOS/titanic.csv\")\ndatos_ISCIII <- read.csv(file = \"https://cnecovid.isciii.es/covid19/resources/casos_tecnica_ccaa.csv\")\ndim(datos_ISCIII)## [1] 13965     8\nhead(datos_ISCIII)##   ccaa_iso      fecha num_casos num_casos_prueba_pcr num_casos_prueba_test_ac\n## 1       AN 2020-01-01         0                    0                        0\n## 2       AR 2020-01-01         0                    0                        0\n## 3       AS 2020-01-01         0                    0                        0\n## 4       CB 2020-01-01         0                    0                        0\n## 5       CE 2020-01-01         0                    0                        0\n## 6       CL 2020-01-01         0                    0                        0\n##   num_casos_prueba_ag num_casos_prueba_elisa num_casos_prueba_desconocida\n## 1                   0                      0                            0\n## 2                   0                      0                            0\n## 3                   0                      0                            0\n## 4                   0                      0                            0\n## 5                   0                      0                            0\n## 6                   0                      0                            0\ndiscurso_1937 <-\n  read.delim(file = \"https://raw.githubusercontent.com/lirondos/discursos-de-navidad/master/data/speeches/1937.txt\")\ndiscurso_1937##                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            COMBATIENTES.de.España.\n## 1 A los que estáis en las trincheras bajo la lluvia y el frío y las balas, yo os envío mi fe ardiente que se une con la vuestra de una próxima y definitiva victoria. A los que en la segunda línea padecéis dolor y sufrimiento -viudas, madres; hijos hermanos- os mando mi piedad y mi gratitud por vuestro esfuerzo que es el combate silencioso de todos los días para que la victoria se alcance en la primera línea, para que sea fecundo y duradero el afán de vuestros combatientes por la instauración de un orden nuevo. A vosotros, trabajadores de España, que dais vuestras fatigas por una España mejor y más justa, yo así os lo prometo. A todos os mando mi aliento y mi cariño.\n## 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ¡Combatientes de España!, por la victoria de nuestra Causa, que es la Causa del mundo cristiano en la tierra:\n## 3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ¡Arriba España!"},{"path":"importar-exportar.html","id":"archivo-.xlsx","chapter":"Capítulo 16 Sacando datos de las piedras","heading":"16.2.2 Archivo .xlsx","text":"Muchas veces tendremos un .csv (por desgracia) y nos tocará leer desde un excel. Para ello deberemos instalar (la primera vez) y cargar el paquete readxl que nos permitirá usar funciones para cargar archivos .xls (la función read_xls()) y archivos .xlsx (la función read_xlsx()). Además del argumento path con la ruta del archivo, podemos en el argumento sheet indicarle la hoja de Excel leer (en caso de tener varias).Vamos leer por ejemplo el archivo Boston.xlsx, que contienen información del valor inmobiliario de 506 distritos de Boston. Puedes ver la información de las variables con ? MASS::Boston.","code":"\ninstall.packages(\"readxl\")\nlibrary(readxl)\nboston <- read_xlsx(path = \"./DATOS/Boston.xlsx\")\nhead(boston)## # A tibble: 6 × 14\n##      crim    zn indus  chas   nox    rm   age   dis   rad   tax ptratio black\n##     <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl> <dbl>\n## 1 0.00632    18  2.31     0 0.538  6.58  65.2  4.09     1   296    15.3  397.\n## 2 0.0273      0  7.07     0 0.469  6.42  78.9  4.97     2   242    17.8  397.\n## 3 0.0273      0  7.07     0 0.469  7.18  61.1  4.97     2   242    17.8  393.\n## 4 0.0324      0  2.18     0 0.458  7.00  45.8  6.06     3   222    18.7  395.\n## 5 0.0690      0  2.18     0 0.458  7.15  54.2  6.06     3   222    18.7  397.\n## 6 0.0298      0  2.18     0 0.458  6.43  58.7  6.06     3   222    18.7  394.\n## # … with 2 more variables: lstat <dbl>, medv <dbl>"},{"path":"importar-exportar.html","id":"desde-paquete","chapter":"Capítulo 16 Sacando datos de las piedras","heading":"16.2.3 Desde paquete","text":"Por último, una opción muy común es cargar datos desde paquetes que ya los tienen (o los consiguen través de una API). Un ejemplo de ello es el paquete MASS, del que ya hemos hablado, que contiene una gran cantidad de conjuntos de datos para usarlos en nuestro propio aprendizaje, como es el conjunto MASS::Boston.Veamos otro ejemplo con uno de los paquetes más útiles para conseguir datos, el paquete del EUROSTATeurostat. Con la función search_eurostat() nos permite buscar datasets por palabras clave (nos muestra una tabla con los datasets y sus códigos) y con get_eurostat() podemos acceder ellos proporcionando el código del archivo.","code":"\nlibrary(eurostat) # instalar la primera vez\n\n# Buscamos datos por palabras clave\nsearch_eurostat(\"education\")## # A tibble: 1,062 × 8\n##    title   code  type  `last update of… `last table str… `data start` `data end`\n##    <chr>   <chr> <chr> <chr>            <chr>            <chr>        <chr>     \n##  1 Popula… cens… data… 01.04.2019       08.02.2021       2011         2011      \n##  2 Popula… cens… data… 26.08.2015       08.02.2021       2011         2011      \n##  3 Employ… cens… data… 26.03.2009       08.02.2021       2001         2001      \n##  4 Popula… cens… data… 26.03.2009       08.02.2021       2001         2001      \n##  5 Pupils… educ… data… 14.12.2021       08.02.2021       2013         2019      \n##  6 Pupils… educ… data… 14.12.2021       08.02.2021       2013         2019      \n##  7 Pupils… educ… data… 14.12.2021       08.02.2021       2013         2019      \n##  8 Pupils… educ… data… 14.12.2021       08.02.2021       2013         2019      \n##  9 Pupils… educ… data… 14.12.2021       08.02.2021       2013         2019      \n## 10 Studen… educ… data… 14.12.2021       08.02.2021       2013         2019      \n## # … with 1,052 more rows, and 1 more variable: values <chr>\n# Accedemos a un dato concreto por codigo\nget_eurostat(\"hlth_ehis_de3\")## # A tibble: 1,536 × 6\n##    sex   age    isced97 geo   time       values\n##    <chr> <chr>  <chr>   <chr> <date>      <dbl>\n##  1 F     TOTAL  ED0-2   BE    2008-01-01   19.1\n##  2 F     TOTAL  ED3_4   BE    2008-01-01   20.2\n##  3 F     TOTAL  ED5_6   BE    2008-01-01   11.5\n##  4 F     TOTAL  TOTAL   BE    2008-01-01   17  \n##  5 F     Y15-24 ED0-2   BE    2008-01-01   17.1\n##  6 F     Y15-24 ED3_4   BE    2008-01-01   21.3\n##  7 F     Y15-24 ED5_6   BE    2008-01-01   10.3\n##  8 F     Y15-24 TOTAL   BE    2008-01-01   16.1\n##  9 F     Y25-34 ED0-2   BE    2008-01-01   29.3\n## 10 F     Y25-34 ED3_4   BE    2008-01-01   27.4\n## # … with 1,526 more rows"},{"path":"importar-exportar.html","id":"otras-fuentes","chapter":"Capítulo 16 Sacando datos de las piedras","heading":"16.2.4 Otras fuentes","text":"En el futuro veremos algunas formas muy interesantes de obtener datos directamente desde R. aquí algunas opciones:Datos de Twitter (conectándonos su API).Datos de Spotify (conectándonos su API).Datos de programas electorales directamente desde los PDF que publican los partidos políticos.Datos de encuestas electorales directamente desde wikipedia.Datos del INE.Datos del BOE.Datos del catastro.Datos del AEMET.Datos electorales del Ministerio del Interior.Datos de partidas de ajedrezPero vayamos poco poco :)","code":""},{"path":"importar-exportar.html","id":"exportación-de-datos","chapter":"Capítulo 16 Sacando datos de las piedras","heading":"16.3 Exportación de datos","text":"Aunque se puede exportar en cualquier formato que puedas importar, vamos ver las dos formas más útiles y eficientes de exportar datos en R:fichero .RData.fichero .csv (obviaremos la exportación Excel porque un .csv ya es posible abrirlo con dicho engendro del demonio).La exportación en fichero .RData es la opción más recomendable si tú o tu equipo solo trabajáis con R, es la opción nativa de fichero, para que su importación sea tan sencilla como una función load(). Para exportar en R.Data basta con uses la función save(), indícandole lo que quieres guardar y la ruta donde quieres guardarlo.Es importante entender que la principal ventaja de exportar un fichero .RData es que se está portando una tabla, o un fichero tabulado con un formato de filas y columnas: estás exportando cualquier cosa, cualquier variable de R, con la naturaleza de esa variable intacta, sin necesidad de pasarlo otro formato.Para tenerlo organizado, la orden anterior está hecha habiendo creado en nuestra carpeta del proyecto una carpeta EXPORTAR para guardar lo que vayamos exportando. Ese fichero solo podrá ser abierto por R, pero cuando lo cargemos, tendremos la variable nombres tal cual la hemos guardado. siempre trabajamos en R y veces necesitamos una exportación de un data.frame o una tabla que podamos abrir en nuestra ordenador, ya sea para explicársela alguien o para enviársela otra persona. Para ello exportaremos en .csv, un fichero sin formato, y que es capaz de ser abierto por todo tipo de hojas de cálculo: basta que usemos la función write.csv(). WARNING: líneas de código en los erroresDado que los errores del código nos vendrán referenciados en la consola por el número de línea donde fueron detectados, puede sernos muy útil mostrar dichos números en la barra lateral izquierda, yendo Tools << Global Options << Code << Display << Show line numbers\nImagen/gráfica 16.2: Líneas de código.\n","code":"\nnombres <- c(\"javier\", \"carla\")\n# Exportamos en .RData la variable nombres \nsave(nombres, file = \"./EXPORTAR/nombres.RData\")\n# Exportamos en .csv el data.frame del ISCIII\nwrite.csv(datos_ISCIII, file = \"./EXPORTAR/datos_ISCIII.csv\")"},{"path":"importar-exportar.html","id":"consejos-10","chapter":"Capítulo 16 Sacando datos de las piedras","heading":"16.4 Consejos","text":"CONSEJOS Paquete rvestEn dicho paquete tienes más funciones para una lectura directamente como si navegaras por una página web. Ver https://github.com/tidyverse/rvest. Margen derecho en la ventana de scriptsAunque afecte nuestro código escribir todo en una línea sin saltos de línea, somos bárbaros/. ¿Por qué cuadno escribes en un Word lo haces en formato vertical pero cuando programas pones todas las órdenes seguidas? Recuerda que la legibilidad de tu código solo te ahorrará tiempo sino que te hará programar mejor. ¿Cómo podemos fijar un margen imaginario para nosotros ser quienes demos al ENTER? Yendo Tools << Global Options << Code << Display << Show margin (es un margen imaginario para ser nosotros quienes lo hagamos efectivo, R le da igual)\nImagen/gráfica 16.3: Margen derecho.\n","code":"\n# Ejemplo cargando datos de una tabla de wikipedia: \n# encuestas elecciones alemanas 2021\nlibrary(rvest)\nlibrary(tidyverse)\nwiki <- paste0(\"https://es.wikipedia.org/wiki/\",\n              \"Elecciones_federales_de_Alemania_de_2021\")\nhtml<- read_html(wiki)\ndatos <- html_nodes(html,\".wikitable\")\n\n# Tabla (tibble) (e ignoramos filas con algún valores ausentes)\nresultados_encuestas <-\n  html_table(datos[[5]], header = TRUE) %>% drop_na()\n\n# Resumen de columnas: casa encuestadora, fecha, muestra, partidos\nglimpse(resultados_encuestas)## Rows: 122\n## Columns: 10\n## $ Encuesta  <chr> \"Wahlkreisprognose[84]\", \"Ipsos[85]\", \"Forschungsgruppe Wahl…\n## $ Fecha     <chr> \"22–24 Sep 2021\", \"22–23 Sep 2021\", \"22–23 Sep 2021\", \"20–23…\n## $ Muestra   <chr> \"1,400\", \"2,000\", \"1,273\", \"2,002\", \"1,554\", \"10,012\", \"2,36…\n## $ SPD       <dbl> 25.5, 26.0, 25.0, 25.0, 26.0, 25.0, 25.0, 25.0, 25.0, 25.0, …\n## $ `CDU/CSU` <dbl> 22.5, 22.0, 23.0, 22.0, 25.0, 23.0, 21.0, 21.5, 21.0, 22.0, …\n## $ Grüne     <dbl> 14.0, 16.0, 16.5, 17.0, 16.0, 16.0, 14.0, 15.0, 16.0, 15.0, …\n## $ FDP       <dbl> 12.0, 12.0, 11.0, 12.0, 10.5, 12.0, 11.0, 12.5, 11.0, 12.0, …\n## $ AfD       <dbl> 11.0, 11.0, 10.0, 10.0, 10.0, 10.0, 12.0, 11.0, 11.0, 11.0, …\n## $ Linke     <dbl> 7.0, 7.0, 6.0, 6.0, 5.0, 6.0, 7.0, 6.5, 7.0, 6.5, 6.0, 6.0, …\n## $ Otros     <chr> \"8\", \"6\", \"8.5\", \"8\", \"7.5\", \"8\", \"9\", \"8.5\", \"9\", \"8.5\", \"8…"},{"path":"bibliografía.html","id":"bibliografía","chapter":"Bibliografía","heading":"Bibliografía","text":"Dasu, T., T. Johnson. 2003. Exploratory Data Mining Data Cleaning. John Wiley & Sons.Wickham, H. 2014. “Journal Statistical Software.” Tidy Data 59 (10).Ziemann, M., Y. Eren, . El-Osta. 2016. “Gene Name Errors Widespread Scientific Literature.” Genome Biology 17 (177).","code":""}]
