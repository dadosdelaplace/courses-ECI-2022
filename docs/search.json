[{"path":"index.html","id":"prefacio","chapter":"Prefacio","heading":"Prefacio","text":"Este material ha sido diseñado como complemento y recursos de apoyo al curso de la Escuela de Invierno de la UCM titulado «Analizando datos, visualizando información, contando historias», celebrado presencialmente del 31 de enero al 4 de febrero de 2022 (16:00 21:00 horas, de lunes viernes).El presente material introductorio ha sido elaborado por Javier Álvarez Liébana y Gabriel Valverde Castilla, y tiene como objetivo introducir en el lenguaje R todas aquellas personas que quieran aprender R desde cero. Dicho manual ha sido elaborado su vez en R con {bookdown}. Puedes ver un resumen de las funcionalidades de algunos paquetes documentados por el equipo de R Studio en sus esquemas resumen. El código de dicho manual se encuentra en GitHub. Para elaborar informes o libros con una estructura similar (de forma nativa en R) el paquete bookdown puede ser instalado desde la plataforma CRAN o desde su versión en desarrollo actualizada en Github:","code":"\ninstall.packages(\"bookdown\")\n# o desde su versión en desarrollo actualizada\n# devtools::install_github(\"rstudio/bookdown\")"},{"path":"index.html","id":"propósito","chapter":"Prefacio","heading":"Propósito","text":"El objetivo de este curso es introducir la programación y análisis estadístico en R toda aquella persona que nunca se haya iniciado en él, sin necesitar conocimientos previos de programación (aunque siempre ayuda, obviamente). se pretende que adquieras un vasto y experto conocimiento de R, pero si lo suficiente como para lograr 5 objetivos:tener miedo programarEntender los conceptos básicos de R.Dotarte de autonomía para poder trabajar con datos.Introducirte en el análisis estadístico.Adquirir las competencias necesarias para la visualización de datos en R.","code":""},{"path":"index.html","id":"contenidos","chapter":"Prefacio","heading":"Contenidos","text":"1 Requisitos2 Instalación de R y Rstudio3 ¿Qué es R?4 Primeros pasos4 Primeros pasos5 Tipos de datos6 Vectores6 Vectores","code":""},{"path":"index.html","id":"código-de-colores","chapter":"Prefacio","heading":"Código de colores","text":"Puedes buscar los siguientes términos en el buscador del documentoERROR:En color rojo encontrarás errores comunes o prácticas evitar.WARNING:En color naranja/amarillo encontrarás warnings o advertencias sobre cosas tener en cuenta para evitar problemas.Algunas funciones pueden arrojar ciertas advertencias que nunca está de más leer. Pero si dichos mensajes de alerta los tenemos controlados, y queremos que nos ensucie la ejecución en la consola, podemos poner al inicio del código assign(\"last.warning\", NULL, envir = baseenv()) para limpiar los warnings antiguos y options(warn = -1) para desactivarlos.CONSEJO:En color verde encontrarás consejos o tips para ampliar y facilitar tu programación. Además en cada cajita de código, si pasas el ratón, encontrarás un botón 📄📄 en la esquina superior derecha de la caja para copiar el código directamente tu consola. Puedes encontrarlos todos escribiendo «consejo» en el buscador.GLOSARIO:En color azul encontrarás un 📚 glosario con algunos términos estadísticos y conceptos básicos.","code":""},{"path":"index.html","id":"licencia","chapter":"Prefacio","heading":"Licencia","text":"Este documento es publicado bajo licencia pública general GNU,\nuna licencia libre de copyleft que garantiza los usuarios finales (personas, organizaciones, compañías) la libertad de usar, estudiar, compartir (copiar) y modificar el software, citando adecuadamente al autor del mismo.","code":""},{"path":"requisitos.html","id":"requisitos","chapter":"Capítulo 1 Requisitos","heading":"Capítulo 1 Requisitos","text":"Conexión internet (para la descarga de algunos datos y paquetes).Conexión internet (para la descarga de algunos datos y paquetes).Instalar R (ver 2.1). R será nuestro lenguaje, nuestro diccionario, nuestro castellano, nuestra ortografía para poder «comunicarnos» con el ordenador. https://cran.r-project.org/Instalar R (ver 2.1). R será nuestro lenguaje, nuestro diccionario, nuestro castellano, nuestra ortografía para poder «comunicarnos» con el ordenador. https://cran.r-project.org/Instalar R Studio (ver 2.2). De la misma manera que podemos escribir el mismo texto en castellano en una tablet, en un ordenador, en un Word, en un papel o en un tuit, en programación podemos usar distintos IDE (entornos de desarrollo integrados, nuestro Office), para que el trabajo sea más cómodo. Nosotros trabajaremos con RStudio.Instalar R Studio (ver 2.2). De la misma manera que podemos escribir el mismo texto en castellano en una tablet, en un ordenador, en un Word, en un papel o en un tuit, en programación podemos usar distintos IDE (entornos de desarrollo integrados, nuestro Office), para que el trabajo sea más cómodo. Nosotros trabajaremos con RStudio.Todo lo necesario para seguir este curso es de descarga gratuita: viva el software libre.","code":""},{"path":"instalacion.html","id":"instalacion","chapter":"Capítulo 2 Instalación","heading":"Capítulo 2 Instalación","text":"En breve daremos nuestros primeros pasos en R pero antes necesitamos instalar algunas cosas. vamos necesitar tantas, y para entender lo que instalamos pensaremos que vamos escribir un libro. ¿Qué necesitamos?Gramática/ortografía: en nuestro caso será R, el lenguaje de programación que usaremos.Word: al igual que podemos escribir en castellano de distintas maneras (en un Word, un post-, un cuaderno, etc), cuando programamos podemos trabajar en distintos entornos de desarrollo (IDE). En nuestro caso escribiremos y programaremos en RStudio, el programa que será nuestro Word para escribir en lenguaje R.","code":""},{"path":"instalacion.html","id":"instalacionR","chapter":"Capítulo 2 Instalación","heading":"2.1 Instalación de R","text":"Vamos necesitar solo 3 pasos (y conexión internet).Paso 1: entra en la web oficial de R https://cran.r-project.org/. En la pantalla de inicio selecciona la instalación acorde tu sistema operativo (ver imagen 2.1)\nImagen/gráfica 2.1: Pantalla inicial de la plataforma CRAN de R.\nPaso 2: para sistemas operativos Mac basta con que hacer click en el archivo .pkg, y abrirlo una vez descargado (ver imagen 2.2)\nImagen/gráfica 2.2: Pantalla de instalación de R en Mac OS.\nPara sistemas operativos Windows, debemos clickar en install R first time (ver imagen 2.3) y en la siguiente pantalla hacer click en Download R Windows (ver imagen 2.4). Una vez descargado, abrirlo como cualquier archivo de instalación.\nImagen/gráfica 2.3: Pantalla previa de instalación de R en Windows.\n\nImagen/gráfica 2.4: Pantalla final de instalación de R en Windows.\nPaso 3: tras su instalación tendrás en tu escritorio (Windows) o en tu Launchpad (Mac Os) un ejecutable de R para abrir. En Windows puede que tengas dos ejecutables i386 y x64 (como todo programa en Windows, está la versión de 32 y de 64 bits, haz click preferiblemente - si lo tienes - en el de x64). Te saldrá algo parecido lo que observas en la imagen 2.5.\nImagen/gráfica 2.5: Primera pantalla al abrir el ejecutable de R.\n","code":""},{"path":"instalacion.html","id":"primera-operación-sumar-dos-números","chapter":"Capítulo 2 Instalación","heading":"2.1.1 Primera operación: sumar dos números","text":"Para comprobar que está correctamente instalado, abre R y prueba escribir en la pantalla blanca inferior el siguiente código (recuerda: los códigos de este manual puedes copiarlos directamente de la cajita haciendo click en el botón de la esquina superior derecha)\nImagen/gráfica 2.6: Primera suma en la consola de R.\n¡Enhorabuena!¿Dónde hemos escrito ese código? Esa pantalla blanca donde hemos escrito el código se llama CONSOLA, y será donde ejecutaremos las órdenes.¿Dónde hemos escrito ese código? Esa pantalla blanca donde hemos escrito el código se llama CONSOLA, y será donde ejecutaremos las órdenes.¿Qué hemos hecho? Hemos hecho más de lo que parece. Primero, hemos definido dos variables y b asignándole un valor numérico cada una de ellas. Imagina que el símbolo <- es visto en nuestra cabeza como una flecha: una variable que llamamos le asignamos el valor 1, una variable que llamamos b le asignamos el valor 2. Podemos verlo como \\(= 1,~b = 2\\). Y tras definir dichas variables, las hemos usado en una operación aritméticaa + b. Ya sabemos usar R como calculadora.¿Qué hemos hecho? Hemos hecho más de lo que parece. Primero, hemos definido dos variables y b asignándole un valor numérico cada una de ellas. Imagina que el símbolo <- es visto en nuestra cabeza como una flecha: una variable que llamamos le asignamos el valor 1, una variable que llamamos b le asignamos el valor 2. Podemos verlo como \\(= 1,~b = 2\\). Y tras definir dichas variables, las hemos usado en una operación aritméticaa + b. Ya sabemos usar R como calculadora.¿Cómo nos devuelve R el resultado de la operación? Si te ha devuelto el resultado correcta, en la consola debe aparecer [1] 3. El valor [1] aparecerá siempre ya que simplemente nos numera las líneas de la consola usadas; lo que viene detrás es realmente el resultado, es decir, \\(+ b = 3\\).¿Cómo nos devuelve R el resultado de la operación? Si te ha devuelto el resultado correcta, en la consola debe aparecer [1] 3. El valor [1] aparecerá siempre ya que simplemente nos numera las líneas de la consola usadas; lo que viene detrás es realmente el resultado, es decir, \\(+ b = 3\\).¿Por qué hemos escrito + b al final? Un mantra de R, que veremos lo largo de todo el curso, es que R intenta molestarte lo menos posible (eso es bueno cuando ya sabes usarlo, tan bueno cuando empezamos aprenderlo). Cuando asignamos los valores <- 1 y b <- 2, R nos muestra nada: si guardamos un resultado en una variable, nos muestra nada por consola. Para obtener el resultado en la consola necesitamos escribir el nombre de las variables (u operaciones entre ellas, como + b).¿Por qué hemos escrito + b al final? Un mantra de R, que veremos lo largo de todo el curso, es que R intenta molestarte lo menos posible (eso es bueno cuando ya sabes usarlo, tan bueno cuando empezamos aprenderlo). Cuando asignamos los valores <- 1 y b <- 2, R nos muestra nada: si guardamos un resultado en una variable, nos muestra nada por consola. Para obtener el resultado en la consola necesitamos escribir el nombre de las variables (u operaciones entre ellas, como + b). WARNING: Como habrás advertido, en R usaremos <- para asignar valores en lugar de =, como una flecha. Usaremos = para indicarle el valor los argumentos que usemos en funciones y == como operador de comparación: si escribimos 2 == 3, le estamos preguntando si 2 es igual 3. Bonita esta interfaz es, así que la cerraremos y la abriremos más. Tenemos nuestro lenguaje instalado, vamos instalar nuestro Word para poder programar de forma cómoda.","code":"\na <- 1\nb <- 2\na + b## [1] 3\n2 == 3## [1] FALSE"},{"path":"instalacion.html","id":"instalacionRStudio","chapter":"Capítulo 2 Instalación","heading":"2.2 Instalación de R Studio","text":"Para instalar RStudio deberemos ir la web https://www.rstudio.com/products/rstudio/download/#download (el gratuito) y seleccionar el ejecutable que te aparezca acorde tu sistema operativo (ver imagen 2.7). Tras descargar el ejecutable, hay que abrirlo como otro cualquier otro ejecutable y dejar que termine la instalación.\nImagen/gráfica 2.7: Descargar el ejecutable de RStudio para su posterior instalación.\nTras instalar tendremos en el escritorio o Launchpad un ejecutable de RStudio que abriremos. Se nos aparecerá una pantalla similar esta:\nImagen/gráfica 2.8: Primer recibimiento de nuestro mejor amigo RStudio.\nListo, tienes instalado (casi) todo correctamente.","code":""},{"path":"instalacion.html","id":"glosario","chapter":"Capítulo 2 Instalación","heading":"2.3 Glosario","text":"GLOSARIOConsola: es el nombre para llamar esa ventana grande que te ocupa buena parte de tu pantalla. Prueba escribir el mismo código que antes en ella (es el equivalente la consola de R que hemos abierto al principio).\nImagen/gráfica 2.9: Lanzando consola nuestras primeras órdenes en RStudio.\nLa consola será donde ejecutaremos órdenes y mostraremos resultadosEnvironment (entorno): la pantalla pequeña (puedes ajustar los márgenes con el ratón tu gusto) que tenemos en la parte superior derecha se denomina environment o entorno de variables, donde como puedes ver, tras ejecutar el pequeño código en la consola, nos informa de que tenemos dos variables numéricas y su valor asignado. Nos mostrará las variables que tenemos definidas, el tipo y su valor.\nImagen/gráfica 2.10: Environment de variables.\nPanel multiusos: la ventana que tenemos en la parte inferior derecha servirá para buscar ayuda de comandos y órdenes, además de para visualizar gráficos. Lo veremos cuando sea necesario.\nImagen/gráfica 2.11: Panel multiusos.\n","code":"\na <- 1\nb <- 2\na + b"},{"path":"instalacion.html","id":"consejos","chapter":"Capítulo 2 Instalación","heading":"2.4 Consejos","text":"CONSEJOS¿Cómo saber cuando la orden lanzada en consola ha terminado?veces R y RStudio son tan silenciosos que sabemos si ha acabado la orden que acabamos de lanzar en la consola o . Siempre que veas el símbolo > como última línea en la consola significa que está listo para que le escribamos otra orden (es la forma cariñosa de decirte que ya ha acabado, ver imagen 2.12)\nImagen/gráfica 2.12: Ejemplo de que la orden lanzada ha acabado.\n ¿Cómo prevenir la fatiga programando?Estando delante de una pantalla de ordenador, con la vista muy fija mientras se programa, puede que acabes teniendo cierta fatiga visual en el trabajo. Te aconsejo que cambies en tu RStudio la tonalidad del fondo de tu programa, en tonos oscuros y blancos (¿te fijado que mis capturas tienen un azul cobalto oscuro de fondo mientras el tuyo es un blanco nuclear? Echa un vistazo las imágenes 2.13 y 2.14)\nImagen/gráfica 2.13: Menú de opciones de nuestro editor\n\nImagen/gráfica 2.14: Personalizar el color de fondo de nuestro editor, la letra y el tamaño de fuente\n","code":""},{"path":"que-es-R.html","id":"que-es-R","chapter":"Capítulo 3 ¿Qué es R?","heading":"Capítulo 3 ¿Qué es R?","text":"Una vez que tenemos todo instalado vamos dar nuestros primeros pasos en R, pero antes veamos un poco de su historia y de una particularidad: R es un lenguaje modular (¿modu…qué?)","code":""},{"path":"que-es-R.html","id":"historia-de-r","chapter":"Capítulo 3 ¿Qué es R?","heading":"3.1 Historia de R","text":"Veamos antes un poco de la historia de nuestra deidad.Allá por 1975, los laboratorios Bell (los que inventaron la radio moderna tal y como la conocemos), necesitaban una alternativa los lenguajes más «rudos» y antiguos como C++ o Fortran, lenguajes rápidos en la ejecución pero complejos en su uso, con una gran curva de aprendizaje y con muy poca capacidad en la visualización de datos que se empezaba necesitar.Así que en 1976 sacaron la primera versión del lenguaje conocido S (hasta entonces estaba de moda lo de llamar los lenguajes con una sola inicial). En 1980 se empezó distribuir la primera versión pública de S, más allá de los laboratorios Bell, y en 1988 se añadieron bastantes funcionalidades nuevas como poder aplicar funciones otras funciones (los famosos apply() que ya veremos). Años más tarde, en 1991, dicho lenguaje se simplificó, reescribiendo muchas subrutinas de otros lenguajes más primitivos, para tener una versión muy parecida al actual R, permitiendo el usod de operadores, data.frames (que veremos) y otro tipo de objetos, sencillos en la programación pero muy versatiles.Sin embargo, salvo uso docente, S tenía licencia así que en 1992 Ross Ihaka y Robert Gentleman se lanzaron crear una versión de S libre y gratuita, un trabajo de casi 8 años hasta que en el año 2000, ambos investigadores de la Universidad de Auckland en Nueva Zelanda lanzaron la primera versión estable del lenguaje.Tras dicho lanzamiento, se creó un equipo de expertos en estadística computacional (el conocido como R Development Core Team) que es el que se encarga de mantener toda la aerquitectura de R y los que se encargar de actualizar y mejorar el paquete {base}, una librería motor sobre la que se construye el resto de funciones.Y es precisamente ese hecho una de las principales diferencias entre Python y R: R fue creado por y para estadísticos. Te dejo esta entrada en el blog por si quieres curiosear las diferencias (aunque ambos pueden ser útiles para trabajos estadísticos muy generales).","code":""},{"path":"que-es-R.html","id":"instalacionpaquetes","chapter":"Capítulo 3 ¿Qué es R?","heading":"3.2 Comunidad de usuarios: paquetes","text":"La pregunta del millón suele ser siempre la misma: ¿qué lenguaje elegir? Podríamos hacer una comparativa técnico de distintos lenguajes pero vamos quedarnos con dos consejos fundamentales: prioriza el software libre y aquellos lenguajes que tienen una comunidad muy grande de usuarios trabajando en los problemas o campo para el que vas usar dicho lenguaje.El lenguaje R (también Python) tiene 3 ventajas principales:Es un lenguaje creado por y para estadísticos/.Es un lenguaje creado por y para estadísticos/.Es software libre (como C++, Python, Fortran, y otros tantos lenguajes). El software libre solo tiene una ventaja evidente (es gratis, ok) sino que permite acceder libremente código ajeno.Es software libre (como C++, Python, Fortran, y otros tantos lenguajes). El software libre solo tiene una ventaja evidente (es gratis, ok) sino que permite acceder libremente código ajeno.Es un lenguaje modular: en la instalación que hemos realizado se han instalado todas las funcionalidades, solo el mínimo para poder funcionar, de forma que se ahorra espacio en disco y en memoria. Al ser software libre, existen trozos de código hechos por otras personas llamados paquetes, que podemos ir instalando nuestro gusto según los vayamos necesitando. Esto es una ventaja enorme ya que R tiene una comunidad de usuarios gigante para hacer estadística (Python tiene una enorme comunidad pero más enfocada al Machine Learning), con más de 17 000 paquetes: ¡hay más de 17 000 trozos de código, muchos de ellos programados por expertos/en R, validados por la comunidad y la plataforma, y de forma gratuita!Es un lenguaje modular: en la instalación que hemos realizado se han instalado todas las funcionalidades, solo el mínimo para poder funcionar, de forma que se ahorra espacio en disco y en memoria. Al ser software libre, existen trozos de código hechos por otras personas llamados paquetes, que podemos ir instalando nuestro gusto según los vayamos necesitando. Esto es una ventaja enorme ya que R tiene una comunidad de usuarios gigante para hacer estadística (Python tiene una enorme comunidad pero más enfocada al Machine Learning), con más de 17 000 paquetes: ¡hay más de 17 000 trozos de código, muchos de ellos programados por expertos/en R, validados por la comunidad y la plataforma, y de forma gratuita!\nImagen/gráfica 3.1: Paquetes disponibles en R.\nEsto nos ahorra muchísimo tiempo en nuestro día día ya que casi todo lo que querramos hacer ya lo habrá querido hacer otra persona (y seguramente mejor que nosotros/). Vamos instalar, por ejemplo, un paquete gráfico (ggplot2) que necesitaremos en el futuro. Para ello, escribe en tu consola el siguiente código y pulsa enter.Dicha orden (puede tardar un poco la primera vez, depende de tu conexión internet) lo que hará será acceder la web de R, bajarse tu ordenador los trozos de código incluidos en el paquete llamado ggplot2, y dejarlos para siempre en él. WARNING:La instalación de paquetes SOLO ES NECESARIA la primera vez que se usa dicho paquete en la vida del ordenador, hace falta hacerlo cada vez que lo usas. Una vez que tenemos los trozos de código (el paquete) en nuestro ordenador, en cada sesión de R que abramos (cada vez que cierres y abras RStudio) deberemos (si queremos) llamar ese paquete que tenemos instalado, escribiendo el siguiente comando en consolaWelcome software libre","code":"\ninstall.packages(\"ggplot2\")\nlibrary(ggplot2)"},{"path":"que-es-R.html","id":"por-qué-excel-no-es-tu-amigo","chapter":"Capítulo 3 ¿Qué es R?","heading":"3.3 ¿Por qué Excel no es tu amigo?","text":"R es un lenguaje de programación, de alto nivel para el usuario y modular. Los lenguajes de alto nivel como R, Python (curso interactivo de Python en https://checkio.org/) o Matlab, facilitan la programación al usuario, teniendo que preocuparte solo de la tarea de programar. Son lenguajes con una menor curva de aprendizaje aunque suelen ser más lentos en su ejecución en comparación con lenguajes de bajo nivel (C, C++ o Fortran), lenguajes muy rápidos en su ejecución pero cuya programación requiere un mayor tiempo y formación, teniendo que además estar pendiente del tipo de variables, espacio en memoria, etc.Por su arquitectura, R es un lenguaje que puede ser usado para un propósito general pero que está especialmente diseñado para el análisis estadístico de datos. Su modularidad nos da la ventaja de que podemos instalar las funcionalidades que vayamos necesitando de forma progresiva.¿Por qué es recomendable usar Excel como base de datos ni para realizar análisis estadísticos complejos? Software de pago: Excel, al igual que el resto de programas de Microsoft o SPSS (por desgracia programa estrella de nuestro sistema sanitario), es un programa de pago. nivel individual, todos hemos tenido una versión que hemos pagado, pero dicha evasión se la puede permitir una empresa o administración, que debe de pagar altas cantidades de dinero anuales por las licencias, dinero que sería necesario si los investigadores y trabajadores tuvieran formación (remunerada) en otras herramientas de software libre.Software de pago: Excel, al igual que el resto de programas de Microsoft o SPSS (por desgracia programa estrella de nuestro sistema sanitario), es un programa de pago. nivel individual, todos hemos tenido una versión que hemos pagado, pero dicha evasión se la puede permitir una empresa o administración, que debe de pagar altas cantidades de dinero anuales por las licencias, dinero que sería necesario si los investigadores y trabajadores tuvieran formación (remunerada) en otras herramientas de software libre.Software cerrado: solo es de pago sino que es cerrado, así que solo podemos hacer lo que Excel ha creído que interesante que podamos hacer. Incluso con la programación de MACROS, las funcionalidades de Excel siguen siendo mucho más limitadas ya que viene «programadas» de antemanoSoftware cerrado: solo es de pago sino que es cerrado, así que solo podemos hacer lo que Excel ha creído que interesante que podamos hacer. Incluso con la programación de MACROS, las funcionalidades de Excel siguen siendo mucho más limitadas ya que viene «programadas» de antemanoAlto consumo de memoria: dicha programación predeterminada hace que Excel ocupe muchísimo espacio en el disco duro y tenga un alto consumo de memoria (la memoria es lo que te permite hacer varias tareas la vez en tu ordenador).Alto consumo de memoria: dicha programación predeterminada hace que Excel ocupe muchísimo espacio en el disco duro y tenga un alto consumo de memoria (la memoria es lo que te permite hacer varias tareas la vez en tu ordenador).es universal: solo es de pago sino que además, dependiendo de la versión que tengas de Excel, tendrá un formato distinto para datos como fechas, teniendo incluso extensiones distintas, de forma que un archivo .xls abierto por un Excel moderno puede provocar errores en la carga.es universal: solo es de pago sino que además, dependiendo de la versión que tengas de Excel, tendrá un formato distinto para datos como fechas, teniendo incluso extensiones distintas, de forma que un archivo .xls abierto por un Excel moderno puede provocar errores en la carga.¡ES SOLO UNA HOJA DE CÁLCULO!: el propio Microsoft desaconseja el uso de Excel para el análisis de grandes volúmenes de datos. El Excel es una herramienta maravillosa para ser usada como una sencilla hoja de cálculo: llevar las cuentas de tu familia, de tu pequeño negocio, una declaración de la Renta sencilla, planificar viajes, etc. Pero el programa ESTÁ DISEÑADO para ser una base de datos ni para análisis detallado, y muchos menos pensado para generar un entorno flexible para el análisis estadístico y la visualización de datos.¡ES SOLO UNA HOJA DE CÁLCULO!: el propio Microsoft desaconseja el uso de Excel para el análisis de grandes volúmenes de datos. El Excel es una herramienta maravillosa para ser usada como una sencilla hoja de cálculo: llevar las cuentas de tu familia, de tu pequeño negocio, una declaración de la Renta sencilla, planificar viajes, etc. Pero el programa ESTÁ DISEÑADO para ser una base de datos ni para análisis detallado, y muchos menos pensado para generar un entorno flexible para el análisis estadístico y la visualización de datos. ¿Puedes ser el mejor partiendo un filete con una cuchara? Seguramente puedas (en Excel puedes hasta programar con macros), y si siempre lo hiciste así, acabarás normalizándolo, pero seguirás siendo una persona comiendo filete con cuchara.¿Qué sucede si usamos la herramienta equivocada? Tres ejemplos:Problemas para codificar fechas: en 2016 se publicó una revisión de artículos en genética, descubriendo que 1 de cada 5 artículos contenían errores debido una mala codificación de las fechas, conviertiendo por ejemplo los genes Septin-2 (conocido como SEPT2) en fechas, y al revés (Ziemann, Eren, El-Osta 2016).\nImagen/gráfica 3.2: Excel en una noche loca.\nProblemas de memoria: un Excel permite por defecto una cantidad máxima de filas. Aunque dicha cantidad se puede ampliar, sigue siendo finita, por lo que cuando superas el umbral de filas, al añadir filas Excel te borra registros sin avisarte de que lo está haciendo. Esto es lo que sucedió con los registros de casos covid en Reino Unido.\nImagen/gráfica 3.3: Cuando Excel dice basta.\nProblemas para codificar edades: una variable de tipo fecha, aunque nosotros la veamos con letras, en realidad es una variable numérica que representa los días que han pasado desde una fecha origen. En función de las distintas versiones de Excel, dicha fecha origen cambia. Además, si se codifica mal la fecha en formato dd-mm-YY, dicho formato cuando se exporta otro excel en texto, permite distinguir un nacido en 1918 y un nacido en 2018, así que podemos estar confundiendo personas de 103 años con niños de 3 años (y es lo que sucedió en España, observando unas tasas de mortalidad en niños muy pequeños equivalentes personas mayores).\nImagen/gráfica 3.4: Los centenarios con biberón.\n","code":""},{"path":"que-es-R.html","id":"glosario-1","chapter":"Capítulo 3 ¿Qué es R?","heading":"3.4 Glosario","text":"GLOSARIOPaquete: trozos de código realizadas por otros usuarios de la comunidad (y validades por el equipo de CRAN si la descarga es mediante install.packages()) para ser usados. Una vez instalados (descargados) los trozos de código nuestro ordenador, basta con «acudir» ellos con library().Haciendo una metáfora con la colección de libros que tengas en casa: con la instalación hemos comprado el libro y lo tenemos en nuestra estantería (para siempre), con la llamada al paquete, por ejemplo library(ggplot2), lo que hacemos es decidir, de entre todos los libros de la estantería, cuales queremos llevarnos de viaje (en cada maleta que hagamos).Los paquetes usados los verás denotados como {nombre_paquete} lo largo del manual.","code":""},{"path":"primeros-pasos.html","id":"primeros-pasos","chapter":"Capítulo 4 Primeros pasos","heading":"Capítulo 4 Primeros pasos","text":"Scripts usados:script01.R: ejercicio 4. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script01.R Vamos empezar por lo sencillo: ¿cómo usar R como una calculadora?","code":""},{"path":"primeros-pasos.html","id":"primeros-pasos-en-r-calculadora","chapter":"Capítulo 4 Primeros pasos","heading":"4.1 Primeros pasos en R: calculadora","text":"¿Te acuerdas de lo que era la consola? En el caso de RStudio, la consola será esa pequeña pantalla que tenemos en la parte inferior (la pestaña Console). Vamos trabajar de momento solo en esa ventana inferior.\nImagen/gráfica 4.1: Lanzando consola nuestras primeras órdenes en RStudio.\nLo que ya hemos descubierto en los pasos de la instalación (ver imagen 4.1) es que la consola de R tiene una función muy básica y evidente: nos sirve de calculadora. Un ejemplo muy simple: si escribimos 3 en la consola y pulsamos ENTER, la consola nos mostrará el resultado de la suma ¿Cuál es la diferencia entre una calculadora y un lenguaje de programación? Imagina que dicha suma 3 la quisiéramos utilizar para un segundo cálculo: ¿y si en lugar de lanzarlo la consola sin más lo almacenamos en alguna variable?Como hemos visto en la instalación de RStudio, para asignar variables lo haremos con <-, por ejemplo la orden x <- 1 + 2: una variable de nombre x va tener asignada lo que valga la suma 1 + 2Como puedes comprobar, en tu parte superior derecha (nuestro entorno de variables), podrás ver como una nueva variable x es ahora visualizada, con su valor asignado (se mostrará en consola salvo que escribas 3 en ella: R asume que querías visualizarla en consola sino solo guardarla).\nImagen/gráfica 4.2: Environment.\nDicha variable x además podemos reciclarla para definir, por ejemplo, una variable y, restándole una constante. De la misma manera que hemos hecho restas, sumas y multiplicaciones, R tiene todas las operaciones clásicas que podrías tener en una calculadora. Prueba ejecutar en la consola las órdenes x^2, sqrt(x) o abs(y): R calculará las operaciones elevar al cuadrado, raíz cuadrada y valor absoluto (respectivaemnte) de la variable que tengan entre paréntesis ","code":"\n1 + 2## [1] 3\nx <- 1 + 2\ny <- x - 3\nx## [1] 3\ny## [1] 0\nx * y## [1] 0\nx^2## [1] 9\nsqrt(x)## [1] 1.732051\ny <- x - 5\nabs(y)## [1] 2"},{"path":"primeros-pasos.html","id":"y-dónde-programamos","chapter":"Capítulo 4 Primeros pasos","heading":"4.2 ¿Y dónde programamos?","text":"¿Estás emocionado/? Vamos abrir nuestro primer script. Un script será el documento en el que programamos, nuestro .doc, pero aquí será un archivo con extensión .R, donde escribiremos las órdenes, que nos evitará estar lanzando todo consola. ¿Por qué abusar de la consola? Una máxima para olvidar: TODO lo que escribas en un script, cuando cierres RStudio, lo habrás perdido (cómo si en lugar de escribir en un Word y guardarlo, nunca guardases el documento).Para abrir nuestro primero script, haz click en el menú superior en File << New File << R Script como se muestra en la imagen 4.3\nImagen/gráfica 4.3: Abriendo nuestro primer script de R.\nTras abrirlo tendremos una cuarta ventana: esta será la ventana de nuestros códigos, la ventana más importante ya que es donde escribiremos lo que queremos ejecutar. Escribe el código de la suma de arriba en ese script y guarda el archivo haciendo click en el botón Save current document\nImagen/gráfica 4.4: Escribiendo y guardando nuestro primer script.\nEse código se ejecuta salvo que se lo digamos. Tenemos tres opciones para ejecutar código:Copiar y pegar el trozo de código en la consola (como hemos hecho al principio).Copiar y pegar el trozo de código en la consola (como hemos hecho al principio).Seleccionar líneas de código y clickar en Run (o con su atajo de teclado), lo que hará que se ejecute solo las líneas seleccionadas.Seleccionar líneas de código y clickar en Run (o con su atajo de teclado), lo que hará que se ejecute solo las líneas seleccionadas.Activar el cuadrado Source save la derecha del botón de guardar y volvemos hacer click en el botón de guardar: siempre que esa opción esté activada, al guardar solo es nos guarda el archivo .R sino que además se ejecuta el código completo que tengas en el script.Activar el cuadrado Source save la derecha del botón de guardar y volvemos hacer click en el botón de guardar: siempre que esa opción esté activada, al guardar solo es nos guarda el archivo .R sino que además se ejecuta el código completo que tengas en el script.","code":"\na <- 1\nb <-2\na + b## [1] 3"},{"path":"primeros-pasos.html","id":"tipos_errores","chapter":"Capítulo 4 Primeros pasos","heading":"4.3 Tipos de errores","text":"Durante tu aprendizaje en R va ser muy habitual que las cosas salgan la primera, apareciendo en consola mensajes en un color rojo. Un miedo muy habitual cuando se empieza programar es pensar que si haces algo mal o aparece algún mensaje de error, el ordenador puede explotar en cualquier momento. programar se aprende programando, así que haz las pruebas que quieras, lo peor que puede pasar es que necesites cerrar sesión en R Studio y abrirlo de nuevo, o en el peor de los casos, desintalarlo y volverlo iinstalar.Dado que el \\(99.9\\%\\) de las veces tu código tendrá errores que deberás ir solventando, está de más conocer los tipos de mensajes que R puede sacarte por consola.Los mensajes de ERROR irán precedidos de la frase «Error …», dándote veces incluso el tipo de error y la línea de código en la que se ha producido. Veamos un ejemplo intentando sumar un número una cadena de texto.Los errores son aquellos fallos que seguramente impidan la ejecución del código. Un error muy habitual es intentar acceder alguna función de algún paquete que, o bien tenemos instalado, o bien hemos llamado haciendo uso del library(): estás intentando leerte un libro de tu biblioteca pero ni siquiera ido la tienda «comprarlo». Los mensajes de WARNING irán precedidos de la frase «Warning …», y son los fallos más delicados ya que son posibles errores o incoherencias que R detecta en tu código pero que van hacer que tu código deje de ejecutarse, aunque probablemente lo haga como ti te gustaría. Un ejemplo es cuando tratamos de hacer la raiz cuadrada de un número negativo.¿Ha ejecutado la orden? Sí, pero te advierte de que el resultado de la operación es un NaN, un valor que existe (al menos dentro de los números reales), un Number (ver Sección 6.5). Los mensajes de CONTROL serán aquellos que aparecerán por consola sin empezar por «Error …» ni «Warning:…». Dichos mensajes, que puedes incluir tú mismo en tu código con funciones como cat() para monitorizar la ejecución de códigos largos, son errores ni problemas, son simplemente información que R considera útil aportarte. ","code":"\n\"a\" + 1## Error in \"a\" + 1: argumento no-numérico para operador binario\nsqrt(-1)## Warning in sqrt(-1): Se han producido NaNs## [1] NaN"},{"path":"primeros-pasos.html","id":"glosario-2","chapter":"Capítulo 4 Primeros pasos","heading":"4.4 Glosario","text":"GLOSARIOPaquete: trozos de código realizadas por otros usuarios de la comunidad (y validades por el equipo de CRAN si la descarga es mediante install.packages()) para ser usados. Una vez instalados (descargados) los trozos de código nuestro ordenador, basta con «acudir» ellos con library().Haciendo una metáfora con la colección de libros que tengas en casa: con la instalación hemos comprado el libro y lo tenemos en nuestra estantería (para siempre), con la llamada al paquete, por ejemplo library(ggplot2), lo que hacemos es decidir, de entre todos los libros de la estantería, cuales queremos llevarnos de viaje (en cada maleta que hagamos).Los paquetes usados los verás denotados como {nombre_paquete} lo largo del manual.","code":""},{"path":"primeros-pasos.html","id":"consejos-1","chapter":"Capítulo 4 Primeros pasos","heading":"4.5 Consejos","text":"CONSEJOS Panel de ayudaSi escribes en la consola ? nombre_funcion (por ejemplo, escribe en la consola ? sqrt), en el panel inferior derecho te aparecerá una documentación de ayuda de la función para saber que argumentos necesita, como puedes usar la función, qué es lo que te devuelve, ejemplos de uso, etc.\nImagen/gráfica 4.5: Panel de ayuda.\n ¿Cómo comentar el código?Probablemente lo más importante al programar es que te acostumbres comentar lo máximo posible tu código. ¿Qué es un comentario? Es un texto que escribes entre el código precedido de #: todo lo que venga detrás será interpretado por R como código. Es vital cuando programamos que nos acostumbremos comentar lo que hacemos, tanto para nosotros como para otras personas que puedan leer nuestro código. Índice en el códigoPuedes escribir comentarios en el código para que automáticamente se organice tu código en epígrafes, mostrándote un índice en el panel lateral (haz click en el icono de la esquina superior derecha del editor) y permitiendo minimizar partes del código. Para ello puedes comentar por ejemplo con # ----- título -----.\nImagen/gráfica 4.6: Comentando el código para generar un índice.\n ","code":"\n? sqrt"},{"path":"primeros-pasos.html","id":"ejercicios","chapter":"Capítulo 4 Primeros pasos","heading":"4.6 📝 Ejercicios","text":"(haz click en las flechas para ver soluciones)📝Ejercicio 1: en tu consola (parte inferior de tu pantalla), asigna los valores 2 y 5 dos variables y b. Tras asignarles valores, multiplica los números en consola (haz click en la flecha para la solución propuesta). Solución:\nImagen/gráfica 4.7: Multiplicación de y b.\n 📝Ejercicio 2: repite el ejercicio anterior pero ahora guarda el resultado de la multiplicación en una variable c. Para ver el resultado guardado en c escribe dicha variable en consola (haz click en la flecha para la solución propuesta). Solución:\nImagen/gráfica 4.8: Multiplicación de y b guardando el resultado.\n 📝Ejercicio 3: asigna ahora los valores 1, -2, 3 tres variables , b y c, y calcula la raíz cuadrada de cada uno. Solución: 📝Ejercicio 4: repite el ejercicio 2 pero ahora escribe el código en un script (fichero .R, guardado en script01.R). Recuerda al acabar seleccionar las líneas ejecutar y clickar Run, o bien guardar el script con Source save activado (haz click en la flecha para la solución propuesta). Solución:\nImagen/gráfica 4.9: Multiplicación de y b guardando el resultado pero escribiendo en el script.\n 📝Ejercicio 5: calcula en consola la suma de 3 más 4, y todo ello multiplicado por 10, y asígnalo una variable x (haz click en la flecha para la solución propuesta).Solución: 📝Ejercicio 6: asigna un valor positivo x y calcula su raíz cuadrada; asigna otro negativo y calcula su valor absoluto (haz click en la flecha para la solución propuesta).Solución: CONSEJO:Las órdenes sqrt(x) y abs(y) se llaman funciones, y la variable que tienen entre paréntesis se llama argumento de la función: una variable que toma de entrada la función y con la que opera internamente. 📝Ejercicio 7: usando la variable x ya definida, calcula x - 5 y guárdalo en una nueva variable z (haz click en la flecha para la solución propuesta).Solución: 📝Ejercicio 8: usando las variables x y z ya definidas, calcula la raíz cuadrada del máximo entre ambas, y guárdalo en una nueva variable t. Hazlo en un script en lugar de en consola (haz click en la flecha para la solución propuesta).Solución: WARNING:hace falta gastar una línea por cada orden que quieras ejecutar. Tampoco necesitas guardar cada paso intermedio que realices. Cuidado con la memoria: cada asignación que hagas es una variable guardada que consume recursos en tu ordenador.","code":"\n# Para poner comentarios en el código se usa #\n\n# Definición de variables\na <- 2\nb <- 5\n\n# Multiplicación\na * b## [1] 10\n# Variables\na <- 2\nb <- 5\n\n# Resultado\nc <- a * b\n\n# Muestro en consola\nc## [1] 10\n# Variables\na <- 1\nb <- -2\nc <- 3\n\n# Resultado\nsqrt(a)## [1] 1\nsqrt(b)## [1] NaN\nsqrt(c)## [1] 1.732051\nx <- (3 + 4) * 10\n# Raíz cuadrada\nx <- 73\nsqrt(x)## [1] 8.544004\n# Valor absoluto\ny <- -73\nabs(y)## [1] 73\nz <- x - 5\nz## [1] 68\nt <- sqrt(max(x, z)) \nt## [1] 8.544004"},{"path":"tipos-datos.html","id":"tipos-datos","chapter":"Capítulo 5 Tipos de datos","heading":"Capítulo 5 Tipos de datos","text":"Scripts usados:script02.R: tipos de datos y funciones usadas con ellos. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script02.R Tras las lecciones anteriores, los ejercicios planteados y lo que hayas jugueteado por tu cuenta, deberíamos saber usar ya R como una calculadora. Vamos ir más allá: ¿existen datos más allá de los números? En este capítulo vamos empezar familiarizarnos con los tipos de datos (individuales) que podemos necesitar. Piensa por ejemplo en los datos guardados de una persona:La edad será un número (sin decimales)Su peso o estatura será otro número (ahora con decimales).Su nombre será una cadena de texto.Su fecha de nacimiento será precisamente eso, una fecha.la pregunta «¿está usted soltero/?» la respuesta será lo que llamamos una variable binaria: una variable que solo puede valer TRUE (si está soltero/) y FALSE (en otro caso).Existen más tipos (como números complejos) pero con estos nos valdrá para nuestra introducción.","code":""},{"path":"tipos-datos.html","id":"numericas","chapter":"Capítulo 5 Tipos de datos","heading":"5.1 Variables numéricas","text":"[X] Variables numéricas (individuales)[ ] Variables de caracteres[ ] Variables lógicas[ ] Variables de tipo fechaProbablemente el dato más sencillo y obvio de entender sean los datos numéricos, datos que ya hemos usado en nuestros primeros pasos como calculadora.En el código anterior, tanto como b como la suma + b son de tipo numérico, algo que podemos comprobar con la función class() (nos devuelve numeric).También podemos comprobar su naturaleza con typeof(), que nos devuelve la naturaleza del dato tal cual es guardada en R.Fíjate que ambas órdenes combinadas nos dicen que las variables son de tipo numérico pero concretamente de tipo double: dichas variables son entendidas internamente como números con decimales (aunque los veamos), lo que en matemáticas se llaman números reales (por curiosidad: el término double viene de lenguajes de programación antiguos como C, que significa «doble precisión», para indicarle que reserve 8 bytes - 64 bits - de memoria). Durante el curso distinguiremos entre distintos tipos de números, para nosotros serán siempre de clase numeric y de tipo double, pero podríamos definir números enteros o integer (sin decimales, ahorrando huecos en memoria).Con los datos numéricos podemos realizar todas las operaciones que se nos ocurriría hacer en una calculadora, como sumar (+), restar (-), multiplicar (*), dividir (/), raíz cuadrada (sqrt()), valor absoluto (abs()), elevar al cuadrado (^2), elevar al cubo (^3), etc.","code":"\na <- 1\nb <- 2\na + b## [1] 3\n# Clase de las variables\nclass(a)## [1] \"numeric\"\nclass(b)## [1] \"numeric\"\nclass(a + b)## [1] \"numeric\"\n# Topología interna\ntypeof(a)## [1] \"double\"\ntypeof(b)## [1] \"double\"\ntypeof(a + b)## [1] \"double\"\n# Dato numérico (entero)\na <- 1L\nclass(a)## [1] \"integer\"\ntypeof(a)## [1] \"integer\"\n# Definimos dos variables numéricas\na <- 1\nb <- -2\n\n# Suma y resta\na + b## [1] -1\na - b## [1] 3\n# Multiplicación y división\na * b## [1] -2\na / b## [1] -0.5\n# Raíz cuadrada\nsqrt(a)## [1] 1\n# Valor absoluto\nabs(b)## [1] 2\n# Potencias\na^2## [1] 1\nb^3## [1] -8"},{"path":"tipos-datos.html","id":"caracter","chapter":"Capítulo 5 Tipos de datos","heading":"5.2 Variables de tipo caracter (texto)","text":"[X] Variables numéricas (individuales)[X] Variables de caracteres[ ] Variables lógicas[ ] Variables de tipo fechaPero solo de números viven los datos: imagina que además de la edad de una persona queremos guardar su nombre.Fíjate que ahora tenemos en nombre una variable de tipo character, es decir, una cadena de texto (conocido en otros lenguajes como string o char): letras y caracteres entre comillas.","code":"\nedad <- 32\nnombre <- \"Javier\"\n\nclass(edad)## [1] \"numeric\"\ntypeof(edad)## [1] \"double\"\nclass(nombre)## [1] \"character\"\ntypeof(nombre)## [1] \"character\""},{"path":"tipos-datos.html","id":"nuestra-primera-función-pastepaste0","chapter":"Capítulo 5 Tipos de datos","heading":"5.2.1 Nuestra primera función: paste/paste0","text":"Las cadenas de texto son un tipo especial de dato, con los que obviamente podremos hacer operaciones aritméticas, pero si podemos hacer operaciones propias de cadenas de texto como puede ser la función paste(). Dicha función nos permite pegar dos cadenas de caracteres, decidiendo que caracter queremos que vaya entre palabra con el argumento sep =.Si queremos pegar cadenas de texto sin ningún tipo de caracter, existe una forma más abreviada y limpia de ejecutar la orden, usando la función paste0()Cuando hemos ejecutado paste() estamos ejecutando lo que se conoce como una función: una palabra reservada que representa un conjunto de órdenes, y que se ejecuta partir de unos argumentos de entrada. En el caso de la función paste() puede tener varios argumentos: las cadenas de texto que queremos copiar, y un argumento opcional llamado sep, que podemos darle un valor con concreto o dejarlo sin especificar. Lo que hará R será tomar su valor por defecto igual sep = \" \" (por defecto, la función paste() pega cadenas de texto con un espacio entre ellas). Prueba ejecutar ? paste en consola para ver las opciones en el panel de ayuda.","code":"\nnombre <- \"Javier\"\napellido <- \"Álvarez\"\npaste(nombre, apellido, sep = \"\") # todo junto## [1] \"JavierÁlvarez\"\npaste(nombre, apellido, sep = \" \") # separados por un espacio## [1] \"Javier Álvarez\"\npaste(nombre, apellido, sep = \".\") # separados por un punto .## [1] \"Javier.Álvarez\"\n# Son equivalentes\npaste(nombre, apellido, sep = \"\") # todo junto## [1] \"JavierÁlvarez\"\npaste0(nombre, apellido) # todo junto sin nada separando## [1] \"JavierÁlvarez\"\n# Son equivalentes\npaste(nombre, apellido, sep = \" \")## [1] \"Javier Álvarez\"\npaste(nombre, apellido)## [1] \"Javier Álvarez\""},{"path":"tipos-datos.html","id":"nuestro-primer-paquete-glue","chapter":"Capítulo 5 Tipos de datos","heading":"5.2.2 Nuestro primer paquete: glue","text":"Otra forma más intuitiva de trabajar con textos y variables numéricas es usar el paquete glue, que nos permite pegar cadenas de texto variables numéricas de forma simbólica.Recuerda que install.packages() es solo necesario la primera que «compramos el libro»: nos bajamos una serie de archivos nuestro ordenador. Una vez que hemos comprado el libro, cada vez que queramos usarlo bastará con indicarle que nos traiga ese libro concreto con library().El paquete glue nos permite pegar de una forma mucho más legible cadenas de textoTambién podemos hacer uso de dicha función sin tener los valores numéricos previamente guardados en variables. ","code":"\ninstall.packages(\"glue\") # solo la primera vez\nlibrary(glue)\n# Ejemplo 1\nedad <- 32\nglue(\"La edad es de {edad} años\")## La edad es de 32 años\npaste(\"La edad es de\", edad, \"años\") # equivalente## [1] \"La edad es de 32 años\"\n# Ejemplo 2\nedad <- 32\nunidades <- \"años\"\nglue(\"La edad es de {edad} {unidades}\")## La edad es de 32 años\n# Otra forma sin definir variables a priori\nglue(\"La edad es de {32} años\")## La edad es de 32 años"},{"path":"tipos-datos.html","id":"logicas","chapter":"Capítulo 5 Tipos de datos","heading":"5.3 Variables lógicas (TRUE/FALSE)","text":"[X] Variables numéricas (individuales)[X] Variables de caracteres[X] Variables lógicas[ ] Variables de tipo fechaProbablemente el tipo de datos más importante en todo lenguaje de programación son las variables lógicas. Un valor lógico puede tomar dos valores (en realidad pueden tomar un tercer valor, NA, las siglas de available para representar datos ausentes, pero lo veremos más adelante):TRUE (guardado internamente como un 1).FALSE (guardado internamente como un 0).Este tipo de variables, también conocidas como variables binarias (solo dos valores) o booleanas, son la base de la programación ya que cada bit de nuestro ordenador puede guardar un 1 o un 0.Ahora nuestas variables son guardadas como logical, y pueden tomar los valores TRUE/FALSE, aunque internamente son guardados como 1/0. Es importante entender que son variables de texto:\"TRUE\" es un texto (internamente idéntico rojo o azul)TRUE es una variable lógicaEstos valores suelen ser resultado de evaluar condiciones lógicas. Por ejemplo, imaginemos que queremos comprobar si una persona está soltero o , y si tiene carnet de conducir o . Basta con que ejecutemos la orden soltero == TRUE, que nos devolverá TRUE si está soltero, y FALSE en caso contrario. De igual manera podremos hacer carnet_conducir == TRUE. IMPORTANTE: cuando queremos comparar si un elemento es igual otro, usaremos el operador de comparación ==, pudiendo usar también su opuesto != («distinto de»).Por el mismo razonamiento podemos comparar si una variable numérica o de tipo caracter es igual o distinto un valor dado, incluso para las numéricas podemos comparar si son menores o mayores que un número.¿Tiene la persona menos de 32 años? ¿Tiene justo 32 años? ¿Tiene 32 años o más?¿La persona se llama Carlos?Fíjate que para comparaciones tenemos «igual » == frente distinto !=, pero también comparaciones de orden como <=, > o >=. Las condiciones lógicas pueden ser combinadas, principalmente de dos maneras:Intersección: todas las condiciones concatenadas se deben cumplir (conjunción y, operador &) para devolver un TRUE.Intersección: todas las condiciones concatenadas se deben cumplir (conjunción y, operador &) para devolver un TRUE.Unión: basta con que una de las condiciones concatenadas se cumpla (conjunción o, operador |) para devolver un TRUE.Unión: basta con que una de las condiciones concatenadas se cumpla (conjunción o, operador |) para devolver un TRUE.Por ejemplo, podríamos preguntarnos si la persona tiene más de 32 años y está soltero (AMBAS deben cumplirse).Vemos que el resultado es FALSE ya que solo se cumple una de las condiciones: devolvería TRUE si preguntamos si tiene más de 30 años y está soltero, o si solo pedimos una de las dos condiciones (¿está soltero y/o tiene más de 32 años?).","code":"\nsoltero <- TRUE # ¿Es soltero? --> SÍ\ncarnet_conducir <- FALSE # ¿Tiene carnet de conducir? --> NO\n\nclass(soltero)## [1] \"logical\"\ntypeof(soltero)## [1] \"logical\"\nclass(carnet_conducir)## [1] \"logical\"\ntypeof(carnet_conducir)## [1] \"logical\"\n# Texto\ntexto <- \"TRUE\"\ntexto + 1## Error in texto + 1: argumento no-numérico para operador binario\n# Lógica\nlogica <- TRUE\nlogica + 1## [1] 2\nsoltero == TRUE## [1] TRUE\nsoltero != TRUE # igual que soltero == FALSE## [1] FALSE\ncarnet_conducir == TRUE## [1] FALSE\ncarnet_conducir != TRUE## [1] TRUE\nedad < 32## [1] FALSE\nedad == 32## [1] TRUE\nedad >= 32## [1] TRUE\nnombre == \"Carlos\"## [1] FALSE\nedad > 32 & soltero == TRUE## [1] FALSE\n# Equivalente (al ser soltero un valor ya de por si lógico)\nedad > 32 & soltero## [1] FALSE\nedad > 32 | soltero # nos sirve con que alguna se cumpla## [1] TRUE\nedad > 32 & soltero # deben cumplirse ambas## [1] FALSE\nedad > 30 & soltero # deben cumplirse ambas## [1] TRUE"},{"path":"tipos-datos.html","id":"fechas","chapter":"Capítulo 5 Tipos de datos","heading":"5.4 Variables de tipo fecha","text":"[X] Variables numéricas (individuales)[X] Variables de caracteres[X] Variables lógicas[X] Variables de tipo fechaPor último, vamos ver un tipo de datos muy especial: los datos de tipo fecha. Una fecha podría ser priori una simple cadena de texto \"2021-04-21\" pero podemos usar la función .Date() para que R entienda que esa cadena de texto representa un instante temporal. Fíjate la diferencia entre una fecha en texto y una fecha con .Date().En el momento en que convertimos la cadena de texto fecha, aunque se visualice como un texto, internamente es un número, por lo que podemos restar fechas (días entre ambas), podemos sumar números fechas (fecha días después), etc. Como ya hemos dicho, las fechas y momentos temporales serán meras cadenas de caracter sino que tienen clases especiales asociadas. Las fechas serán guardadas internamente como el número de días transcurridos desde el 1 de enero de 1970, y las horas como número de segundos desde el 1 de enero de 1970 (para la clase POSIXct) o una lista de segundos, minutos y horas (para la clase POSIXlt).¿Cómo obtener automáticamente la fecha de hoy? La función Sys.Date() nos devuelve directamente la fecha y hora en el momento de la ejecución de la orden.Para convertir una cadena de texto fecha, basta usar la función .Date(), pasándole como argumento la fecha en formato \"yyyy-mm-dd\" por defecto.Si introducimos otro tipo de formato, debemos especificárselo en un segundo argumento, para R sepa el formato de fecha que le estamos pasando ERROR: sin pasar fecha se puede operarSi tenemos una fecha como caracter, nunca podremos hacer operaciones (por ejemplo, restarle una unidad temporal, en este caso un día).Fíjate la diferencia cuando lo convertimos en fecha Dentro del entorno del paquete lubridate tenemos bastantes funciones útiles para trabajar con fechas como las siguientesAdemás el paquete nos proporciona herramientas para extraer la fecha y hora actuales con las funciones today() y now()También tenemos disponibles en dicho paquete funciones para extraer facilmente algunas variables temporales como el día de la semana, el mes o el cuatrimestre, con las funciones year(), months(), day() o wday() (día de la semana).Al igual que podemos realizar operaciones aritméticas sencillas con las fechas, también podemos realizar comparaciones, por ejemplo, si el día actual es menor o mayor que otra fecha dada. ","code":"\n# Cadena de texto\nfecha_char <- \"2021-04-21\"\nfecha_char + 1## Error in fecha_char + 1: argumento no-numérico para operador binario\n# Fecha, mostrada como un texto pero guardada internamente como un número\nfecha_date <- as.Date(fecha_char, format = \"%Y-%m-%d\")\nfecha_date + 1## [1] \"2021-04-22\"\nfecha <- Sys.Date()\nfecha## [1] \"2021-12-27\"\nfecha - 7 # una semana antes## [1] \"2021-12-20\"\nclass(fecha) # de clase fecha## [1] \"Date\"\nas.Date(\"2021-03-10\") # formato por defecto## [1] \"2021-03-10\"\nas.Date(\"10-03-2020\", \"%d-%m-%Y\") # con día-mes-año (4 cifras)## [1] \"2020-03-10\"\nas.Date(\"10-03-20\", \"%d-%m-%y\")  # con día-mes-año (2 cifras)## [1] \"2020-03-10\"\nas.Date(\"03-10-2020\", \"%m-%d-%Y\") # con mes-día-año (4 cifras)## [1] \"2020-03-10\"\nas.Date(\"Octubre 21, 1995 21:24\", \"%B %d, %Y %H:%M\") # fecha escrita## [1] NA\n\"2021-03-10\" - 1 # error## Error in \"2021-03-10\" - 1: argumento no-numérico para operador binario\nfecha <- as.Date(\"2021-03-10\") - 1 # día previo\nfecha## [1] \"2021-03-09\"\ninstall.packages(\"lubridate\") # solo la primera vez\nlibrary(lubridate)\nymd_hms(\"2017-11-28T14:02:00\") # convertir a fecha una cadena año-mes-día + hora## [1] \"2017-11-28 14:02:00 UTC\"\nydm_hms(\"2017-22-12 10:00:00\") # convertir a fecha una cadena año-día-mes + hora## [1] \"2017-12-22 10:00:00 UTC\"\ndmy_hms(\"1 Jan 2017 23:59:59\") # convertir a fecha una cadena textual de fecha + hora## [1] \"2017-01-01 23:59:59 UTC\"\nmdy(\"July 4th, 2000\") # convertir a fecha una cadena textual de fecha## [1] \"2000-07-04\"\nymd(20170131)## [1] \"2017-01-31\"\ntoday()## [1] \"2021-12-27\"\nnow()## [1] \"2021-12-27 11:19:13 CET\"\nfecha <- now()\nyear(fecha)## [1] 2021\nmonth(fecha)## [1] 12\nday(fecha)## [1] 27\nwday(fecha, week_start = 1) # Día de la semana (empezando por el lunes)## [1] 1\nhour(fecha)## [1] 11\nminute(fecha)## [1] 19\nsecond(fecha)## [1] 13.12445\nweek(fecha) # Número de semana (del año)## [1] 52\nfecha_actual <- now()\nfecha_actual > ymd(20170131) # Actual vs 2017-01-31## [1] TRUE\nfecha_actual > ymd(21000131) # Actual vs 2100-01-31## [1] FALSE"},{"path":"tipos-datos.html","id":"consejos-2","chapter":"Capítulo 5 Tipos de datos","heading":"5.5 Consejos","text":"CONSEJOS Recuperar un comando y autocompletarSi haces click con el ratón en la consola y pulsas la flecha «arriba» del teclado, te irá apareciendo todo el historial de órdenes ejecutadas. Es una manera de ahorrar tiempo para ejecutar órdenes similares las ya ejecutadas. Si empiezas escribir el nombre de una variable pero te acuerdas exactamente de su nombre, pulsando tabulador te autocompletará solo. Convertir tipos de datosA veces la lectura de variables numéricas de nuestros archivos puede hacer que un número, por ejemplo 1, sea leído como la cadena de texto \"1\", con la que podemos operar como un número. Las funciones .numeric(), .character() y .logical() nos permiten convertir una variable en tipo numérico, caracter o lógico, respectivamente. ","code":"\n\"1\" + 1## Error in \"1\" + 1: argumento no-numérico para operador binario\nas.numeric(\"1\") + 1## [1] 2\nas.character(1)## [1] \"1\"\nas.logical(c(0, 1))## [1] FALSE  TRUE"},{"path":"tipos-datos.html","id":"ejercicios-1","chapter":"Capítulo 5 Tipos de datos","heading":"5.6 📝 Ejercicios","text":"(haz click en las flechas para ver soluciones)📝Ejercicio 1: define una variable que guarde tu edad, otra con tu nombre, otra respondiendo la pregunta «¿tengo hermanos?» y otra con la fecha de tu nacimiento. Solución: 📝Ejercicio 2: define otra variable con tus apellidos y junta las variables nombre y apellidos en una sola variable nombre_completo. Solución: 📝Ejercicio 3: construye una frase que diga «Hola, llamo … y tengo … años. Nací el … de … de …» (con el nombre completo). Solución: 📝Ejercicio 4: calcula los días que han pasado desde la fecha de tu nacimiento Solución: 📝Ejercicio 5: obtén una variable lógica que nos diga si se cumplen (todas) las condiciones ) menor de 30 años; ii) con hermanos; iii) nacido en 1990 o posterior. Solución: 📝Ejercicio 6: obtén una variable lógica que nos diga si se cumplen (al menos) alguna de las condiciones ) menor de 30 años; ii) con hermanos; iii) nacido en 1990 o posterior. Solución: 📝Ejercicio 7: calcula la fecha 11 días más tarde tu fecha de nacimiento. Obtén la semana del año de dicha fecha y el día de la semana. Solución: 📝Ejercicio 8: define dos números cualesquiera en variable y b. Calcula su suma y determina cual es mayor. Solución: ","code":"\nedad <- 32 # tipo numeric\nnombre <- \"Javier\" # tipo caracter\nhermanos <- TRUE # tipo hermanos\nfecha_nacimiento <- as.Date(\"1989-09-10\") # tipo fecha\n# Apellidos\napellidos <- \"Álvarez Liébana\"\n\n# Pegamos\nnombre_completo <- glue(\"{nombre} {apellidos}\")\nnombre_completo## Javier Álvarez Liébana\n# Otra forma\nnombre_completo <- paste(nombre, apellidos)\nnombre_completo## [1] \"Javier Álvarez Liébana\"\ndia_nacimiento <- day(fecha_nacimiento)\nmes_nacimiento <- month(fecha_nacimiento)\na_nacimiento <- year(fecha_nacimiento)\n\nglue(\"Hola, me llamo {nombre_completo} y tengo {edad} años. Nací el {dia_nacimiento} del {mes_nacimiento} de {a_nacimiento}\")## Hola, me llamo Javier Álvarez Liébana y tengo 32 años. Nací el 10 del 9 de 1989\ndays(today() - fecha_nacimiento)## [1] \"11796d 0H 0M 0S\"\n# Se tienen que cumplir todas\nedad < 30 & fecha_nacimiento >= as.Date(\"1990-01-01\") & hermanos## [1] FALSE\n# Se tienen que cumplir todas\nedad < 30 | fecha_nacimiento >= as.Date(\"1990-01-01\") | hermanos## [1] TRUE\n# Podemos sumar porque es fecha\nfecha_post <- fecha_nacimiento + 11\nfecha_post## [1] \"1989-09-21\"\n# Semana del año\nweek(fecha_post)## [1] 38\n# Día de la semana (versión americana, empiezan el domingo)\nwday(fecha_post)## [1] 5\n# Día de la semana (versión española)\nwday(fecha_post, week_start = 1)## [1] 4\n# Día de la semana en texto\nweekdays(fecha_post)## [1] \"Thursday\"\na <- -5\nb <- 7\n\n# Suma\nc <- a + b\nc## [1] 2\n# Comparaciones\na == b # ¿a = b?## [1] FALSE\na < b # ¿a < b?## [1] TRUE"},{"path":"vectores.html","id":"vectores","chapter":"Capítulo 6 Vectores","heading":"Capítulo 6 Vectores","text":"Scripts usados:script03.R: tipos de datos y funciones usadas con ellos. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script03.RHemos visto como poder almacenar elementos individuales: la edad de una persona, su estado civil con una variable lógica, su nombre, su fecha de nacimiento…¿Y si en lugar de querer almacenar un solo elemento, por ejemplo edad <- 32, tenemos una colección de elementos (las edades de toda nuestra familia, por ejemplo)? En este capítulo vamos ver un clásico de cualquier lenguaje de programación: los vectores o arrays, que son más que una concatenación de elementos del mismo tipo. De hecho un número individual (por ejemplo, x <- 1) es en realidad un vector de longitud uno (un solo elemento).Si sabes algo de matemáticas, un vector es lo que solemos representar como \\(\\overrightarrow{x} = \\left[1, 2, 3 \\right]\\), pero te preocupes si nunca visto esta forma de representarlos. Vamos empezar de cero.","code":""},{"path":"vectores.html","id":"vectores-numéricos","chapter":"Capítulo 6 Vectores","heading":"6.1 Vectores numéricos","text":"La forma más sencilla de crear un vector en R es con el comando c() (de concatenar elementos), y basta con introducir sus elementos entre paréntesis, y separados por comas. Voy crear el vector con las 4 edades de los miembros de mi familia.Como ves ahora en el environment (entorno, arriba la derecha) tenemos una colección de elementos guardada, con cuatro en concreto, guardados en una misma variable edades. La longitud de un vector se puede calcular con el comando length() (nos devolverá el número de elementos de la variable que le pasemos como argumento).Además podemos concatenar su vez vectores: vamos concatenar el vector edades consigo mismo, y añadiéndole al final un 8.Esta última concatenación lo que nos ha dado son, primero, los cuatro elementos que ya teníamos en edades, después de nuevo los cuatro elementos, y por último un 8.","code":"\nedades <- c(32, 27, 60, 61)\nedades## [1] 32 27 60 61\nlength(edades)## [1] 4\nc(edades, edades, 8)## [1] 32 27 60 61 32 27 60 61  8"},{"path":"vectores.html","id":"secuencias-numéricas-con-un-patrón","chapter":"Capítulo 6 Vectores","heading":"6.2 Secuencias numéricas con un patrón","text":"Muchas veces nos gustaría crear vectores de una forma mucho más rápida. Supongamos que queremos un vector de identificadores de 21 personas, asignando números desde el 1 hasta el 21. Si construyéramos el vector como antes, tendríamos que ejecutar el comando c(1, 2, 3, 4, 5, 6, ...) hasta llegar al número 21. ¿Un poco largo, ?Hay un atajo: el comando seq() nos permite crear una secuencia desde un elemento inicial hasta un elemento final, avanzando de uno en uno.Es importante que perdamos el foco: programar es similar escribir en un idioma, por lo que si hay algo que se puede decir de una forma más limpia y que se entienda mejor, ¿por qué usarlo? Siempre que queramos definir secuencias entre dos números naturales (por ejemplo, entre 1 y un valor n), cuya distancia entre elementos consecutivos sea uno, el comando 1:n nos devuelve lo mismo que la orden seq(1, n). Además, si el elemento inicial es mayor que el final, R entenderá solo que la secuencia la queremos decreciente. También podemos definir otro tipo de distancia entre dos elementos consecutivos (conocido como paso de discretización), por ejemplo de 0.5 en 0.5, o de 1.7 en 1.7Otras veces nos interesará definir una secuencia entre un valor inicial y un valor final, pero nos dará igual la distancia entre cada elemento: solo nos importa que tenga un número concreto de elementos (y que sea R el que decida la distancia entre elementos consecutivos para conseguirlo). Otro atajo que podemos usar para definir secuencias de números con un patrón es definir vectores de elementos repetidos, por ejemplo un vector lleno de ceros. La función rep() nos permite repetir un elemento un número fijado de veces.solo podemos repetir un número sino que podemos repetir vectores enteros.Esa repetición además podemos definirla también de forma intercalada: en lugar de repetir c(0, 1, 2) cuatro veces seguidas, queremos cuatro 0, después cuatro 1, y después cuatro 2.","code":"\nseq(1, 21) # secuencia desde 1 hasta 21 de uno en uno##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21\nn <- 21\n1:n # secuencia desde 1 hasta n (21) de uno en uno##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21\nn:1 # secuencia decreciente##  [1] 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1\nseq(1, 10, by = 0.5) # secuencia desde 1 a 10 de 0.5 en 0.5##  [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0\n## [16]  8.5  9.0  9.5 10.0\nseq(1, 21, by = 1.7) # secuencia desde 1 a 21 de 1.7 en 1.7##  [1]  1.0  2.7  4.4  6.1  7.8  9.5 11.2 12.9 14.6 16.3 18.0 19.7\nseq(1, 50, l = 11) # secuencia desde 1 a 50 de longitud 11##  [1]  1.0  5.9 10.8 15.7 20.6 25.5 30.4 35.3 40.2 45.1 50.0\nseq(1, 50, l = 8) # secuencia desde 1 a 50 de longitud 8## [1]  1  8 15 22 29 36 43 50\nrep(0, 7) # vector de 7 ceros## [1] 0 0 0 0 0 0 0\nrep(c(0, 1, 2), 4) # repetimos el vector c(0, 1, 2) 4 veces##  [1] 0 1 2 0 1 2 0 1 2 0 1 2\nrep(c(0, 1, 2), each = 4) # cuatro 0, luego cuatro 1, luego cuatro 2##  [1] 0 0 0 0 1 1 1 1 2 2 2 2"},{"path":"vectores.html","id":"vectores-de-caracteres-texto","chapter":"Capítulo 6 Vectores","heading":"6.3 Vectores de caracteres (texto)","text":"Un error común es asociar el concepto de vectores solo números: un vector es una colección o concatenación de elementos del mismo tipo pero tienen porque ser necesariamente números. Vamos crear una frase de ejemplo, un vector de 4 elementos de tipo texto (en R se llaman char): \"Mi\", \"nombre\", \"es\" \"Javier\".Como antes, las variables de tipo char o character van entre comillas dobles, ya que es un cadena de texto.Ya tenemos nuestro primer vector de texto de longitud 4. Cuando usamos la función paste() con variables diferentes, usábamos sep = ... para decidir el caracter con el que pegamos dichas cadenas texto. Cuando la función paste() la aplicamos un vector de caracteres, decidiremos que caracter queremos que vaya entre palabra con el argumento collapse =.Ahora que sabemos lo que es un vector de núemros, por ejemplo el vector 1:7 (el conjunto de naturales desde el 1 hasta el 7), podemos definir cadenas de texto que compartan por ejemplo un prefijo (variable_1, variable_2, …)De igual manera podemos hacer uso de glue combinando cadenas de texto y vectores numéricos, obteniendo vectores de frases.¿Y si queremos pasar todo mayúscula o todo minúscula? ¿Y si queremos sustituir un caracter (por ejemplo, .) por otro en todos los elementos?R también nos proporciona algunas funciones muy sencillas (del paquete {base}) de usar para dichas tareas. Aquí un ejemplo de algunas de ellas.El paquete {base} también nos permite buscar y reemplazar patrones concretos en cadenas de texto (por ejemplo, sustituir toda letra «o» por el caracter «*»), con la función gsub(). ","code":"\nmi_nombre <- c(\"Mi\", \"nombre\", \"es\", \"Javier\")\nmi_nombre## [1] \"Mi\"     \"nombre\" \"es\"     \"Javier\"\npaste(mi_nombre, collapse = \"\") # todo junto## [1] \"MinombreesJavier\"\npaste(mi_nombre, collapse = \" \") # separados por un espacio## [1] \"Mi nombre es Javier\"\npaste(mi_nombre, collapse = \".\") # separados por un punto .## [1] \"Mi.nombre.es.Javier\"\npaste0(mi_nombre) # todo junto sin nada separando## [1] \"Mi\"     \"nombre\" \"es\"     \"Javier\"\npaste0(\"variable\", 1:7) # a la palabra «variable» le pegamos los números del 1 al 7## [1] \"variable1\" \"variable2\" \"variable3\" \"variable4\" \"variable5\" \"variable6\"\n## [7] \"variable7\"\npaste(\"variable\", 1:7, sep = \"_\") # separado por una barra baja## [1] \"variable_1\" \"variable_2\" \"variable_3\" \"variable_4\" \"variable_5\"\n## [6] \"variable_6\" \"variable_7\"\nlibrary(glue)\nedad <- 10:15 # edades\nglue(\"La edad es de {edad} años\")## La edad es de 10 años\n## La edad es de 11 años\n## La edad es de 12 años\n## La edad es de 13 años\n## La edad es de 14 años\n## La edad es de 15 años\n# Otra forma sin definir variables a priori\nglue(\"La edad es de {10:15} años\")## La edad es de 10 años\n## La edad es de 11 años\n## La edad es de 12 años\n## La edad es de 13 años\n## La edad es de 14 años\n## La edad es de 15 años\ntexto <- c(\"Hola.\", \"qué\", \"ase?\", \"todo\", \"bien.\", \"y yo\",\n           \"que\", \"ME\", \"ALEGRO\")\ntoupper(texto) # todo a mayúscula## [1] \"HOLA.\"  \"QUÉ\"    \"ASE?\"   \"TODO\"   \"BIEN.\"  \"Y YO\"   \"QUE\"    \"ME\"    \n## [9] \"ALEGRO\"\ntolower(texto) # todo a minúscula## [1] \"hola.\"  \"qué\"    \"ase?\"   \"todo\"   \"bien.\"  \"y yo\"   \"que\"    \"me\"    \n## [9] \"alegro\"\ngsub(\"o\", \"*\", texto) # toda \"o\" en el texto será sustituida por *## [1] \"H*la.\"  \"qué\"    \"ase?\"   \"t*d*\"   \"bien.\"  \"y y*\"   \"que\"    \"ME\"    \n## [9] \"ALEGRO\""},{"path":"vectores.html","id":"vectores-lógicos-truefalse","chapter":"Capítulo 6 Vectores","heading":"6.4 Vectores lógicos (TRUE/FALSE)","text":"Antes hemos comentado que las variables lógicas suelen aparecer como resultado de comparaciones de elementos. Por ejemplo, imaginemos ahora que definimos un vector de números x <- c(1.5, -1, 2, 4, 3, -4). ¿Qué numeros de x son menores que 2? Basta con que ejecutemos la orden x < 2, que nos devolverá TRUE/FALSE en cada hueco, en función de si cumple (TRUE) o (FALSE) la condición pedida.El primer, segundo y sexto elemento del vector son los únicos elementos (estrictamente) menores que 2, de ahí que en el primer, segundo y sexto elemento aparezca un TRUE y en el resto un FALSE. Es importante recordar que al evaluar una condición lógica sobre un vector de longitud n, la salida sigue siendo un vector de longitud n pero con valores lógicos.Dicha condición lógica puede hacerse con otros operadores como <=, > o >=. Al igual que antes, las condiciones pueden ser combinadas. Por ejemplo, vamos calcular qué elementos del vector c(1.5, -1, 2, 4, 3, -4) sean menores que 3 y además mayores que 0, y los elementos menores que 2 o mayores que 3.","code":"\nx <- c(1.5, -1, 2, 4, 3, -4)\nx < 2## [1]  TRUE  TRUE FALSE FALSE FALSE  TRUE\nx <= 2## [1]  TRUE  TRUE  TRUE FALSE FALSE  TRUE\nx > 2## [1] FALSE FALSE FALSE  TRUE  TRUE FALSE\nx >= 2## [1] FALSE FALSE  TRUE  TRUE  TRUE FALSE\nx == 2## [1] FALSE FALSE  TRUE FALSE FALSE FALSE\nx != 2## [1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\nx <- c(1.5, -1, 2, 4, 3, -4)\nx < 3 & x > 0 # Solo los que cumplen ambas condiciones## [1]  TRUE FALSE  TRUE FALSE FALSE FALSE\nx < 2 | x > 3 # Los cumplen al menos una de ellas## [1]  TRUE  TRUE FALSE  TRUE FALSE  TRUE"},{"path":"vectores.html","id":"ausentes","chapter":"Capítulo 6 Vectores","heading":"6.5 Datos ausentes: NA y NaN","text":"La vida siempre es perfecta así que en muchas ocasiones nos encontraremos con lo que llamamos en estadística un dato ausente o missing value, un valor que tenemos en nuestra variable, y un ejemplo práctico lo tenemos con los datos de vacunación de covid del Ministerio de Sanidad. Cada día se publicaba un PDF con los datos de vacunación PERO…se publicabann datos los fines de semana: en dichas fechas hay datos que tenemos, y en R se representan por NA (significa available).","code":""},{"path":"vectores.html","id":"na-not-available","chapter":"Capítulo 6 Vectores","heading":"6.5.1 NA: not available","text":"Vamos crear un vector de números con datos ausentes con la orden x <- c(1, NA, 3, NA, NA, 5, 6): el vector tendrá longitud 7 pero en el segundo, cuarto y quinto elemento tendremos datos faltantes, un lugar que tenemos relleno (pero que eliminamos).¿Puedes aventurar qué sucede cuando multiplicamos ese vector por una constante (por 2, por ejemplo)?Un dato que tenemos, multiplicado por 2, sigue siendo un dato ausente. Es muy importante para evitar resultados erróneos que entendamos que un dato ausente computa en una operación aritmética, es un hueco vacío. Si hacemos la suma del vector, estamos sumando números más datos ausentes, por lo que el resultado final será también un dato ausente. Si tenemos algún dato ausente en nuestro vector, la suma final está su vez ausente, ¡podemos saber cuánto vale! Una manera de localizar que elementos están ausentes en nuestrps vectores es con la función .na(), una función que nos devuelve un vector de valores lógico: TRUE si el elemento está ausente y FALSE si lo está.Dichos datos ausentes se pueden eliminar con la función na.omit() (aunque veces lo que nos interesa es que sea ausente, introduciendo el punto medio entre su valor anterior y su valor posterior, por ejemplo).","code":"\nx <- c(1, NA, 3, NA, NA, 5, 6) # Vector numérico con datos faltante\nlength(x) # longitud del vector## [1] 7\nx## [1]  1 NA  3 NA NA  5  6\n2 * x # operación aritmética con un vector con NA## [1]  2 NA  6 NA NA 10 12\n1 + NA + 3## [1] NA\nis.na(x) # TRUE si está ausente (NA), FALSE si no lo está.## [1] FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE\nna.omit(x)## [1] 1 3 5 6\n## attr(,\"na.action\")\n## [1] 2 4 5\n## attr(,\"class\")\n## [1] \"omit\""},{"path":"vectores.html","id":"nan-not-a-number","chapter":"Capítulo 6 Vectores","heading":"6.5.2 NaN: not a number","text":"Hay un tipo de dato, como resultado de operaciones permitidas o cuyo resultado es indeterminado, que en R lo veremos como NaN: number, un resultado fruto de una indeterminación, como por ejemplo la operación 0/0 (cuyo límite está definido). Importante saber que también existe una forma de denotar al infinito como Inf, siendo el resultado de algunas operaciones como 1/0.De la misma manera que podemos localizar valores NA, tenemos nuestra disposición las funciones .infinte() y .nan() para detectar que elementos de nuestro vector son Inf o NaN, respectivamente.","code":"\n1/0## [1] Inf\n0/0## [1] NaN\nx <- c(1, NA, 3, 4, Inf, 6, 7, Inf, NaN, NA)\nis.na(x)##  [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\nis.nan(x)##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\nis.infinite(x)##  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE"},{"path":"vectores.html","id":"consejos-3","chapter":"Capítulo 6 Vectores","heading":"6.6 Consejos","text":"CONSEJOS Expresiones regularesDentro del entorno de paquetes tidyverse, el paquete stringr permite un manejo más complejo de cadenas de texo (como el uso de expresiones regulares).\nImagen/gráfica 6.1: Paquete stringr para manejar cadenas de texto más complejas\n ","code":""},{"path":"vectores.html","id":"ejercicios-2","chapter":"Capítulo 6 Vectores","heading":"6.7 📝 Ejercicios","text":"(haz click en las flechas para ver soluciones)📝Ejercicio 1: define un vector que contenga los números 1, 10, -1 y 2, y guárdalo en una variable llamada vector_num. Solución: 📝Ejercicio 2: obtén la longitud del vector anterior vector_num. Solución: 📝Ejercicio 3: crea un vector con las palabras “Hola”, “”, “llamo” (y tu nombre y apellidos), y pega luego sus elementos de forma que la frase esté correctamente escrita en castellano. Tras hacerlo, añade “y tengo 30 años”. Solución: 📝Ejercicio 4: crea una secuencia de números, que empiece en -1, que acabe en 32, y que vaya saltando de 3 en 3. Solución: 📝Ejercicio 5: crea una secuencia de números, que empiece en -1, que acabe en 32, y que tenga longitud 12. Solución: 📝Ejercicio 6: crea una secuencia que empiece en 1 y recorra todos los naturales hasta el 10. Después crea otra secuencia de longitud 7 que todos los números sean 3. Solución: 📝Ejercicio 7: crea una secuencia que repita 5 veces el patrón 1, 2, 3. Después crea otra que repita dicho patrón pero de forma intercalada, con 5 veces 1, después 5 veces 2 y después 5 veces 3.Solución: 📝Ejercicio 8: crea un vector con las edades de cuatro conocidos o familiares. Tras ello, determina cuáles de ellos tienen menos de 20 años, 30 años o más, menos de 40 años y más de 65 años.Solución:","code":"\n# Vector de números\nvector_num <- c(1, 10, -1, 2)\nvector_num## [1]  1 10 -1  2\n# Longitud del vector\nlength(vector_num)## [1] 4\n# Definiendo el vector\nvector_char <- c(\"Hola\", \"me\", \"llamo\", \"Javier\",\n                 \"Álvarez\", \"Liébana\")\n\n# Pegamos\nfrase <- paste(vector_char, collapse = \" \")\nfrase## [1] \"Hola me llamo Javier Álvarez Liébana\"\n# Añadimos frase\nglue(\"{frase} y tengo 30 años.\")## Hola me llamo Javier Álvarez Liébana y tengo 30 años.\n# Otra forma\npaste0(frase, \" y tengo 30 años.\")## [1] \"Hola me llamo Javier Álvarez Liébana y tengo 30 años.\"\n# Otra forma\npaste(frase, \"y tengo 30 años.\")## [1] \"Hola me llamo Javier Álvarez Liébana y tengo 30 años.\"\nsecuencia <- seq(-1, 32, by = 3)\nsecuencia##  [1] -1  2  5  8 11 14 17 20 23 26 29 32\nlength(secuencia) # longitud de la secuencia## [1] 12\nsecuencia <- seq(-1, 32, l = 12)\nsecuencia##  [1] -1  2  5  8 11 14 17 20 23 26 29 32\nlength(secuencia) # longitud de la secuencia## [1] 12\n1:10##  [1]  1  2  3  4  5  6  7  8  9 10\nrep(3, 7) # secuencia repetida## [1] 3 3 3 3 3 3 3\nrep(c(1, 2, 3), 5) # repetimos patrón (1, 2, 3) 5 veces##  [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3\nrep(c(1, 2, 3), each = 5) # repetimos patrón alternado##  [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3\nedades <- c(27, 32, 60, 61) # en mi caso, por ejemplo\nedades < 20 # menos de 20 años## [1] FALSE FALSE FALSE FALSE\nedades >= 30 # 30 años o más## [1] FALSE  TRUE  TRUE  TRUE\nedades < 40 # menos de 40 años## [1]  TRUE  TRUE FALSE FALSE\nedades > 65 # más de 65 años## [1] FALSE FALSE FALSE FALSE"},{"path":"operacionesvectores.html","id":"operacionesvectores","chapter":"Capítulo 7 Operaciones con vectores","heading":"Capítulo 7 Operaciones con vectores","text":"","code":""},{"path":"operacionesvectores.html","id":"operaciones-aritméticas-con-vectores-numéricos","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.1 Operaciones aritméticas con vectores numéricos","text":"Hemos dicho que un número es un vector de longitud 1, así que toda operación aritmética que podamos hacer con un número la vamos poder hacer con un vector de números, de forma que si hacemos por ejemplo la operación 2 * z, lo que sucederá es que CADA ELEMENTO del vector será multiplicado por 2.De la misma manera se pueden definir sumas z + x, raíces cuadradas sqrt(z) o elevar cada elemento al cuadrado z^2. Esto último es bastante importante que se te olvide ya que en otros lenguajes siempre es así. En R, salvo que especifiquemos lo contrario, toda operación ARITMÉTICA que hagas un vector será elemento elemento: si multiplicas dos matrices, la operación la realizará elemento elemento, como una multiplicación matricial. Dado que la operación (por ejemplo, una suma) se realiza elemento elemento, ¿qué sucederá si sumamos dos vectores de distinta longitud? Prueba definir un vector con los 4 primeros impares, e intentar hacer la suma z + y (un vector de longitud 3 más un vector de longitud 4).R intenta molestarte lo menos posible, así que lo que hace es reciclar: si tiene un vector de 4 elementos y le intentas sumar uno de 3 elementos, lo que hará será reciclar elementos del vector con menor longitud: hará 1+2, 3+4, 5+6 pero… 7+2 (vuelve al primero). Como hemos comentado anteriormente, los valores lógicosTRUE/FALSE son guardados internamente como 0/1 por lo que podemos usar operaciones aritméticas con ellos. Por ejemplo, si queremos averiguar el número de elementos de un vector que cumplen una condición lógica < 2, los que lo hagan tendrán asignado un 1 y los que un 0, por lo que basta con sumar el vector lógico para obtener el número de elementos bajo dicha condición.","code":"\n# Multiplicamos por 2 a CADA ELEMENTO del vector\nz <- c(2, 4, 6)\n2 * z## [1]  4  8 12\n# Sumamos 3 a CADA ELEMENTO DEL VECTOR\nz + 3## [1] 5 7 9\n# Hacemos la raíz cuadrada de CADA ELEMENTO DEL VECTOR\nsqrt(z)## [1] 1.414214 2.000000 2.449490\n# Elevamos al cuadrado CADA ELEMENTO DEL VECTOR\nz^2## [1]  4 16 36\ny <- c(1, 3, 5, 7)\nz + y## [1]  3  7 11  9\nsum(x < 2) # sumamos el vector de TRUE/FALSE --> número de TRUE## [1] NA"},{"path":"operacionesvectores.html","id":"operaciones-estadísticas-con-vectores-numéricos","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.2 Operaciones estadísticas con vectores numéricos","text":"Al igual que podemos ejecutar operaciones aritméticas, podemos realizar también operaciones estadísticas con los vectores, como calcular su suma (sum()), su media (mean()), su mediana (median()), su suma acumulada (cumsum() cada elemento lo acumula al anterior) o percentiles (quantiles()). WARNING:En R algunas funciones tienen argumentos por defecto, argumentos que necesitan ser asignados un valor priori. En el ejemplo de calcular los percentiles con quantile(), hay un argumento por defecto (con un valor ya asignado sino se especifica lo contrario) que es probs = c(0, 0.25, 0.5, 0.75, 1). Pero dicho argumento por defecto puede ser cambiado, por ejemplo, para sacar los percentiles 15%-30%-70%-90%. CONSEJOComo podido comprobar, este otro tipo de operaciones ESTADÍSTICAS se realizan elemento elemento: la media o la suma las realiza tomando todos los elementos del vector. GLOSARIO:Media: medida de centralización que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. pesar de ser la más conocida, la media es muy poco robusta: dado un conjunto, si se introducen valores atípicos o outliers (valores muy grandes o muy pequeños), la media se perturbar con mucha facilidad. Dado un vector de valores \\(x = (x_1, \\ldots, x_n)\\), se denota como \\(\\overline{x}\\).\\[\\overline{x} = \\frac{\\displaystyle \\sum_{=1}^{n}x_i}{n}\\]Mediana: medida de centralización que consiste en, tras ordenar los datos de menor mayor, quedarnos con el valor que ocupa el medio (deja tantos números por debajo como por encima). Más robusta que la media aunque menos la moda. Dado un vector de valores \\(x = (x_1, \\ldots, x_n)\\), se denota como \\(Me_x\\).\\[Me_x = \\displaystyle \\arg \\min_{x_i} \\left\\lbrace F_i > 0.5 \\right\\rbrace, \\quad F_i = \\frac{\\#\\left\\lbrace x_j \\leq x_i \\right\\rbrace}{n}\\]Moda: medida de centralización que consiste en encontrar el valor más repetido (el valor trending). Es la medida de centralización más robusta. Dado un vector de valores \\(x = (x_1, \\ldots, x_n)\\), se denota como \\(Mo_x\\).\\[Mo_x = \\displaystyle \\arg \\max_{x_i} f_i  , \\quad f_i = \\frac{\\#\\left\\lbrace x_j = x_i \\right\\rbrace}{n}\\] ","code":"\nsum(y) # suma## [1] 16\nmean(y) # media## [1] 4\nmedian(y) # mediana## [1] 4\ncumsum(y) # suma acumulada## [1]  1  4  9 16\ny <- c(1, 2, 5, 5, 8, 9, 10, 10, 10, 11, 13, 15, 20, 23, 24, 29)\nquantile(y) # Percentiles por defecto: cuartiles (0%-25%-50%-75%-100%)##    0%   25%   50%   75%  100% \n##  1.00  7.25 10.00 16.25 29.00\ny <- c(1, 2, 5, 5, 8, 9, 10, 10, 10, 11, 13, 15, 20, 23, 24, 29)\nquantile(y, probs = c(0.15, 0.3, 0.7, 0.9)) # Percentiles p15, p30, p70 y p90##  15%  30%  70%  90% \n##  5.0  8.5 14.0 23.5"},{"path":"operacionesvectores.html","id":"ausentes","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.3 Datos ausentes: NA y NaN","text":"Como comentamos en la lección anterior, es muy importante que entendamos que un dato ausente computa en una operación aritmética. Si hacemos la suma del vector, estamos sumando números más datos ausentes, por lo que el resultado final será también un dato ausente. Para evitar que un dato ausente en nuestros datos nos impida hacer ciertas operaciones, en muchas funciones de R podemos añadir el argumento na.rm = TRUE: primero elimina los datos ausentes, y luego ejecuta la función.","code":"\nsum(x) # suma de un vector que contiene NA## [1] NA\nmean(x) # media de un vector que contiene NA## [1] NA\n# eliminando datos ausentes antes de operar\nsum(x, na.rm = TRUE) ## [1] Inf\nmean(x, na.rm = TRUE)## [1] Inf"},{"path":"operacionesvectores.html","id":"seleccionar-elementos","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.4 Seleccionar elementos","text":"Ya sabemos definir variables que sean vectores (recuerda: colección de valores del mismo tipo). ¿Y si del vector original queremos EXTRAER UN SUBCONJUNTO del mismo, por ejemplo, los primeros 10 elementos?R tiene varias formas de hacer esto pero la más sencilla es entendiendo que si yo quiero acceder al elemento -ésimo de un vector, deberé usar el operador de selección []. Veamos un ejemploDado que hemos visto que un número es más que un vector de longitud uno, esta operación también la podemos aplicar usando un vector de índices seleccionar, de forma que le podemos indicar simultaneamente que valores que queremosOtras veces querremos seleccionar un elemento en concreto sino filtrar algunos elementos en concreto y extraerlos, para lo cual deberemos repetir la misma operación pero con el signo - delante: el operador [-] selecciona el elemento -ésimo del vector sino que lo elimina en nuestro filtro. Sin embargo, lo habitual es que dicho filtro lo hagamos en base una condición lógica. Supongamos que x <- c(7, 20, 18, 3, 19, 9, 13, 3, 45) y y <- c(17, 21, 58, 33, 15, 59, 13, 1, 45) son las edades de dos grupos de personas y que queremos quedarnos solo con los mayores edad. ¿Tenemos que andar averiguando en que posición se encuentran para luego seleccionarlos? , vamos seleccionar los elementos que cumplen una condición dada.Lo que hemos hecho ha sido pasarlo como índices un vector lógico TRUE/FALSE, de forma que solo filtrará los que tengan un TRUE asignado, aquellos que cumplen la condición lógica introducida. Esto también nos puede servir para limpiar de datos ausentes, combinando la función .na(), que nos localiza el lugar que ocupan los ausentes, con el operador !, que lo que hace es negar lo que venga detrás. También podemos probar combinar condiciones lógicas para nuestra selección.Como ves si un valor es NA, la evaluación de una condición lógica sobre él (mayor o menor de 18 años) nos seguirá devolviendo NA. Por último, R nos permite dar significado léxico nuestros valores (significan algo, solo números), pudiendo poner nombres los elementos de un vector, permitiendo su selección por dichos nombres.Con la función names() además podemos, solo consultar los nombres de una variable, sino cambiarlos nuestro gusto. CONSEJO: , anyExisten dos funciones muy útiles en R para saber si TODOS o ALGUNO de los elementos de un vector cumple una condición. Las funciones () y () nos devolverá un único valor lógico. Estas funciones son muy útiles al final de los códigos para comprobar que las condiciones que tienen que verificar los datos se cumplen, y asegurarnos que el proceso se ha ejecutado correctamente (por ejemplo, que todos los datos sean positivos o haya datos ausentes). ","code":"\nx <- 1:100 # Vector de longitud 100 (del 1 al 100)\ny <- x[37] # Solo me interesa el elemento que ocupa el lugar 37\ny## [1] 37\nx[c(1, 4, 51, 77)] # Solo queremos acceder a los elementos en la posición 1, 4, 51, y 77## [1]  1  4 51 77\ny <- c(\"hola\", \"qué\", \"tal\", \"todo\", \"ok\", \"?\")\ny[1:2] # Solo queremos acceder a los elementos en la posición 1 y 2## [1] \"hola\" \"qué\"\nc(1:2, length(y))## [1] 1 2 6\ny[c(1:2, length(y))] # Solo accedemos a los elementos en la posición 1, 2 y además el que ocupa la última posición (recuerda: length(y) nos da la longitud total del vector)## [1] \"hola\" \"qué\"  \"?\"\ny## [1] \"hola\" \"qué\"  \"tal\"  \"todo\" \"ok\"   \"?\"\nz <- y[-2] # Nos muestra todo y salvo el elemento que ocupa la segunda posición\nz## [1] \"hola\" \"tal\"  \"todo\" \"ok\"   \"?\"\nx <- c(7, 20, 18, 3, 19, 9, 13, 3, 45)\ny <- c(17, 21, 58, 33, 15, 59, 13, 1, 45)\nx[x >= 18] # mayores de 18 años del conjunto x## [1] 20 18 19 45\ny[x >= 18] # mayores de 18 años del conjunto y## [1] 21 58 15 45\nx <- c(7, NA, 20, 3, 19, 21, 25, 80, NA)\nx[x >= 18] # mayores de 18 años del conjunto x## [1] NA 20 19 21 25 80 NA\nx[is.na(x)] # solo valores ausentes## [1] NA NA\nx[!is.na(x)] # sin valores ausentes: ! es el símbolo de la negación## [1]  7 20  3 19 21 25 80\n!(x >= 18) # niega los mayores de 18 años, todo lo que no cumpla esa condición## [1]  TRUE    NA FALSE  TRUE FALSE FALSE FALSE FALSE    NA\nx[x >= 18 & x <= 25] # los valores que cumplen ambas (&): entre 18 y 25 años## [1] NA 20 19 21 25 NA\nx <- c(\"edad\" = 31, \"tlf\" = 613910687, \"cp\" = 33007) # cada número tiene un significado distinto\nx##      edad       tlf        cp \n##        31 613910687     33007\nx[c(\"edad\", \"cp\")] # seleccionamos los elementos que tienen ese nombre asignado##  edad    cp \n##    31 33007\nnames(x) # Consultamos nombres## [1] \"edad\" \"tlf\"  \"cp\"\nnames(x) <- c(\"años\", \"móvil\", \"dirección\") # Cambiamos nombres\nnames(x) # Consultamos nuevos nombres## [1] \"años\"      \"móvil\"     \"dirección\"\nx##      años     móvil dirección \n##        31 613910687     33007\nx <- c(1, 2, 3, 4, 5, NA, 7)\nall(x < 3)## [1] FALSE\nany(x < 3)## [1] TRUE\nall(x > 0)## [1] NA\nall(na.omit(x) > 0)## [1] TRUE\nall(is.na(x))## [1] FALSE\nany(is.na(x))## [1] TRUE"},{"path":"operacionesvectores.html","id":"which","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.4.1 which","text":"Hemos visto como seleccionar elementos de un vector que cumplen una condición, para veces queremos el elemento en sí, sino el lugar que ocupa: ¿qué valores de un vector cumplen una condición lógica, qué lugar ocupan? Para obtener dicho índice tenemos nuestro disposición la función (), que nos devuelve el elemento en sí sino su lugar.Esta función es muy útil especialmente cuando queremos averiguar el valor que ocupa el máximo/mínimo de una colección de valores, con las funciones .max() y .min().","code":"\nx <- c(7, NA, 20, 3, 19, 21, 25, 80, NA)\nx[x >= 18] # Accedemos a los elementos que cumplen la condición## [1] NA 20 19 21 25 80 NA\nwhich(x >= 18) # Obtenemos los lugares que ocupan los elementos que cumplen la condición## [1] 3 5 6 7 8\nmax(x, na.rm = TRUE) # máximo de x (si no eliminamos NA, nos devolverá NA)## [1] 80\nmin(x, na.rm = TRUE) # mínimo de x (si no eliminamos NA, nos devolverá NA)## [1] 3\nwhich.max(x) # Lugar que ocupa el máximo## [1] 8\nx[which.max(x)]## [1] 80\nwhich.min(x) # Lugar que ocupa el mínimo## [1] 4\nx[which.min(x)]## [1] 3"},{"path":"operacionesvectores.html","id":"null","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.4.2 NULL","text":"veces veremos que además de NA y NaN, R nos muestra un dato llamado NULL. Cuando tenemos NA en alguna variable, el registro existe, pero está relleno. Sin embargo, cuando tenemos un NULL significa que ese registro ni siquiera existe: es un dato guardado pero cuyo valor desconocemos, es un dato que ni siquiera existe (por ejemplo, si guardamos datos de 7 personas, el dato de la octava persona es NA, es que hay octava persona directamente).","code":"\nx <- c(1, NA, 3, NA, NA, 5, 6)\nx[2] # NA: el registro existe pero sin dato## [1] NA\nnames(x) # No hemos definido el nombre de las variables, así que devuelve NULL## NULL"},{"path":"operacionesvectores.html","id":"ordenar","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.5 Ordenar","text":"Una acción habitual al trabajar con datos es saber ordenarlos: de menor mayor edad, datos más recientes vs antiguos, etc. Para ello tenemos la función sort(), que podemos usar directamente para ordenar de menor mayor, o con el argumento decreasing = TRUE, para ordenar de mayor menor.Otra forma de ordenar un vector es que R nos devuelva los índices de los elementos ordenados, y luego usar dichos índices para reorganizar los elementos, con la función order(). CONSEJO: argumentos por defectoLa función sort() es un buen ejemplo de que las funciones traen definidos argumentos por defecto (aunque los veamos priori). La orden sort(x) en realidad está ejecutando sort(x, decreasing = TRUE), pero como es su valor por defecto, nos podemos ahorrar incluirlo. Escribe ? help sort() en la consola y verás como en la cabecera de la función ya hay preasignado un decreasing = TRUE.","code":"\nx <- c(1, -3, 0, 10, 5, 2, 7, -13)\nsort(x) # orden de menor a mayor## [1] -13  -3   0   1   2   5   7  10\nsort(x, decreasing = FALSE) # orden de mayor a menor## [1] -13  -3   0   1   2   5   7  10\norder(x) # el elemento más pequeño es el octavo, luego el segundo, luego el tercero, luego el primero, luego el sexto, etc.## [1] 8 2 3 1 6 5 7 4\nx[order(x)] # accedemos a los índices ordenados, equivalente al sort(x)## [1] -13  -3   0   1   2   5   7  10"},{"path":"operacionesvectores.html","id":"consejos-4","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.6 Consejos","text":"CONSEJOS Diferencia de conjuntosUna función muy útil para ver las diferencias entre dos conjuntos es setdiff(), una función que nos devuelve los elementos distintos entre dos conjuntos. Optimiza tu códigoAunque parezca un tema menor, si tu código tarda 1 milisegundo más de lo que podría tardar de otra forma, si esa orden se repite muchas veces, ese milisegundo extra puede ser 5, 10 o 20 minutos más que tu código tardará en ejecutarse. Hay un paquete muy útil en R para medir tiempos de distintas órdenes que hacen lo mismo (el paquete microbenchmark), vamos instalarlo.Este paquete contiene una orden para comparar el tiempo de dos órdenes: necesita como primeros argumentos las dos órdenes cuyos tiempos vamos comparar, y un argumento times en el que le indicamos el número de veces que ejecutará cada orden para realizar los tiempos medios. Vamos comparar los comandos de ordenación order() y sort().Sí, estás viendo bien: aunque priori parezca contraintuitivo, es más corto obtener los índices ordenados de un vector, y luego reordenarlo en base esos índices, que la ordenación directa través del comando sort() (ya que usan algoritmos de ordenación distintos).","code":"\ny <- 1:10\nz <- c(1, 3, 7, 10)\nsetdiff(y, z) # Elementos en y que no están en z ## [1] 2 4 5 6 8 9\ninstall.packages(\"microbenchmark\")\nlibrary(microbenchmark)\nx <- rnorm(1e3) # 1000 elementos aleatorias de una normal N(0, 1)\nmicrobenchmark(sort(x), # primera forma\n               x[order(x)], # segunda forma\n               times = 1e3) # se repetirá 1000 veces## Unit: microseconds\n##         expr    min     lq     mean  median     uq     max neval cld\n##      sort(x) 52.543 60.589 70.22854 65.2670 72.357 226.694  1000   b\n##  x[order(x)] 36.684 43.158 49.35939 46.2165 51.053 160.482  1000  a"},{"path":"operacionesvectores.html","id":"ejercicios-3","chapter":"Capítulo 7 Operaciones con vectores","heading":"7.7 📝 Ejercicios","text":"(haz click en las flechas para ver soluciones)📝Ejercicio 1: calcula la suma del vector vector_num mencionado anteriormente (definido como un vector que contenga los números 1, 10, -1 y 2). Solución: 📝Ejercicio 2: define otro vector vector_num2 que contenga los números 5, -7, 8, -3, y haz la suma de vector_num y vector_num2. Solución: 📝Ejercicio 3: calcula el número de elementos mayores que 0 del resultado de la suma de vector_num y vector_num2. Solución: 📝Ejercicio 4: calcula la versión ordenada del vector anterior vector_num. Solución: 📝Ejercicio 5: encuentra del vector vector_num original el lugar (el índice) que ocupa su mínimo y su máximo. Solución: 📝Ejercicio 6: encuentra del vector vector_num los elementos mayores que 1 y menores que 7. Encuentra una forma de averiguar si todos los elementos son o positivos. Solución: 📝Ejercicio 7: define el vector c(-1, 0, 4, 5, -2), calcula la raíz cuadrada del vector y determina que lugares son ausente de tipo NaN. Solución: 📝Ejercicio 8: define el vector de los primeros números impares (hasta el 21) y extrae los elementos que ocupan los lugares 1, 4, 5, 8. Elimina del vector el segundo elementoSolución:","code":"\n# Vector de números\nvector_num <- c(1, 10, -1, 2)\n\n# Suma\nsum(vector_num)## [1] 12\n# Vector de números\nvector_num2 <- c(5, -7, 8, -3)\n\n# Suma\nvector_num + vector_num2## [1]  6  3  7 -1\n# Vector de números\nvector_suma <- vector_num + vector_num2\n\n# Suma\nsum(vector_suma > 0)## [1] 3\n# Ordenamos el vector (con sort)\nsort(vector_num)## [1] -1  1  2 10\n# Ordenamos el vector  (con order)\nvector_num[order(vector_num)]## [1] -1  1  2 10\nvector_num <- c(1, 10, -1, 2)\n\n# Encontrando el lugar que ocupa el máximo y mínimo\nwhich.max(vector_num)## [1] 2\nwhich.min(vector_num)## [1] 3\n# Vector lógico: mayores que 1 y menores que 7\nvector_num > 1 & vector_num < 7## [1] FALSE FALSE FALSE  TRUE\n# ¿Son todos positivos?\nall(vector_num > 0)## [1] FALSE\n# Vector\nx <- c(-1, 0, 4, 5, -2)\n\n# ¿Cuáles son ausentes tras aplicar la raíz cuadrada?\nis.nan(sqrt(x))## [1]  TRUE FALSE FALSE FALSE  TRUE\n# Vector de impares (de 1 a 21 saltando de dos en dos)\nx <- seq(1, 21, by = 2)\n\n# Seleccionamos elementos\nx[c(1, 4, 5, 8)]## [1]  1  7  9 15\n# Eliminamos elementos\ny <- x[-2]\ny##  [1]  1  5  7  9 11 13 15 17 19 21"},{"path":"bibliografía.html","id":"bibliografía","chapter":"Bibliografía","heading":"Bibliografía","text":"Ziemann, M., Y. Eren, . El-Osta. 2016. “Gene Name Errors Widespread Scientific Literature.” Genome Biology 17 (177).","code":""}]
