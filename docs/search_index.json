[["index.html", "Analizando datos, visualizando información, contando historias Prefacio", " Analizando datos, visualizando información, contando historias Javier Álvarez Liébana, Gabriel Valverde Castilla, Borja Andrino, Victòria Oliveres, Dominic Royé Última actualización: 27-12-2021 Prefacio Este material ha sido diseñado como complemento y recursos de apoyo al curso de la Escuela de Invierno de la UCM titulado «Analizando datos, visualizando información, contando historias», celebrado presencialmente del 31 de enero al 4 de febrero de 2022 (16:00 a 21:00 horas, de lunes a viernes). El presente material introductorio ha sido elaborado por Javier Álvarez Liébana y Gabriel Valverde Castilla, y tiene como objetivo introducir en el lenguaje R a todas aquellas personas que quieran aprender R desde cero. Dicho manual ha sido elaborado a su vez en R con {bookdown}. Puedes ver un resumen de las funcionalidades de algunos paquetes documentados por el equipo de R Studio en sus esquemas resumen. El código de dicho manual se encuentra en GitHub. Para elaborar informes o libros con una estructura similar (de forma nativa en R) el paquete {bookdown} puede ser instalado desde la plataforma CRAN o desde su versión en desarrollo actualizada en Github: install.packages(&quot;bookdown&quot;) # o desde su versión en desarrollo actualizada # devtools::install_github(&quot;rstudio/bookdown&quot;) "],["propósito.html", "Propósito", " Propósito El objetivo de este curso es introducir a la programación y análisis estadístico en R a toda aquella persona que nunca se haya iniciado en él, sin necesitar conocimientos previos de programación (aunque siempre ayuda, obviamente). No se pretende que adquieras un vasto y experto conocimiento de R, pero si lo suficiente como para lograr 5 objetivos: No tener miedo a programar Entender los conceptos básicos de R. Dotarte de autonomía para poder trabajar con datos. Introducirte en el análisis estadístico. Adquirir las competencias necesarias para la visualización de datos en R. "],["contenidos.html", "Contenidos", " Contenidos 1 Requisitos 2 Instalación de R y Rstudio 3 ¿Qué es R? 4 Primeros pasos 5 Tipos de datos ?? Vectores "],["código-de-colores.html", "Código de colores", " Código de colores Puedes buscar los siguientes términos en el buscador del documento ERROR: En color rojo encontrarás errores comunes o prácticas a evitar. WARNING: En color naranja/amarillo encontrarás warnings o advertencias sobre cosas a tener en cuenta para evitar problemas. Algunas funciones pueden arrojar ciertas advertencias que nunca está de más leer. Pero si dichos mensajes de alerta los tenemos controlados, y no queremos que nos ensucie la ejecución en la consola, podemos poner al inicio del código assign(&quot;last.warning&quot;, NULL, envir = baseenv()) para limpiar los warnings antiguos y options(warn = -1) para desactivarlos. CONSEJO: En color verde encontrarás consejos o tips para ampliar y facilitar tu programación. Además en cada cajita de código, si pasas el ratón, encontrarás un botón 📄📄 en la esquina superior derecha de la caja para copiar el código directamente a tu consola. Puedes encontrarlos todos escribiendo «consejo» en el buscador. GLOSARIO: En color azul encontrarás un 📚 glosario con algunos términos estadísticos y conceptos básicos. "],["licencia.html", "Licencia", " Licencia Este documento es publicado bajo licencia pública general GNU, una licencia libre de copyleft que garantiza a los usuarios finales (personas, organizaciones, compañías) la libertad de usar, estudiar, compartir (copiar) y modificar el software, citando adecuadamente al autor del mismo. "],["requisitos.html", "Capítulo 1 Requisitos", " Capítulo 1 Requisitos Conexión a internet (para la descarga de algunos datos y paquetes). Instalar R (ver 2.1). R será nuestro lenguaje, nuestro diccionario, nuestro castellano, nuestra ortografía para poder «comunicarnos» con el ordenador. https://cran.r-project.org/ Instalar R Studio (ver 2.2). De la misma manera que podemos escribir el mismo texto en castellano en una tablet, en un ordenador, en un Word, en un papel o en un tuit, en programación podemos usar distintos IDE (entornos de desarrollo integrados, nuestro Office), para que el trabajo sea más cómodo. Nosotros trabajaremos con RStudio. Todo lo necesario para seguir este curso es de descarga gratuita: viva el software libre. "],["instalacion.html", "Capítulo 2 Instalación", " Capítulo 2 Instalación En breve daremos nuestros primeros pasos en R pero antes necesitamos instalar algunas cosas. No vamos a necesitar tantas, y para entender lo que instalamos pensaremos que vamos a escribir un libro. ¿Qué necesitamos? Gramática/ortografía: en nuestro caso será R, el lenguaje de programación que usaremos. Word: al igual que podemos escribir en castellano de distintas maneras (en un Word, un post-it, un cuaderno, etc), cuando programamos podemos trabajar en distintos entornos de desarrollo (IDE). En nuestro caso escribiremos y programaremos en RStudio, el programa que será nuestro Word para escribir en lenguaje R. "],["instalacionR.html", "2.1 Instalación de R", " 2.1 Instalación de R Vamos a necesitar solo 3 pasos (y conexión a internet). Paso 1: entra en la web oficial de R https://cran.r-project.org/. En la pantalla de inicio selecciona la instalación acorde a tu sistema operativo (ver imagen 2.1) Imagen/gráfica 2.1: Pantalla inicial de la plataforma CRAN de R. Paso 2: para sistemas operativos Mac basta con que hacer click en el archivo .pkg, y abrirlo una vez descargado (ver imagen 2.2) Imagen/gráfica 2.2: Pantalla de instalación de R en Mac OS. Para sistemas operativos Windows, debemos clickar en install R for the first time (ver imagen 2.3) y en la siguiente pantalla hacer click en Download R for Windows (ver imagen 2.4). Una vez descargado, abrirlo como cualquier archivo de instalación. Imagen/gráfica 2.3: Pantalla previa de instalación de R en Windows. Imagen/gráfica 2.4: Pantalla final de instalación de R en Windows. Paso 3: tras su instalación tendrás en tu escritorio (Windows) o en tu Launchpad (Mac Os) un ejecutable de R para abrir. En Windows puede que tengas dos ejecutables i386 y x64 (como todo programa en Windows, está la versión de 32 y de 64 bits, haz click preferiblemente - si lo tienes - en el de x64). Te saldrá algo parecido a lo que observas en la imagen 2.5. Imagen/gráfica 2.5: Primera pantalla al abrir el ejecutable de R. 2.1.1 Primera operación: sumar dos números Para comprobar que está correctamente instalado, abre R y prueba a escribir en la pantalla blanca inferior el siguiente código (recuerda: los códigos de este manual puedes copiarlos directamente de la cajita haciendo click en el botón de la esquina superior derecha) a &lt;- 1 b &lt;- 2 a + b ## [1] 3 Imagen/gráfica 2.6: Primera suma en la consola de R. ¡Enhorabuena! ¿Dónde hemos escrito ese código? Esa pantalla blanca donde hemos escrito el código se llama CONSOLA, y será donde ejecutaremos las órdenes. ¿Qué hemos hecho? Hemos hecho más de lo que parece. Primero, hemos definido dos variables a y b asignándole un valor numérico a cada una de ellas. Imagina que el símbolo &lt;- es visto en nuestra cabeza como una flecha: a una variable que llamamos a le asignamos el valor 1, a una variable que llamamos b le asignamos el valor 2. Podemos verlo como \\(a = 1,~b = 2\\). Y tras definir dichas variables, las hemos usado en una operación aritmética a + b. Ya sabemos usar R como calculadora. ¿Cómo nos devuelve R el resultado de la operación? Si te ha devuelto el resultado correcta, en la consola debe aparecer [1] 3. El valor [1] aparecerá siempre ya que simplemente nos numera las líneas de la consola usadas; lo que viene detrás es realmente el resultado, es decir, \\(a + b = 3\\). ¿Por qué hemos escrito a + b al final? Un mantra de R, que veremos a lo largo de todo el curso, es que R intenta molestarte lo menos posible (eso es bueno cuando ya sabes usarlo, no tan bueno cuando empezamos a aprenderlo). Cuando asignamos los valores a &lt;- 1 y b &lt;- 2, R no nos muestra nada: si guardamos un resultado en una variable, no nos muestra nada por consola. Para obtener el resultado en la consola necesitamos escribir el nombre de las variables (u operaciones entre ellas, como a + b). WARNING: Como habrás advertido, en R usaremos &lt;- para asignar valores en lugar de =, como una flecha. Usaremos = para indicarle el valor a los argumentos que usemos en funciones y == como operador de comparación: si escribimos 2 == 3, le estamos preguntando si 2 es igual a 3. 2 == 3 ## [1] FALSE Bonita esta interfaz no es, así que la cerraremos y no la abriremos más. Tenemos nuestro lenguaje instalado, vamos a instalar nuestro Word para poder programar de forma cómoda. "],["instalacionRStudio.html", "2.2 Instalación de R Studio", " 2.2 Instalación de R Studio Para instalar RStudio deberemos ir a la web https://www.rstudio.com/products/rstudio/download/#download (el gratuito) y seleccionar el ejecutable que te aparezca acorde a tu sistema operativo (ver imagen 2.7). Tras descargar el ejecutable, hay que abrirlo como otro cualquier otro ejecutable y dejar que termine la instalación. Imagen/gráfica 2.7: Descargar el ejecutable de RStudio para su posterior instalación. Tras instalar tendremos en el escritorio o Launchpad un ejecutable de RStudio que abriremos. Se nos aparecerá una pantalla similar a esta: Imagen/gráfica 2.8: Primer recibimiento de nuestro mejor amigo RStudio. Listo, tienes instalado (casi) todo correctamente. "],["glosario.html", "2.3 Glosario", " 2.3 Glosario GLOSARIO Consola: es el nombre para llamar a esa ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo código que antes en ella (es el equivalente a la consola de R que hemos abierto al principio). a &lt;- 1 b &lt;- 2 a + b Imagen/gráfica 2.9: Lanzando a consola nuestras primeras órdenes en RStudio. La consola será donde ejecutaremos órdenes y mostraremos resultados Environment (entorno): la pantalla pequeña (puedes ajustar los márgenes con el ratón a tu gusto) que tenemos en la parte superior derecha se denomina environment o entorno de variables, donde como puedes ver, tras ejecutar el pequeño código en la consola, nos informa de que tenemos dos variables numéricas y su valor asignado. Nos mostrará las variables que tenemos definidas, el tipo y su valor. Imagen/gráfica 2.10: Environment de variables. Panel multiusos: la ventana que tenemos en la parte inferior derecha no servirá para buscar ayuda de comandos y órdenes, además de para visualizar gráficos. Lo veremos cuando sea necesario. Imagen/gráfica 2.11: Panel multiusos. "],["consejos.html", "2.4 Consejos", " 2.4 Consejos CONSEJOS ¿Cómo saber cuando la orden lanzada en consola ha terminado? A veces R y RStudio son tan silenciosos que no sabemos si ha acabado la orden que acabamos de lanzar en la consola o no. Siempre que veas el símbolo &gt; como última línea en la consola significa que está listo para que le escribamos otra orden (es la forma cariñosa de decirte que ya ha acabado, ver imagen 2.12) Imagen/gráfica 2.12: Ejemplo de que la orden lanzada ha acabado. ¿Cómo prevenir la fatiga programando? Estando delante de una pantalla de ordenador, con la vista muy fija mientras se programa, puede que acabes teniendo cierta fatiga visual en el trabajo. Te aconsejo que cambies en tu RStudio la tonalidad del fondo de tu programa, en tonos oscuros y no blancos (¿te has fijado que mis capturas tienen un azul cobalto oscuro de fondo mientras el tuyo es un blanco nuclear? Echa un vistazo a las imágenes 2.13 y 2.14) Imagen/gráfica 2.13: Menú de opciones de nuestro editor Imagen/gráfica 2.14: Personalizar el color de fondo de nuestro editor, la letra y el tamaño de fuente "],["que-es-R.html", "Capítulo 3 ¿Qué es R?", " Capítulo 3 ¿Qué es R? Una vez que tenemos todo instalado vamos a dar nuestros primeros pasos en R, pero antes veamos un poco de su historia y de una particularidad: R es un lenguaje modular (¿modu…qué?) "],["historia-de-r.html", "3.1 Historia de R", " 3.1 Historia de R Veamos antes un poco de la historia de nuestra deidad. Allá por 1975, los laboratorios Bell (los que inventaron la radio moderna tal y como la conocemos), necesitaban una alternativa a los lenguajes más «rudos» y antiguos como C++ o Fortran, lenguajes rápidos en la ejecución pero complejos en su uso, con una gran curva de aprendizaje y con muy poca capacidad en la visualización de datos que se empezaba a necesitar. Así que en 1976 sacaron la primera versión del lenguaje conocido S (hasta entonces estaba de moda lo de llamar a los lenguajes con una sola inicial). En 1980 se empezó a distribuir la primera versión pública de S, más allá de los laboratorios Bell, y en 1988 se añadieron bastantes funcionalidades nuevas como poder aplicar funciones a otras funciones (los famosos apply() que ya veremos). Años más tarde, en 1991, dicho lenguaje se simplificó, reescribiendo muchas subrutinas de otros lenguajes más primitivos, para tener una versión muy parecida al actual R, permitiendo el usod de operadores, data.frames (que veremos) y otro tipo de objetos, sencillos en la programación pero muy versatiles. Sin embargo, salvo uso docente, S tenía licencia así que en 1992 Ross Ihaka y Robert Gentleman se lanzaron a crear una versión de S libre y gratuita, un trabajo de casi 8 años hasta que en el año 2000, ambos investigadores de la Universidad de Auckland en Nueva Zelanda lanzaron la primera versión estable del lenguaje. Tras dicho lanzamiento, se creó un equipo de expertos en estadística computacional (el conocido como R Development Core Team) que es el que se encarga de mantener toda la aerquitectura de R y los que se encargar de actualizar y mejorar el paquete {base}, una librería motor sobre la que se construye el resto de funciones. Y es precisamente ese hecho una de las principales diferencias entre Python y R: R fue creado por y para estadísticos. Te dejo esta entrada en el blog por si quieres curiosear las diferencias (aunque ambos pueden ser útiles para trabajos estadísticos muy generales). "],["instalacionpaquetes.html", "3.2 Comunidad de usuarios: paquetes", " 3.2 Comunidad de usuarios: paquetes La pregunta del millón suele ser siempre la misma: ¿qué lenguaje elegir? Podríamos hacer una comparativa técnico de distintos lenguajes pero vamos a quedarnos con dos consejos fundamentales: prioriza el software libre y aquellos lenguajes que tienen una comunidad muy grande de usuarios trabajando en los problemas o campo para el que vas a usar dicho lenguaje. El lenguaje R (también Python) tiene 3 ventajas principales: Es un lenguaje creado por y para estadísticos/as. Es software libre (como C++, Python, Fortran, y otros tantos lenguajes). El software libre no solo tiene una ventaja evidente (es gratis, ok) sino que permite acceder libremente a código ajeno. Es un lenguaje modular: en la instalación que hemos realizado no se han instalado todas las funcionalidades, solo el mínimo para poder funcionar, de forma que se ahorra espacio en disco y en memoria. Al ser software libre, existen trozos de código hechos por otras personas llamados paquetes, que podemos ir instalando a nuestro gusto según los vayamos necesitando. Esto es una ventaja enorme ya que R tiene una comunidad de usuarios gigante para hacer estadística (Python tiene una enorme comunidad pero más enfocada al Machine Learning), con más de 17 000 paquetes: ¡hay más de 17 000 trozos de código, muchos de ellos programados por expertos/as en R, validados por la comunidad y la plataforma, y de forma gratuita! Imagen/gráfica 3.1: Paquetes disponibles en R. Esto nos ahorra muchísimo tiempo en nuestro día a día ya que casi todo lo que querramos hacer ya lo habrá querido hacer otra persona (y seguramente mejor que nosotros/as). Vamos a instalar, por ejemplo, un paquete gráfico ({ggplot2}) que necesitaremos en el futuro. Para ello, escribe en tu consola el siguiente código y pulsa enter. install.packages(&quot;ggplot2&quot;) Dicha orden (puede tardar un poco la primera vez, depende de tu conexión a internet) lo que hará será acceder a la web de R, bajarse a tu ordenador los trozos de código incluidos en el paquete llamado {ggplot2}, y dejarlos para siempre en él. WARNING: La instalación de paquetes SOLO ES NECESARIA la primera vez que se usa dicho paquete en la vida del ordenador, no hace falta hacerlo cada vez que lo usas. Una vez que tenemos los trozos de código (el paquete) en nuestro ordenador, en cada sesión de R que abramos (cada vez que cierres y abras RStudio) deberemos (si queremos) llamar a ese paquete que tenemos instalado, escribiendo el siguiente comando en consola library(ggplot2) Welcome to software libre "],["por-qué-excel-no-es-tu-amigo.html", "3.3 ¿Por qué Excel no es tu amigo?", " 3.3 ¿Por qué Excel no es tu amigo? R es un lenguaje de programación, de alto nivel para el usuario y modular. Los lenguajes de alto nivel como R, Python (curso interactivo de Python en https://checkio.org/) o Matlab, facilitan la programación al usuario, teniendo que preocuparte solo de la tarea de programar. Son lenguajes con una menor curva de aprendizaje aunque suelen ser más lentos en su ejecución en comparación con lenguajes de bajo nivel (C, C++ o Fortran), lenguajes muy rápidos en su ejecución pero cuya programación requiere un mayor tiempo y formación, teniendo que además estar pendiente del tipo de variables, espacio en memoria, etc. Por su arquitectura, R es un lenguaje que puede ser usado para un propósito general pero que está especialmente diseñado para el análisis estadístico de datos. Su modularidad nos da la ventaja de que podemos instalar las funcionalidades que vayamos necesitando de forma progresiva. ¿Por qué no es recomendable usar Excel como base de datos ni para realizar análisis estadísticos complejos? Software de pago: Excel, al igual que el resto de programas de Microsoft o SPSS (por desgracia programa estrella de nuestro sistema sanitario), es un programa de pago. A nivel individual, todos hemos tenido una versión que no hemos pagado, pero dicha evasión no se la puede permitir una empresa o administración, que debe de pagar altas cantidades de dinero anuales por las licencias, dinero que no sería necesario si los investigadores y trabajadores tuvieran formación (remunerada) en otras herramientas de software libre. Software cerrado: no solo es de pago sino que es cerrado, así que solo podemos hacer lo que Excel ha creído que interesante que podamos hacer. Incluso con la programación de MACROS, las funcionalidades de Excel siguen siendo mucho más limitadas ya que viene «programadas» de antemano Alto consumo de memoria: dicha programación predeterminada hace que Excel ocupe muchísimo espacio en el disco duro y tenga un alto consumo de memoria (la memoria es lo que te permite hacer varias tareas a la vez en tu ordenador). No es universal: no solo es de pago sino que además, dependiendo de la versión que tengas de Excel, tendrá un formato distinto para datos como fechas, teniendo incluso extensiones distintas, de forma que un archivo .xls abierto por un Excel moderno puede provocar errores en la carga. ¡ES SOLO UNA HOJA DE CÁLCULO!: el propio Microsoft desaconseja el uso de Excel para el análisis de grandes volúmenes de datos. El Excel es una herramienta maravillosa para ser usada como una sencilla hoja de cálculo: llevar las cuentas de tu familia, de tu pequeño negocio, una declaración de la Renta sencilla, planificar viajes, etc. Pero el programa NO ESTÁ DISEÑADO para ser una base de datos ni para análisis detallado, y muchos menos pensado para generar un entorno flexible para el análisis estadístico y la visualización de datos. ¿Puedes ser el mejor partiendo un filete con una cuchara? Seguramente puedas (en Excel puedes hasta programar con macros), y si siempre lo hiciste así, acabarás normalizándolo, pero seguirás siendo una persona comiendo filete con cuchara. ¿Qué sucede si usamos la herramienta equivocada? Tres ejemplos: Problemas para codificar fechas: en 2016 se publicó una revisión de artículos en genética, descubriendo que 1 de cada 5 artículos contenían errores debido a una mala codificación de las fechas, conviertiendo por ejemplo los genes Septin-2 (conocido como SEPT2) en fechas, y al revés (Ziemann, Eren, and El-Osta 2016). Imagen/gráfica 3.2: Excel en una noche loca. Problemas de memoria: un Excel permite por defecto una cantidad máxima de filas. Aunque dicha cantidad se puede ampliar, sigue siendo finita, por lo que cuando superas el umbral de filas, al añadir filas Excel te borra registros sin avisarte de que lo está haciendo. Esto es lo que sucedió con los registros de casos covid en Reino Unido. Imagen/gráfica 3.3: Cuando Excel dice basta. Problemas para codificar edades: una variable de tipo fecha, aunque nosotros la veamos con letras, en realidad es una variable numérica que representa los días que han pasado desde una fecha origen. En función de las distintas versiones de Excel, dicha fecha origen cambia. Además, si se codifica mal la fecha en formato dd-mm-YY, dicho formato cuando se exporta a otro excel en texto, no permite distinguir a un nacido en 1918 y a un nacido en 2018, así que podemos estar confundiendo personas de 103 años con niños de 3 años (y es lo que sucedió en España, observando unas tasas de mortalidad en niños muy pequeños equivalentes a personas mayores). Imagen/gráfica 3.4: Los centenarios con biberón. Bibliografía "],["glosario-1.html", "3.4 Glosario", " 3.4 Glosario GLOSARIO Paquete: trozos de código realizadas por otros usuarios de la comunidad (y validades por el equipo de CRAN si la descarga es mediante install.packages()) para ser usados. Una vez instalados (descargados) los trozos de código a nuestro ordenador, basta con «acudir» a ellos con library(). Haciendo una metáfora con la colección de libros que tengas en casa: con la instalación hemos comprado el libro y lo tenemos en nuestra estantería (para siempre), con la llamada al paquete, por ejemplo library(ggplot2), lo que hacemos es decidir, de entre todos los libros de la estantería, cuales queremos llevarnos de viaje (en cada maleta que hagamos). Los paquetes usados los verás denotados como {nombre_paquete} a lo largo del manual. "],["primeros-pasos.html", "Capítulo 4 Primeros pasos", " Capítulo 4 Primeros pasos Scripts usados: script01.R: ejercicio 4. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script01.R Vamos a empezar por lo sencillo: ¿cómo usar R como una calculadora? "],["primeros-pasos-en-r-calculadora.html", "4.1 Primeros pasos en R: calculadora", " 4.1 Primeros pasos en R: calculadora ¿Te acuerdas de lo que era la consola? En el caso de RStudio, la consola será esa pequeña pantalla que tenemos en la parte inferior (la pestaña Console). Vamos a trabajar de momento solo en esa ventana inferior. Imagen/gráfica 4.1: Lanzando a consola nuestras primeras órdenes en RStudio. Lo que ya hemos descubierto en los pasos de la instalación (ver imagen 4.1) es que la consola de R tiene una función muy básica y evidente: nos sirve de calculadora. Un ejemplo muy simple: si escribimos 3 en la consola y pulsamos ENTER, la consola nos mostrará el resultado de la suma 1 + 2 ## [1] 3 ¿Cuál es la diferencia entre una calculadora y un lenguaje de programación? Imagina que dicha suma 3 la quisiéramos utilizar para un segundo cálculo: ¿y si en lugar de lanzarlo a la consola sin más lo almacenamos en alguna variable? Como hemos visto en la instalación de RStudio, para asignar variables lo haremos con &lt;-, por ejemplo la orden x &lt;- 1 + 2: una variable de nombre x va a tener asignada lo que valga la suma 1 + 2 x &lt;- 1 + 2 Como puedes comprobar, en tu parte superior derecha (nuestro entorno de variables), podrás ver como una nueva variable x es ahora visualizada, con su valor asignado (no se mostrará en consola salvo que escribas 3 en ella: R asume que no querías visualizarla en consola sino solo guardarla). Imagen/gráfica 4.2: Environment. y &lt;- x - 3 x ## [1] 3 y ## [1] 0 x * y ## [1] 0 Dicha variable x además podemos reciclarla para definir, por ejemplo, una variable y, restándole una constante. De la misma manera que hemos hecho restas, sumas y multiplicaciones, R tiene todas las operaciones clásicas que podrías tener en una calculadora. Prueba a ejecutar en la consola las órdenes x^2, sqrt(x) o abs(y): R calculará las operaciones elevar al cuadrado, raíz cuadrada y valor absoluto (respectivaemnte) de la variable que tengan entre paréntesis x^2 ## [1] 9 sqrt(x) ## [1] 1.732051 y &lt;- x - 5 abs(y) ## [1] 2 "],["y-dónde-programamos.html", "4.2 ¿Y dónde programamos?", " 4.2 ¿Y dónde programamos? ¿Estás emocionado/a? Vamos a abrir nuestro primer script. Un script será el documento en el que programamos, nuestro .doc, pero aquí será un archivo con extensión .R, donde escribiremos las órdenes, que nos evitará estar lanzando todo a consola. ¿Por qué no abusar de la consola? Una máxima para no olvidar: TODO lo que no escribas en un script, cuando cierres RStudio, lo habrás perdido (cómo si en lugar de escribir en un Word y guardarlo, nunca guardases el documento). Para abrir nuestro primero script, haz click en el menú superior en File &lt;&lt; New File &lt;&lt; R Script como se muestra en la imagen 4.3 Imagen/gráfica 4.3: Abriendo nuestro primer script de R. Tras abrirlo tendremos una cuarta ventana: esta será la ventana de nuestros códigos, la ventana más importante ya que es donde escribiremos lo que queremos ejecutar. Escribe el código de la suma de arriba en ese script y guarda el archivo haciendo click en el botón Save current document a &lt;- 1 b &lt;-2 a + b ## [1] 3 Imagen/gráfica 4.4: Escribiendo y guardando nuestro primer script. Ese código no se ejecuta salvo que se lo digamos. Tenemos tres opciones para ejecutar código: Copiar y pegar el trozo de código en la consola (como hemos hecho al principio). Seleccionar líneas de código y clickar en Run (o con su atajo de teclado), lo que hará que se ejecute solo las líneas seleccionadas. Activar el cuadrado Source on save a la derecha del botón de guardar y volvemos a hacer click en el botón de guardar: siempre que esa opción esté activada, al guardar no solo es nos guarda el archivo .R sino que además se ejecuta el código completo que tengas en el script. "],["tipos_errores.html", "4.3 Tipos de errores", " 4.3 Tipos de errores Durante tu aprendizaje en R va a ser muy habitual que las cosas no salgan a la primera, apareciendo en consola mensajes en un color rojo. Un miedo muy habitual cuando se empieza a programar es pensar que si haces algo mal o aparece algún mensaje de error, el ordenador puede explotar en cualquier momento. A programar se aprende programando, así que haz las pruebas que quieras, lo peor que puede pasar es que necesites cerrar sesión en R Studio y abrirlo de nuevo, o en el peor de los casos, desintalarlo y volverlo a iinstalar. Dado que el \\(99.9\\%\\) de las veces tu código tendrá errores que deberás ir solventando, no está de más conocer los tipos de mensajes que R puede sacarte por consola. Los mensajes de ERROR irán precedidos de la frase «Error in…», dándote a veces incluso el tipo de error y la línea de código en la que se ha producido. Veamos un ejemplo intentando sumar un número a una cadena de texto. &quot;a&quot; + 1 ## Error in &quot;a&quot; + 1: argumento no-numérico para operador binario Los errores son aquellos fallos que seguramente impidan la ejecución del código. Un error muy habitual es intentar acceder a alguna función de algún paquete que, o bien no tenemos instalado, o bien no hemos llamado haciendo uso del library(): estás intentando leerte un libro de tu biblioteca pero ni siquiera has ido a la tienda a «comprarlo». Los mensajes de WARNING irán precedidos de la frase «Warning in…», y son los fallos más delicados ya que son posibles errores o incoherencias que R detecta en tu código pero que no van a hacer que tu código deje de ejecutarse, aunque probablemente no lo haga como a ti te gustaría. Un ejemplo es cuando tratamos de hacer la raiz cuadrada de un número negativo. sqrt(-1) ## Warning in sqrt(-1): Se han producido NaNs ## [1] NaN ¿Ha ejecutado la orden? Sí, pero te advierte de que el resultado de la operación es un NaN, un valor que no existe (al menos dentro de los números reales), un Not A Number (ver Sección ??). Los mensajes de CONTROL serán aquellos que aparecerán por consola sin empezar por «Error in…» ni «Warning:…». Dichos mensajes, que puedes incluir tú mismo en tu código con funciones como cat() para monitorizar la ejecución de códigos largos, no son errores ni problemas, son simplemente información que R considera útil aportarte. "],["glosario-2.html", "4.4 Glosario", " 4.4 Glosario GLOSARIO Paquete: trozos de código realizadas por otros usuarios de la comunidad (y validades por el equipo de CRAN si la descarga es mediante install.packages()) para ser usados. Una vez instalados (descargados) los trozos de código a nuestro ordenador, basta con «acudir» a ellos con library(). Haciendo una metáfora con la colección de libros que tengas en casa: con la instalación hemos comprado el libro y lo tenemos en nuestra estantería (para siempre), con la llamada al paquete, por ejemplo library(ggplot2), lo que hacemos es decidir, de entre todos los libros de la estantería, cuales queremos llevarnos de viaje (en cada maleta que hagamos). Los paquetes usados los verás denotados como {nombre_paquete} a lo largo del manual. "],["consejos-1.html", "4.5 Consejos", " 4.5 Consejos CONSEJOS Panel de ayuda Si escribes en la consola ? nombre_funcion (por ejemplo, escribe en la consola ? sqrt), en el panel inferior derecho te aparecerá una documentación de ayuda de la función para saber que argumentos necesita, como puedes usar la función, qué es lo que te devuelve, ejemplos de uso, etc. ? sqrt Imagen/gráfica 4.5: Panel de ayuda. ¿Cómo comentar el código? Probablemente lo más importante al programar es que te acostumbres a comentar lo máximo posible tu código. ¿Qué es un comentario? Es un texto que escribes entre el código precedido de #: todo lo que venga detrás no será interpretado por R como código. Es vital cuando programamos que nos acostumbremos a comentar lo que hacemos, tanto para nosotros como para otras personas que puedan leer nuestro código. Índice en el código Puedes escribir comentarios en el código para que automáticamente se organice tu código en epígrafes, mostrándote un índice en el panel lateral (haz click en el icono de la esquina superior derecha del editor) y permitiendo minimizar partes del código. Para ello puedes comentar por ejemplo con # ----- título -----. Imagen/gráfica 4.6: Comentando el código para generar un índice. "],["ejercicios.html", "4.6 📝 Ejercicios", " 4.6 📝 Ejercicios (haz click en las flechas para ver soluciones) 📝Ejercicio 1: en tu consola (parte inferior de tu pantalla), asigna los valores 2 y 5 a dos variables a y b. Tras asignarles valores, multiplica los números en consola (haz click en la flecha para la solución propuesta). Solución: # Para poner comentarios en el código se usa # # Definición de variables a &lt;- 2 b &lt;- 5 # Multiplicación a * b ## [1] 10 Imagen/gráfica 4.7: Multiplicación de a y b. 📝Ejercicio 2: repite el ejercicio anterior pero ahora guarda el resultado de la multiplicación en una variable c. Para ver el resultado guardado en c escribe dicha variable en consola (haz click en la flecha para la solución propuesta). Solución: # Variables a &lt;- 2 b &lt;- 5 # Resultado c &lt;- a * b # Muestro en consola c ## [1] 10 Imagen/gráfica 4.8: Multiplicación de a y b guardando el resultado. 📝Ejercicio 3: asigna ahora los valores 1, -2, 3 a tres variables a, b y c, y calcula la raíz cuadrada de cada uno. Solución: # Variables a &lt;- 1 b &lt;- -2 c &lt;- 3 # Resultado sqrt(a) ## [1] 1 sqrt(b) ## [1] NaN sqrt(c) ## [1] 1.732051 📝Ejercicio 4: repite el ejercicio 2 pero ahora escribe el código en un script (fichero .R, guardado en script01.R). Recuerda al acabar seleccionar las líneas a ejecutar y clickar Run, o bien guardar el script con Source on save activado (haz click en la flecha para la solución propuesta). Solución: Imagen/gráfica 4.9: Multiplicación de a y b guardando el resultado pero escribiendo en el script. 📝Ejercicio 5: calcula en consola la suma de 3 más 4, y todo ello multiplicado por 10, y asígnalo a una variable x (haz click en la flecha para la solución propuesta). Solución: x &lt;- (3 + 4) * 10 📝Ejercicio 6: asigna un valor positivo a x y calcula su raíz cuadrada; asigna otro negativo y calcula su valor absoluto (haz click en la flecha para la solución propuesta). Solución: # Raíz cuadrada x &lt;- 73 sqrt(x) ## [1] 8.544004 # Valor absoluto y &lt;- -73 abs(y) ## [1] 73 CONSEJO: Las órdenes sqrt(x) y abs(y) se llaman funciones, y la variable que tienen entre paréntesis se llama argumento de la función: una variable que toma de entrada la función y con la que opera internamente. 📝Ejercicio 7: usando la variable x ya definida, calcula x - 5 y guárdalo en una nueva variable z (haz click en la flecha para la solución propuesta). Solución: z &lt;- x - 5 z ## [1] 68 📝Ejercicio 8: usando las variables x y z ya definidas, calcula la raíz cuadrada del máximo entre ambas, y guárdalo en una nueva variable t. Hazlo en un script en lugar de en consola (haz click en la flecha para la solución propuesta). Solución: t &lt;- sqrt(max(x, z)) t ## [1] 8.544004 WARNING: No hace falta gastar una línea por cada orden que quieras ejecutar. Tampoco necesitas guardar cada paso intermedio que realices. Cuidado con la memoria: cada asignación que hagas es una variable guardada que consume recursos en tu ordenador. "],["tipos-datos.html", "Capítulo 5 Tipos de datos", " Capítulo 5 Tipos de datos Scripts usados: script02.R: tipos de datos y funciones usadas con ellos. Ver en https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script02.R Tras las lecciones anteriores, los ejercicios planteados y lo que hayas jugueteado por tu cuenta, deberíamos saber usar ya R como una calculadora. Vamos a ir más allá: ¿existen datos más allá de los números? En este capítulo vamos a empezar a familiarizarnos con los tipos de datos (individuales) que podemos necesitar. Piensa por ejemplo en los datos guardados de una persona: La edad será un número (sin decimales) Su peso o estatura será otro número (ahora con decimales). Su nombre será una cadena de texto. Su fecha de nacimiento será precisamente eso, una fecha. A la pregunta «¿está usted soltero/a?» la respuesta será lo que llamamos una variable binaria: una variable que solo puede valer TRUE (si está soltero/a) y FALSE (en otro caso). Existen más tipos (como números complejos) pero con estos nos valdrá para nuestra introducción. "],["numericas.html", "5.1 Variables numéricas", " 5.1 Variables numéricas [X] Variables numéricas (individuales) [ ] Variables de caracteres [ ] Variables lógicas [ ] Variables de tipo fecha Probablemente el dato más sencillo y obvio de entender sean los datos numéricos, datos que ya hemos usado en nuestros primeros pasos como calculadora. a &lt;- 1 b &lt;- 2 a + b ## [1] 3 En el código anterior, tanto a como b como la suma a + b son de tipo numérico, algo que podemos comprobar con la función class() (nos devuelve numeric). # Clase de las variables class(a) ## [1] &quot;numeric&quot; class(b) ## [1] &quot;numeric&quot; class(a + b) ## [1] &quot;numeric&quot; También podemos comprobar su naturaleza con typeof(), que nos devuelve la naturaleza del dato tal cual es guardada en R. # Topología interna typeof(a) ## [1] &quot;double&quot; typeof(b) ## [1] &quot;double&quot; typeof(a + b) ## [1] &quot;double&quot; Fíjate que ambas órdenes combinadas nos dicen que las variables son de tipo numérico pero concretamente de tipo double: dichas variables son entendidas internamente como números con decimales (aunque no los veamos), lo que en matemáticas se llaman números reales (por curiosidad: el término double viene de lenguajes de programación antiguos como C, que significa «doble precisión», para indicarle que reserve 8 bytes - 64 bits - de memoria). Durante el curso no distinguiremos entre distintos tipos de números, para nosotros serán siempre de clase numeric y de tipo double, pero podríamos definir números enteros o integer (sin decimales, ahorrando huecos en memoria). # Dato numérico (entero) a &lt;- 1L class(a) ## [1] &quot;integer&quot; typeof(a) ## [1] &quot;integer&quot; Con los datos numéricos podemos realizar todas las operaciones que se nos ocurriría hacer en una calculadora, como sumar (+), restar (-), multiplicar (*), dividir (/), raíz cuadrada (sqrt()), valor absoluto (abs()), elevar al cuadrado (^2), elevar al cubo (^3), etc. # Definimos dos variables numéricas a &lt;- 1 b &lt;- -2 # Suma y resta a + b ## [1] -1 a - b ## [1] 3 # Multiplicación y división a * b ## [1] -2 a / b ## [1] -0.5 # Raíz cuadrada sqrt(a) ## [1] 1 # Valor absoluto abs(b) ## [1] 2 # Potencias a^2 ## [1] 1 b^3 ## [1] -8 "],["caracter.html", "5.2 Variables de tipo caracter (texto)", " 5.2 Variables de tipo caracter (texto) [X] Variables numéricas (individuales) [X] Variables de caracteres [ ] Variables lógicas [ ] Variables de tipo fecha Pero no solo de números viven los datos: imagina que además de la edad de una persona queremos guardar su nombre. edad &lt;- 32 nombre &lt;- &quot;Javier&quot; class(edad) ## [1] &quot;numeric&quot; typeof(edad) ## [1] &quot;double&quot; class(nombre) ## [1] &quot;character&quot; typeof(nombre) ## [1] &quot;character&quot; Fíjate que ahora tenemos en nombre una variable de tipo character, es decir, una cadena de texto (conocido en otros lenguajes como string o char): letras y caracteres entre comillas. 5.2.1 Nuestra primera función: paste/paste0 Las cadenas de texto son un tipo especial de dato, con los que obviamente no podremos hacer operaciones aritméticas, pero si podemos hacer operaciones propias de cadenas de texto como puede ser la función paste(). Dicha función nos permite pegar dos cadenas de caracteres, decidiendo que caracter queremos que vaya entre palabra con el argumento sep =. nombre &lt;- &quot;Javier&quot; apellido &lt;- &quot;Álvarez&quot; paste(nombre, apellido, sep = &quot;&quot;) # todo junto ## [1] &quot;JavierÁlvarez&quot; paste(nombre, apellido, sep = &quot; &quot;) # separados por un espacio ## [1] &quot;Javier Álvarez&quot; paste(nombre, apellido, sep = &quot;.&quot;) # separados por un punto . ## [1] &quot;Javier.Álvarez&quot; Si queremos pegar cadenas de texto sin ningún tipo de caracter, existe una forma más abreviada y limpia de ejecutar la orden, usando la función paste0() # Son equivalentes paste(nombre, apellido, sep = &quot;&quot;) # todo junto ## [1] &quot;JavierÁlvarez&quot; paste0(nombre, apellido) # todo junto sin nada separando ## [1] &quot;JavierÁlvarez&quot; Cuando hemos ejecutado paste() estamos ejecutando lo que se conoce como una función: una palabra reservada que representa un conjunto de órdenes, y que se ejecuta a partir de unos argumentos de entrada. En el caso de la función paste() puede tener varios argumentos: las cadenas de texto que queremos copiar, y un argumento opcional llamado sep, que podemos darle un valor con concreto o dejarlo sin especificar. Lo que hará R será tomar su valor por defecto igual a sep = &quot; &quot; (por defecto, la función paste() pega cadenas de texto con un espacio entre ellas). Prueba a ejecutar ? paste en consola para ver las opciones en el panel de ayuda. # Son equivalentes paste(nombre, apellido, sep = &quot; &quot;) ## [1] &quot;Javier Álvarez&quot; paste(nombre, apellido) ## [1] &quot;Javier Álvarez&quot; 5.2.2 Nuestro primer paquete: glue Otra forma más intuitiva de trabajar con textos y variables numéricas es usar el paquete {glue}, que nos permite pegar cadenas de texto a variables numéricas de forma simbólica. install.packages(&quot;glue&quot;) # solo la primera vez library(glue) Recuerda que install.packages() es solo necesario la primera que «compramos el libro»: nos bajamos una serie de archivos a nuestro ordenador. Una vez que hemos comprado el libro, cada vez que queramos usarlo bastará con indicarle que nos traiga ese libro concreto con library(). El paquete {glue} nos permite pegar de una forma mucho más legible cadenas de texto # Ejemplo 1 edad &lt;- 32 glue(&quot;La edad es de {edad} años&quot;) ## La edad es de 32 años paste(&quot;La edad es de&quot;, edad, &quot;años&quot;) # equivalente ## [1] &quot;La edad es de 32 años&quot; # Ejemplo 2 edad &lt;- 32 unidades &lt;- &quot;años&quot; glue(&quot;La edad es de {edad} {unidades}&quot;) ## La edad es de 32 años También podemos hacer uso de dicha función sin tener los valores numéricos previamente guardados en variables. # Otra forma sin definir variables a priori glue(&quot;La edad es de {32} años&quot;) ## La edad es de 32 años "],["logicas.html", "5.3 Variables lógicas (TRUE/FALSE)", " 5.3 Variables lógicas (TRUE/FALSE) [X] Variables numéricas (individuales) [X] Variables de caracteres [X] Variables lógicas [ ] Variables de tipo fecha Probablemente el tipo de datos más importante en todo lenguaje de programación son las variables lógicas. Un valor lógico puede tomar dos valores (en realidad pueden tomar un tercer valor, NA, las siglas de not available para representar datos ausentes, pero lo veremos más adelante): TRUE (guardado internamente como un 1). FALSE (guardado internamente como un 0). Este tipo de variables, también conocidas como variables binarias (solo dos valores) o booleanas, son la base de la programación ya que cada bit de nuestro ordenador puede guardar un 1 o un 0. soltero &lt;- TRUE # ¿Es soltero? --&gt; SÍ carnet_conducir &lt;- FALSE # ¿Tiene carnet de conducir? --&gt; NO class(soltero) ## [1] &quot;logical&quot; typeof(soltero) ## [1] &quot;logical&quot; class(carnet_conducir) ## [1] &quot;logical&quot; typeof(carnet_conducir) ## [1] &quot;logical&quot; Ahora nuestas variables son guardadas como logical, y pueden tomar los valores TRUE/FALSE, aunque internamente son guardados como 1/0. Es importante entender que no son variables de texto: &quot;TRUE&quot; es un texto (internamente idéntico a rojo o azul) TRUE es una variable lógica # Texto texto &lt;- &quot;TRUE&quot; texto + 1 ## Error in texto + 1: argumento no-numérico para operador binario # Lógica logica &lt;- TRUE logica + 1 ## [1] 2 Estos valores suelen ser resultado de evaluar condiciones lógicas. Por ejemplo, imaginemos que queremos comprobar si una persona está soltero o no, y si tiene carnet de conducir o no. Basta con que ejecutemos la orden soltero == TRUE, que nos devolverá TRUE si está soltero, y FALSE en caso contrario. De igual manera podremos hacer carnet_conducir == TRUE. IMPORTANTE: cuando queremos comparar si un elemento es igual a otro, usaremos el operador de comparación ==, pudiendo usar también su opuesto != («distinto de»). soltero == TRUE ## [1] TRUE soltero != TRUE # igual que soltero == FALSE ## [1] FALSE carnet_conducir == TRUE ## [1] FALSE carnet_conducir != TRUE ## [1] TRUE Por el mismo razonamiento podemos comparar si una variable numérica o de tipo caracter es igual o distinto a un valor dado, incluso para las numéricas podemos comparar si son menores o mayores que un número. ¿Tiene la persona menos de 32 años? ¿Tiene justo 32 años? ¿Tiene 32 años o más? edad &lt; 32 ## [1] FALSE edad == 32 ## [1] TRUE edad &gt;= 32 ## [1] TRUE ¿La persona se llama Carlos? nombre == &quot;Carlos&quot; ## [1] FALSE Fíjate que para comparaciones tenemos «igual a» == frente distinto !=, pero también comparaciones de orden como &lt;=, &gt; o &gt;=. Las condiciones lógicas pueden ser combinadas, principalmente de dos maneras: Intersección: todas las condiciones concatenadas se deben cumplir (conjunción y, operador &amp;) para devolver un TRUE. Unión: basta con que una de las condiciones concatenadas se cumpla (conjunción o, operador |) para devolver un TRUE. Por ejemplo, podríamos preguntarnos si la persona tiene más de 32 años y está soltero (AMBAS deben cumplirse). edad &gt; 32 &amp; soltero == TRUE ## [1] FALSE # Equivalente (al ser soltero un valor ya de por si lógico) edad &gt; 32 &amp; soltero ## [1] FALSE Vemos que el resultado es FALSE ya que solo se cumple una de las condiciones: devolvería TRUE si preguntamos si tiene más de 30 años y está soltero, o si solo pedimos una de las dos condiciones (¿está soltero y/o tiene más de 32 años?). edad &gt; 32 | soltero # nos sirve con que alguna se cumpla ## [1] TRUE edad &gt; 32 &amp; soltero # deben cumplirse ambas ## [1] FALSE edad &gt; 30 &amp; soltero # deben cumplirse ambas ## [1] TRUE "],["fechas.html", "5.4 Variables de tipo fecha", " 5.4 Variables de tipo fecha [X] Variables numéricas (individuales) [X] Variables de caracteres [X] Variables lógicas [X] Variables de tipo fecha Por último, vamos a ver un tipo de datos muy especial: los datos de tipo fecha. Una fecha podría ser a priori una simple cadena de texto &quot;2021-04-21&quot; pero podemos usar la función as.Date() para que R entienda que esa cadena de texto representa un instante temporal. Fíjate la diferencia entre una fecha en texto y una fecha con as.Date(). # Cadena de texto fecha_char &lt;- &quot;2021-04-21&quot; fecha_char + 1 ## Error in fecha_char + 1: argumento no-numérico para operador binario # Fecha, mostrada como un texto pero guardada internamente como un número fecha_date &lt;- as.Date(fecha_char, format = &quot;%Y-%m-%d&quot;) fecha_date + 1 ## [1] &quot;2021-04-22&quot; En el momento en que convertimos la cadena de texto a fecha, aunque se visualice como un texto, internamente es un número, por lo que podemos restar fechas (días entre ambas), podemos sumar números a fechas (fecha días después), etc. Como ya hemos dicho, las fechas y momentos temporales no serán meras cadenas de caracter sino que tienen clases especiales asociadas. Las fechas serán guardadas internamente como el número de días transcurridos desde el 1 de enero de 1970, y las horas como número de segundos desde el 1 de enero de 1970 (para la clase POSIXct) o una lista de segundos, minutos y horas (para la clase POSIXlt). ¿Cómo obtener automáticamente la fecha de hoy? La función Sys.Date() nos devuelve directamente la fecha y hora en el momento de la ejecución de la orden. fecha &lt;- Sys.Date() fecha ## [1] &quot;2021-12-27&quot; fecha - 7 # una semana antes ## [1] &quot;2021-12-20&quot; class(fecha) # de clase fecha ## [1] &quot;Date&quot; Para convertir una cadena de texto a fecha, basta usar la función as.Date(), pasándole como argumento la fecha en formato &quot;yyyy-mm-dd&quot; por defecto. as.Date(&quot;2021-03-10&quot;) # formato por defecto ## [1] &quot;2021-03-10&quot; Si introducimos otro tipo de formato, debemos especificárselo en un segundo argumento, para R sepa el formato de fecha que le estamos pasando as.Date(&quot;10-03-2020&quot;, &quot;%d-%m-%Y&quot;) # con día-mes-año (4 cifras) ## [1] &quot;2020-03-10&quot; as.Date(&quot;10-03-20&quot;, &quot;%d-%m-%y&quot;) # con día-mes-año (2 cifras) ## [1] &quot;2020-03-10&quot; as.Date(&quot;03-10-2020&quot;, &quot;%m-%d-%Y&quot;) # con mes-día-año (4 cifras) ## [1] &quot;2020-03-10&quot; as.Date(&quot;Octubre 21, 1995 21:24&quot;, &quot;%B %d, %Y %H:%M&quot;) # fecha escrita ## [1] NA ERROR: sin pasar a fecha no se puede operar Si tenemos una fecha como caracter, nunca podremos hacer operaciones (por ejemplo, restarle una unidad temporal, en este caso un día). &quot;2021-03-10&quot; - 1 # error ## Error in &quot;2021-03-10&quot; - 1: argumento no-numérico para operador binario Fíjate la diferencia cuando lo convertimos en fecha fecha &lt;- as.Date(&quot;2021-03-10&quot;) - 1 # día previo fecha ## [1] &quot;2021-03-09&quot; Dentro del entorno del paquete {lubridate} tenemos bastantes funciones útiles para trabajar con fechas como las siguientes install.packages(&quot;lubridate&quot;) # solo la primera vez library(lubridate) ymd_hms(&quot;2017-11-28T14:02:00&quot;) # convertir a fecha una cadena año-mes-día + hora ## [1] &quot;2017-11-28 14:02:00 UTC&quot; ydm_hms(&quot;2017-22-12 10:00:00&quot;) # convertir a fecha una cadena año-día-mes + hora ## [1] &quot;2017-12-22 10:00:00 UTC&quot; dmy_hms(&quot;1 Jan 2017 23:59:59&quot;) # convertir a fecha una cadena textual de fecha + hora ## [1] &quot;2017-01-01 23:59:59 UTC&quot; mdy(&quot;July 4th, 2000&quot;) # convertir a fecha una cadena textual de fecha ## [1] &quot;2000-07-04&quot; ymd(20170131) ## [1] &quot;2017-01-31&quot; Además el paquete nos proporciona herramientas para extraer la fecha y hora actuales con las funciones today() y now() today() ## [1] &quot;2021-12-27&quot; now() ## [1] &quot;2021-12-27 00:30:28 CET&quot; También tenemos disponibles en dicho paquete funciones para extraer facilmente algunas variables temporales como el día de la semana, el mes o el cuatrimestre, con las funciones year(), months(), day() o wday() (día de la semana). fecha &lt;- now() year(fecha) ## [1] 2021 month(fecha) ## [1] 12 day(fecha) ## [1] 27 wday(fecha, week_start = 1) # Día de la semana (empezando por el lunes) ## [1] 1 hour(fecha) ## [1] 0 minute(fecha) ## [1] 30 second(fecha) ## [1] 28.55104 week(fecha) # Número de semana (del año) ## [1] 52 Al igual que podemos realizar operaciones aritméticas sencillas con las fechas, también podemos realizar comparaciones, por ejemplo, si el día actual es menor o mayor que otra fecha dada. fecha_actual &lt;- now() fecha_actual &gt; ymd(20170131) # Actual vs 2017-01-31 ## [1] TRUE fecha_actual &gt; ymd(21000131) # Actual vs 2100-01-31 ## [1] FALSE "],["consejos-2.html", "5.5 Consejos", " 5.5 Consejos CONSEJOS Recuperar un comando y autocompletar Si haces click con el ratón en la consola y pulsas la flecha «arriba» del teclado, te irá apareciendo todo el historial de órdenes ejecutadas. Es una manera de ahorrar tiempo para ejecutar órdenes similares a las ya ejecutadas. Si empiezas a escribir el nombre de una variable pero no te acuerdas exactamente de su nombre, pulsando tabulador te autocompletará solo. Convertir tipos de datos A veces la lectura de variables numéricas de nuestros archivos puede hacer que un número, por ejemplo 1, sea leído como la cadena de texto &quot;1&quot;, con la que no podemos operar como un número. Las funciones as.numeric(), as.character() y as.logical() nos permiten convertir una variable en tipo numérico, caracter o lógico, respectivamente. &quot;1&quot; + 1 ## Error in &quot;1&quot; + 1: argumento no-numérico para operador binario as.numeric(&quot;1&quot;) + 1 ## [1] 2 as.character(1) ## [1] &quot;1&quot; as.logical(c(0, 1)) ## [1] FALSE TRUE "],["ejercicios-1.html", "5.6 📝 Ejercicios", " 5.6 📝 Ejercicios (haz click en las flechas para ver soluciones) 📝Ejercicio 1: define una variable que guarde tu edad, otra con tu nombre, otra respondiendo a la pregunta «¿tengo hermanos?» y otra con la fecha de tu nacimiento. Solución: edad &lt;- 32 # tipo numeric nombre &lt;- &quot;Javier&quot; # tipo caracter hermanos &lt;- TRUE # tipo hermanos fecha_nacimiento &lt;- as.Date(&quot;1989-09-10&quot;) # tipo fecha 📝Ejercicio 2: define otra variable con tus apellidos y junta las variables nombre y apellidos en una sola variable nombre_completo. Solución: # Apellidos apellidos &lt;- &quot;Álvarez Liébana&quot; # Pegamos nombre_completo &lt;- glue(&quot;{nombre} {apellidos}&quot;) nombre_completo ## Javier Álvarez Liébana # Otra forma nombre_completo &lt;- paste(nombre, apellidos) nombre_completo ## [1] &quot;Javier Álvarez Liébana&quot; 📝Ejercicio 3: construye una frase que diga «Hola, me llamo … y tengo … años. Nací el … de … de …» (con el nombre completo). Solución: dia_nacimiento &lt;- day(fecha_nacimiento) mes_nacimiento &lt;- month(fecha_nacimiento) a_nacimiento &lt;- year(fecha_nacimiento) glue(&quot;Hola, me llamo {nombre_completo} y tengo {edad} años. Nací el {dia_nacimiento} del {mes_nacimiento} de {a_nacimiento}&quot;) ## Hola, me llamo Javier Álvarez Liébana y tengo 32 años. Nací el 10 del 9 de 1989 📝Ejercicio 4: calcula los días que han pasado desde la fecha de tu nacimiento Solución: days(today() - fecha_nacimiento) ## [1] &quot;11796d 0H 0M 0S&quot; 📝Ejercicio 5: obtén una variable lógica que nos diga si se cumplen (todas) las condiciones i) menor de 30 años; ii) con hermanos; iii) nacido en 1990 o posterior. Solución: # Se tienen que cumplir todas edad &lt; 30 &amp; fecha_nacimiento &gt;= as.Date(&quot;1990-01-01&quot;) &amp; hermanos ## [1] FALSE 📝Ejercicio 6: obtén una variable lógica que nos diga si se cumplen (al menos) alguna de las condiciones i) menor de 30 años; ii) con hermanos; iii) nacido en 1990 o posterior. Solución: # Se tienen que cumplir todas edad &lt; 30 | fecha_nacimiento &gt;= as.Date(&quot;1990-01-01&quot;) | hermanos ## [1] TRUE 📝Ejercicio 7: calcula la fecha 11 días más tarde a tu fecha de nacimiento. Obtén la semana del año de dicha fecha y el día de la semana. Solución: # Podemos sumar porque es fecha fecha_post &lt;- fecha_nacimiento + 11 fecha_post ## [1] &quot;1989-09-21&quot; # Semana del año week(fecha_post) ## [1] 38 # Día de la semana (versión americana, empiezan el domingo) wday(fecha_post) ## [1] 5 # Día de la semana (versión española) wday(fecha_post, week_start = 1) ## [1] 4 # Día de la semana en texto weekdays(fecha_post) ## [1] &quot;Thursday&quot; 📝Ejercicio 8: define dos números cualesquiera en variable a y b. Calcula su suma y determina cual es mayor. Solución: a &lt;- -5 b &lt;- 7 # Suma c &lt;- a + b c ## [1] 2 # Comparaciones a == b # ¿a = b? ## [1] FALSE a &lt; b # ¿a &lt; b? ## [1] TRUE "],["bibliografía.html", "Bibliografía", " Bibliografía "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
